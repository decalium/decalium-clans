--- a/net/minecraft/world/entity/item/FallingBlockEntity.java
+++ b/net/minecraft/world/entity/item/FallingBlockEntity.java
@@ -1,12 +1,12 @@
 package net.minecraft.world.entity.item;
 
+import java.util.Iterator;
 import java.util.function.Predicate;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtUtils;
-import net.minecraft.nbt.Tag;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundAddEntityPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
@@ -16,6 +16,7 @@
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.tags.BlockTags;
 import net.minecraft.tags.FluidTags;
+import net.minecraft.tags.Tag;
 import net.minecraft.util.Mth;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.entity.Entity;
@@ -23,9 +24,11 @@
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.MoverType;
 import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.context.BlockPlaceContext;
 import net.minecraft.world.item.context.DirectionalPlaceContext;
 import net.minecraft.world.level.ClipContext;
 import net.minecraft.world.level.GameRules;
+import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.AnvilBlock;
 import net.minecraft.world.level.block.Block;
@@ -40,27 +43,32 @@
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.craftbukkit.v1_17_R1.event.CraftEventFactory; // CraftBukkit
 
 public class FallingBlockEntity extends Entity {
-    private BlockState blockState = Blocks.SAND.defaultBlockState();
+
+    private BlockState blockState;
     public int time;
-    public boolean dropItem = true;
+    public boolean dropItem;
     private boolean cancelDrop;
-    private boolean hurtEntities;
-    private int fallDamageMax = 40;
+    public boolean hurtEntities;
+    private int fallDamageMax;
     private float fallDamagePerDistance;
     public CompoundTag blockData;
     protected static final EntityDataAccessor<BlockPos> DATA_START_POS = SynchedEntityData.defineId(FallingBlockEntity.class, EntityDataSerializers.BLOCK_POS);
 
     public FallingBlockEntity(EntityType<? extends FallingBlockEntity> type, Level world) {
         super(type, world);
+        this.blockState = Blocks.SAND.defaultBlockState();
+        this.dropItem = true;
+        this.fallDamageMax = 40;
     }
 
     public FallingBlockEntity(Level world, double x, double y, double z, BlockState block) {
         this(EntityType.FALLING_BLOCK, world);
         this.blockState = block;
         this.blocksBuilding = true;
-        this.setPos(x, y + (double)((1.0F - this.getBbHeight()) / 2.0F), z);
+        this.setPos(x, y + (double) ((1.0F - this.getBbHeight()) / 2.0F), z);
         this.setDeltaMovement(Vec3.ZERO);
         this.xo = x;
         this.yo = y;
@@ -68,39 +76,61 @@
         this.setStartPos(this.blockPosition());
     }
 
+    @Override
     public boolean isAttackable() {
         return false;
     }
 
     public void setStartPos(BlockPos pos) {
-        this.entityData.set(DATA_START_POS, pos);
+        this.entityData.set(FallingBlockEntity.DATA_START_POS, pos);
     }
 
     public BlockPos getStartPos() {
-        return this.entityData.get(DATA_START_POS);
+        return (BlockPos) this.entityData.get(FallingBlockEntity.DATA_START_POS);
     }
 
+    @Override
     protected Entity.MovementEmission getMovementEmission() {
         return Entity.MovementEmission.NONE;
     }
 
+    @Override
     protected void defineSynchedData() {
-        this.entityData.define(DATA_START_POS, BlockPos.ZERO);
+        this.entityData.define(FallingBlockEntity.DATA_START_POS, BlockPos.ZERO);
     }
 
+    @Override
     public boolean isPickable() {
         return !this.isRemoved();
     }
 
+    @Override
     public void tick() {
+        // Paper start - fix sand duping
+        if (this.isRemoved()) {
+            return;
+        }
+        // Paper end - fix sand duping
         if (this.blockState.isAir()) {
             this.discard();
         } else {
             Block block = this.blockState.getBlock();
+            BlockPos blockposition;
+
             if (this.time++ == 0) {
-                BlockPos blockPos = this.blockPosition();
-                if (this.level.getBlockState(blockPos).is(block)) {
-                    this.level.removeBlock(blockPos, false);
+                blockposition = this.blockPosition();
+                // Paper start - fix cancelling block falling causing client desync
+                if (this.level.getBlockState(blockposition).is(block)) {
+                    if (CraftEventFactory.callEntityChangeBlockEvent(this, blockposition, Blocks.AIR.defaultBlockState()).isCancelled()) {
+                        if (this.level.getBlockState(blockposition).is(block)) { //if listener didn't update the block
+                            ((ServerLevel) level).getChunkSource().blockChanged(blockposition);
+                        }
+                        this.discard();
+                        return;
+                    } else {
+                        this.level.removeBlock(blockposition, false);
+                    }
+                    // Paper end - fix cancelling block falling causing client desync
                 } else if (!this.level.isClientSide) {
                     this.discard();
                     return;
@@ -112,83 +142,114 @@
             }
 
             this.move(MoverType.SELF, this.getDeltaMovement());
+
+            // Paper start - fix sand duping
+            if (this.isRemoved()) {
+                return;
+            }
+            // Paper end - fix sand duping
+
+            // Paper start - Configurable EntityFallingBlock height nerf
+            if (this.level.paperConfig.fallingBlockHeightNerf != 0 && this.getY() > this.level.paperConfig.fallingBlockHeightNerf) {
+                if (this.dropItem && this.level.getGameRules().getBoolean(GameRules.RULE_DOENTITYDROPS)) {
+                    this.spawnAtLocation(block);
+                }
+
+                this.discard();
+                return;
+            }
+            // Paper end
             if (!this.level.isClientSide) {
-                BlockPos blockPos2 = this.blockPosition();
-                boolean bl = this.blockState.getBlock() instanceof ConcretePowderBlock;
-                boolean bl2 = bl && this.level.getFluidState(blockPos2).is(FluidTags.WATER);
-                double d = this.getDeltaMovement().lengthSqr();
-                if (bl && d > 1.0D) {
-                    BlockHitResult blockHitResult = this.level.clip(new ClipContext(new Vec3(this.xo, this.yo, this.zo), this.position(), ClipContext.Block.COLLIDER, ClipContext.Fluid.SOURCE_ONLY, this));
-                    if (blockHitResult.getType() != HitResult.Type.MISS && this.level.getFluidState(blockHitResult.getBlockPos()).is(FluidTags.WATER)) {
-                        blockPos2 = blockHitResult.getBlockPos();
-                        bl2 = true;
+                blockposition = this.blockPosition();
+                boolean flag = this.blockState.getBlock() instanceof ConcretePowderBlock;
+                boolean flag1 = flag && this.level.getFluidState(blockposition).is((Tag) FluidTags.WATER);
+                double d0 = this.getDeltaMovement().lengthSqr();
+
+                if (flag && d0 > 1.0D) {
+                    BlockHitResult movingobjectpositionblock = this.level.clip(new ClipContext(new Vec3(this.xo, this.yo, this.zo), this.position(), ClipContext.Block.COLLIDER, ClipContext.Fluid.SOURCE_ONLY, this));
+
+                    if (movingobjectpositionblock.getType() != HitResult.Type.MISS && this.level.getFluidState(movingobjectpositionblock.getBlockPos()).is((Tag) FluidTags.WATER)) {
+                        blockposition = movingobjectpositionblock.getBlockPos();
+                        flag1 = true;
                     }
                 }
 
-                if (!this.onGround && !bl2) {
-                    if (!this.level.isClientSide && (this.time > 100 && (blockPos2.getY() <= this.level.getMinBuildHeight() || blockPos2.getY() > this.level.getMaxBuildHeight()) || this.time > 600)) {
+                if (!this.onGround && !flag1) {
+                    if (!this.level.isClientSide && (this.time > 100 && (blockposition.getY() <= this.level.getMinBuildHeight() || blockposition.getY() > this.level.getMaxBuildHeight()) || this.time > 600)) {
                         if (this.dropItem && this.level.getGameRules().getBoolean(GameRules.RULE_DOENTITYDROPS)) {
-                            this.spawnAtLocation(block);
+                            this.spawnAtLocation((ItemLike) block);
                         }
 
                         this.discard();
                     }
                 } else {
-                    BlockState blockState = this.level.getBlockState(blockPos2);
+                    BlockState iblockdata = this.level.getBlockState(blockposition);
+
                     this.setDeltaMovement(this.getDeltaMovement().multiply(0.7D, -0.5D, 0.7D));
-                    if (!blockState.is(Blocks.MOVING_PISTON)) {
+                    if (!iblockdata.is(Blocks.MOVING_PISTON)) {
                         if (!this.cancelDrop) {
-                            boolean bl3 = blockState.canBeReplaced(new DirectionalPlaceContext(this.level, blockPos2, Direction.DOWN, ItemStack.EMPTY, Direction.UP));
-                            boolean bl4 = FallingBlock.isFree(this.level.getBlockState(blockPos2.below())) && (!bl || !bl2);
-                            boolean bl5 = this.blockState.canSurvive(this.level, blockPos2) && !bl4;
-                            if (bl3 && bl5) {
-                                if (this.blockState.hasProperty(BlockStateProperties.WATERLOGGED) && this.level.getFluidState(blockPos2).getType() == Fluids.WATER) {
-                                    this.blockState = this.blockState.setValue(BlockStateProperties.WATERLOGGED, Boolean.valueOf(true));
+                            boolean flag2 = iblockdata.canBeReplaced((BlockPlaceContext) (new DirectionalPlaceContext(this.level, blockposition, Direction.DOWN, ItemStack.EMPTY, Direction.UP)));
+                            boolean flag3 = FallingBlock.isFree(this.level.getBlockState(blockposition.below())) && (!flag || !flag1);
+                            boolean flag4 = this.blockState.canSurvive(this.level, blockposition) && !flag3;
+
+                            if (flag2 && flag4) {
+                                if (this.blockState.hasProperty(BlockStateProperties.WATERLOGGED) && this.level.getFluidState(blockposition).getType() == Fluids.WATER) {
+                                    this.blockState = (BlockState) this.blockState.setValue(BlockStateProperties.WATERLOGGED, true);
                                 }
 
-                                if (this.level.setBlock(blockPos2, this.blockState, 3)) {
-                                    ((ServerLevel)this.level).getChunkSource().chunkMap.broadcast(this, new ClientboundBlockUpdatePacket(blockPos2, this.level.getBlockState(blockPos2)));
+                                // CraftBukkit start
+                                if (CraftEventFactory.callEntityChangeBlockEvent(this, blockposition, this.blockState).isCancelled()) {
+                                    this.discard(); // SPIGOT-6586 called before the event in previous versions
+                                    return;
+                                }
+                                // CraftBukkit end
+                                if (this.level.setBlock(blockposition, this.blockState, 3)) {
+                                    ((ServerLevel) this.level).getChunkSource().chunkMap.broadcast(this, new ClientboundBlockUpdatePacket(blockposition, this.level.getBlockState(blockposition)));
                                     this.discard();
                                     if (block instanceof Fallable) {
-                                        ((Fallable)block).onLand(this.level, blockPos2, this.blockState, blockState, this);
+                                        ((Fallable) block).onLand(this.level, blockposition, this.blockState, iblockdata, this);
                                     }
 
                                     if (this.blockData != null && this.blockState.hasBlockEntity()) {
-                                        BlockEntity blockEntity = this.level.getBlockEntity(blockPos2);
-                                        if (blockEntity != null) {
-                                            CompoundTag compoundTag = blockEntity.save(new CompoundTag());
+                                        BlockEntity tileentity = this.level.getBlockEntity(blockposition);
 
-                                            for(String string : this.blockData.getAllKeys()) {
-                                                Tag tag = this.blockData.get(string);
-                                                if (!"x".equals(string) && !"y".equals(string) && !"z".equals(string)) {
-                                                    compoundTag.put(string, tag.copy());
+                                        if (tileentity != null) {
+                                            CompoundTag nbttagcompound = tileentity.save(new CompoundTag());
+                                            Iterator iterator = this.blockData.getAllKeys().iterator();
+
+                                            while (iterator.hasNext()) {
+                                                String s = (String) iterator.next();
+                                                net.minecraft.nbt.Tag nbtbase = this.blockData.get(s);
+
+                                                if (!"x".equals(s) && !"y".equals(s) && !"z".equals(s)) {
+                                                    nbttagcompound.put(s, nbtbase.copy());
                                                 }
                                             }
 
                                             try {
-                                                blockEntity.load(compoundTag);
-                                            } catch (Exception var16) {
-                                                LOGGER.error("Failed to load block entity from falling block", (Throwable)var16);
+                                                tileentity.load(nbttagcompound);
+                                            } catch (Exception exception) {
+                                                FallingBlockEntity.LOGGER.error("Failed to load block entity from falling block", exception);
                                             }
 
-                                            blockEntity.setChanged();
+                                            tileentity.setChanged();
                                         }
                                     }
                                 } else if (this.dropItem && this.level.getGameRules().getBoolean(GameRules.RULE_DOENTITYDROPS)) {
                                     this.discard();
-                                    this.callOnBrokenAfterFall(block, blockPos2);
-                                    this.spawnAtLocation(block);
+                                    this.callOnBrokenAfterFall(block, blockposition);
+                                    this.spawnAtLocation((ItemLike) block);
                                 }
                             } else {
                                 this.discard();
                                 if (this.dropItem && this.level.getGameRules().getBoolean(GameRules.RULE_DOENTITYDROPS)) {
-                                    this.callOnBrokenAfterFall(block, blockPos2);
-                                    this.spawnAtLocation(block);
+                                    this.callOnBrokenAfterFall(block, blockposition);
+                                    this.spawnAtLocation((ItemLike) block);
                                 }
                             }
                         } else {
                             this.discard();
-                            this.callOnBrokenAfterFall(block, blockPos2);
+                            this.callOnBrokenAfterFall(block, blockposition);
                         }
                     }
                 }
@@ -200,41 +261,50 @@
 
     public void callOnBrokenAfterFall(Block block, BlockPos pos) {
         if (block instanceof Fallable) {
-            ((Fallable)block).onBrokenAfterFall(this.level, pos, this);
+            ((Fallable) block).onBrokenAfterFall(this.level, pos, this);
         }
 
     }
 
+    @Override
     public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
         if (!this.hurtEntities) {
             return false;
         } else {
             int i = Mth.ceil(fallDistance - 1.0F);
+
             if (i < 0) {
                 return false;
             } else {
-                Predicate<Entity> predicate;
-                DamageSource damageSource2;
+                Predicate<Entity> predicate; // CraftBukkit - decompile error
+                DamageSource damagesource1;
+
                 if (this.blockState.getBlock() instanceof Fallable) {
-                    Fallable fallable = (Fallable)this.blockState.getBlock();
+                    Fallable fallable = (Fallable) this.blockState.getBlock();
+
                     predicate = fallable.getHurtsEntitySelector();
-                    damageSource2 = fallable.getFallDamageSource();
+                    damagesource1 = fallable.getFallDamageSource();
                 } else {
                     predicate = EntitySelector.NO_SPECTATORS;
-                    damageSource2 = DamageSource.FALLING_BLOCK;
+                    damagesource1 = DamageSource.FALLING_BLOCK;
                 }
 
-                float f = (float)Math.min(Mth.floor((float)i * this.fallDamagePerDistance), this.fallDamageMax);
+                float f2 = (float) Math.min(Mth.floor((float) i * this.fallDamagePerDistance), this.fallDamageMax);
+
                 this.level.getEntities(this, this.getBoundingBox(), predicate).forEach((entity) -> {
-                    entity.hurt(damageSource2, f);
+                    CraftEventFactory.entityDamage = this; // CraftBukkit
+                    entity.hurt(damagesource1, f2);
+                    CraftEventFactory.entityDamage = null; // CraftBukkit
                 });
-                boolean bl = this.blockState.is(BlockTags.ANVIL);
-                if (bl && f > 0.0F && this.random.nextFloat() < 0.05F + (float)i * 0.05F) {
-                    BlockState blockState = AnvilBlock.damage(this.blockState);
-                    if (blockState == null) {
+                boolean flag = this.blockState.is((Tag) BlockTags.ANVIL);
+
+                if (flag && f2 > 0.0F && this.random.nextFloat() < 0.05F + (float) i * 0.05F) {
+                    BlockState iblockdata = AnvilBlock.damage(this.blockState);
+
+                    if (iblockdata == null) {
                         this.cancelDrop = true;
                     } else {
-                        this.blockState = blockState;
+                        this.blockState = iblockdata;
                     }
                 }
 
@@ -243,6 +313,7 @@
         }
     }
 
+    @Override
     protected void addAdditionalSaveData(CompoundTag nbt) {
         nbt.put("BlockState", NbtUtils.writeBlockState(this.blockState));
         nbt.putInt("Time", this.time);
@@ -256,14 +327,27 @@
 
     }
 
+    @Override
     protected void readAdditionalSaveData(CompoundTag nbt) {
         this.blockState = NbtUtils.readBlockState(nbt.getCompound("BlockState"));
+        // Paper start - Block FallingBlocks with Command Blocks
+        final Block b = this.blockState.getBlock();
+        if (this.level.paperConfig.filterNBTFromSpawnEgg
+            && (b == Blocks.COMMAND_BLOCK
+            || b == Blocks.REPEATING_COMMAND_BLOCK
+            || b == Blocks.CHAIN_COMMAND_BLOCK
+            || b == Blocks.JIGSAW
+            || b == Blocks.STRUCTURE_BLOCK
+            || b instanceof net.minecraft.world.level.block.GameMasterBlock)) {
+            this.blockState = Blocks.STONE.defaultBlockState();
+        }
+        // Paper end
         this.time = nbt.getInt("Time");
         if (nbt.contains("HurtEntities", 99)) {
             this.hurtEntities = nbt.getBoolean("HurtEntities");
             this.fallDamagePerDistance = nbt.getFloat("FallHurtAmount");
             this.fallDamageMax = nbt.getInt("FallHurtMax");
-        } else if (this.blockState.is(BlockTags.ANVIL)) {
+        } else if (this.blockState.is((Tag) BlockTags.ANVIL)) {
             this.hurtEntities = true;
         }
 
@@ -279,6 +363,14 @@
             this.blockState = Blocks.SAND.defaultBlockState();
         }
 
+        // Paper start - Try and load origin location from the old NBT tags for backwards compatibility
+        if (nbt.contains("SourceLoc_x")) {
+            int srcX = nbt.getInt("SourceLoc_x");
+            int srcY = nbt.getInt("SourceLoc_y");
+            int srcZ = nbt.getInt("SourceLoc_z");
+            this.setOrigin(new org.bukkit.Location(level.getWorld(), srcX, srcY, srcZ));
+        }
+        // Paper end
     }
 
     public Level getLevel() {
@@ -291,35 +383,41 @@
         this.fallDamageMax = fallHurtMax;
     }
 
+    @Override
     public boolean displayFireAnimation() {
         return false;
     }
 
+    @Override
     public void fillCrashReportCategory(CrashReportCategory section) {
         super.fillCrashReportCategory(section);
-        section.setDetail("Immitating BlockState", this.blockState.toString());
+        section.setDetail("Immitating BlockState", (Object) this.blockState.toString());
     }
 
     public BlockState getBlockState() {
         return this.blockState;
     }
 
+    @Override
     public boolean onlyOpCanSetNbt() {
         return true;
     }
 
+    @Override
     public Packet<?> getAddEntityPacket() {
         return new ClientboundAddEntityPacket(this, Block.getId(this.getBlockState()));
     }
 
+    @Override
     public void recreateFromPacket(ClientboundAddEntityPacket packet) {
         super.recreateFromPacket(packet);
         this.blockState = Block.stateById(packet.getData());
         this.blocksBuilding = true;
-        double d = packet.getX();
-        double e = packet.getY();
-        double f = packet.getZ();
-        this.setPos(d, e + (double)((1.0F - this.getBbHeight()) / 2.0F), f);
+        double d0 = packet.getX();
+        double d1 = packet.getY();
+        double d2 = packet.getZ();
+
+        this.setPos(d0, d1 + (double) ((1.0F - this.getBbHeight()) / 2.0F), d2);
         this.setStartPos(this.blockPosition());
     }
 }
