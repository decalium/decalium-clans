--- a/net/minecraft/util/SortedArraySet.java
+++ b/net/minecraft/util/SortedArraySet.java
@@ -22,13 +22,48 @@
             this.contents = (T[])castRawArray(new Object[initialCapacity]);
         }
     }
+    // Paper start - optimise removeIf
+    @Override
+    public boolean removeIf(java.util.function.Predicate<? super T> filter) {
+        // prev. impl used an iterator, which could be n^2 and creates garbage
+        int i = 0, len = this.size;
+        T[] backingArray = this.contents;
+
+        for (;;) {
+            if (i >= len) {
+                return false;
+            }
+            if (!filter.test(backingArray[i])) {
+                ++i;
+                continue;
+            }
+            break;
+        }
+
+        // we only want to write back to backingArray if we really need to
+
+        int lastIndex = i; // this is where new elements are shifted to
+
+        for (; i < len; ++i) {
+            T curr = backingArray[i];
+            if (!filter.test(curr)) { // if test throws we're screwed
+                backingArray[lastIndex++] = curr;
+            }
+        }
+
+        // cleanup end
+        Arrays.fill(backingArray, lastIndex, len, null);
+        this.size = lastIndex;
+        return true;
+    }
+    // Paper end - optimise removeIf
 
     public static <T extends Comparable<T>> SortedArraySet<T> create() {
         return create(10);
     }
 
     public static <T extends Comparable<T>> SortedArraySet<T> create(int initialCapacity) {
-        return new SortedArraySet<>(initialCapacity, Comparator.naturalOrder());
+        return new SortedArraySet<>(initialCapacity, Comparator.<T>naturalOrder()); // Paper - decompile fix
     }
 
     public static <T> SortedArraySet<T> create(Comparator<T> comparator) {
@@ -51,6 +86,7 @@
         return -binarySearchResult - 1;
     }
 
+    @Override
     public boolean add(T object) {
         int i = this.findIndex(object);
         if (i >= 0) {
@@ -109,6 +145,7 @@
         }
     }
 
+    @Override
     public boolean remove(Object object) {
         int i = this.findIndex((T)object);
         if (i >= 0) {
@@ -133,23 +170,28 @@
         return this.getInternal(this.size - 1);
     }
 
+    @Override
     public boolean contains(Object object) {
         int i = this.findIndex((T)object);
         return i >= 0;
     }
 
+    @Override
     public Iterator<T> iterator() {
         return new SortedArraySet.ArrayIterator();
     }
 
+    @Override
     public int size() {
         return this.size;
     }
 
+    @Override
     public Object[] toArray() {
         return this.contents.clone();
     }
 
+    @Override
     public <U> U[] toArray(U[] objects) {
         if (objects.length < this.size) {
             return (U[])Arrays.copyOf(this.contents, this.size, objects.getClass());
@@ -163,11 +205,13 @@
         }
     }
 
+    @Override
     public void clear() {
         Arrays.fill(this.contents, 0, this.size, (Object)null);
         this.size = 0;
     }
 
+    @Override
     public boolean equals(Object object) {
         if (this == object) {
             return true;
@@ -187,10 +231,12 @@
         private int index;
         private int last = -1;
 
+        @Override
         public boolean hasNext() {
             return this.index < SortedArraySet.this.size;
         }
 
+        @Override
         public T next() {
             if (this.index >= SortedArraySet.this.size) {
                 throw new NoSuchElementException();
@@ -200,6 +246,7 @@
             }
         }
 
+        @Override
         public void remove() {
             if (this.last == -1) {
                 throw new IllegalStateException();
