--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -1,7 +1,10 @@
 package net.minecraft.server.level;
 
+import co.aikar.timings.Timing; // Paper
+import com.destroystokyo.paper.PaperWorldConfig; // Paper
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.ComparisonChain; // Paper
 import com.google.common.collect.Lists;
 import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
@@ -12,25 +15,34 @@
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
+import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import java.io.File;
 import java.io.IOException;
 import java.io.Writer;
 import java.util.BitSet;
+import java.util.HashMap; // Paper
+import java.util.Collection;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Map; // Paper
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.CancellationException;
+import java.util.UUID; // Paper
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
+import java.util.concurrent.CompletionStage;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BooleanSupplier;
+import java.util.function.Consumer;
 import java.util.function.IntFunction;
 import java.util.function.IntSupplier;
 import java.util.function.Supplier;
@@ -50,6 +62,8 @@
 import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
 import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
 import net.minecraft.network.protocol.game.DebugPackets;
+import net.minecraft.server.MCUtil;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.server.network.ServerPlayerConnection;
 import net.minecraft.util.CsvOutput;
@@ -65,6 +79,7 @@
 import net.minecraft.world.entity.boss.EnderDragonPart;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.GameRules;
+import net.minecraft.world.level.Level;
 import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.chunk.ChunkStatus;
@@ -75,17 +90,23 @@
 import net.minecraft.world.level.chunk.UpgradeData;
 import net.minecraft.world.level.chunk.storage.ChunkSerializer;
 import net.minecraft.world.level.chunk.storage.ChunkStorage;
+import net.minecraft.world.level.chunk.storage.RegionFile;
 import net.minecraft.world.level.entity.ChunkStatusUpdateListener;
 import net.minecraft.world.level.levelgen.structure.StructureStart;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import net.minecraft.world.phys.Vec3;
-import org.apache.commons.lang3.mutable.MutableBoolean;
+import net.minecraft.world.level.storage.PrimaryLevelData;
+import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet; // Paper
+import org.bukkit.craftbukkit.libs.org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+import org.bukkit.entity.Player; // CraftBukkit
+
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider {
+
     private static final byte CHUNK_TYPE_REPLACEABLE = -1;
     private static final byte CHUNK_TYPE_UNKNOWN = 0;
     private static final byte CHUNK_TYPE_FULL = 1;
@@ -94,88 +115,569 @@
     private static final int MIN_VIEW_DISTANCE = 3;
     public static final int MAX_VIEW_DISTANCE = 33;
     public static final int MAX_CHUNK_DISTANCE = 33 + ChunkStatus.maxDistance();
+    // Paper start - faster copying
+    public final Long2ObjectLinkedOpenHashMap<ChunkHolder> updatingChunkMap = new com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<>(); // Paper - faster copying
+    public final Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunkMap = new ProtectedVisibleChunksMap(); // Paper - faster copying
+
+    private class ProtectedVisibleChunksMap extends com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<ChunkHolder> {
+        @Override
+        public ChunkHolder put(long k, ChunkHolder playerChunk) {
+            throw new UnsupportedOperationException("Updating visible Chunks");
+        }
+
+        @Override
+        public ChunkHolder remove(long k) {
+            throw new UnsupportedOperationException("Removing visible Chunks");
+        }
+
+        @Override
+        public ChunkHolder get(long k) {
+            return ChunkMap.this.getVisibleChunkIfPresent(k);
+        }
+
+        public ChunkHolder safeGet(long k) {
+            return super.get(k);
+        }
+    }
+    // Paper end
+    public final com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<ChunkHolder> pendingVisibleChunks = new com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<ChunkHolder>(); // Paper - this is used if the visible chunks is updated while iterating only
+    public transient com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<ChunkHolder> visibleChunksClone; // Paper - used for async access of visible chunks, clone and cache only when needed
     public static final int FORCED_TICKET_LEVEL = 31;
-    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> updatingChunkMap = new Long2ObjectLinkedOpenHashMap<>();
-    private volatile Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunkMap = this.updatingChunkMap.clone();
-    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> pendingUnloads = new Long2ObjectLinkedOpenHashMap<>();
-    private final LongSet entitiesInLevel = new LongOpenHashSet();
-    final ServerLevel level;
+    // public final Long2ObjectLinkedOpenHashMap<ChunkHolder> updatingChunkMap = new Long2ObjectLinkedOpenHashMap(); // Paper - moved up
+    // public volatile Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunkMap; // Paper - moved up
+    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> pendingUnloads;
+    public final LongSet entitiesInLevel;
+    public final ServerLevel level;
     private final ThreadedLevelLightEngine lightEngine;
     private final BlockableEventLoop<Runnable> mainThreadExecutor;
-    private final ChunkGenerator generator;
-    private final Supplier<DimensionDataStorage> overworldDataStorage;
+    final java.util.concurrent.Executor mainInvokingExecutor; // Paper
+    public final ChunkGenerator generator;
+    public final Supplier<DimensionDataStorage> overworldDataStorage;
     private final PoiManager poiManager;
-    final LongSet toDrop = new LongOpenHashSet();
+    public final LongSet toDrop;
     private boolean modified;
     private final ChunkTaskPriorityQueueSorter queueSorter;
     private final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> worldgenMailbox;
-    private final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> mainThreadMailbox;
-    private final ChunkProgressListener progressListener;
+    public final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> mainThreadMailbox; // Paper - private -> public
+    // Paper start
+    final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> mailboxLight;
+    public void addLightTask(ChunkHolder playerchunk, Runnable run) {
+        this.mailboxLight.tell(ChunkTaskPriorityQueueSorter.message(playerchunk, run));
+    }
+    // Paper end
+    public final ChunkProgressListener progressListener;
     private final ChunkStatusUpdateListener chunkStatusListener;
-    private final ChunkMap.DistanceManager distanceManager;
-    private final AtomicInteger tickingGenerated = new AtomicInteger();
-    private final StructureManager structureManager;
+    public final ChunkMap.ChunkDistanceManager distanceManager;
+    private final AtomicInteger tickingGenerated;
+    public final StructureManager structureManager;
     private final String storageName;
-    private final PlayerMap playerMap = new PlayerMap();
-    private final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap = new Int2ObjectOpenHashMap<>();
-    private final Long2ByteMap chunkTypeCache = new Long2ByteOpenHashMap();
-    private final Queue<Runnable> unloadQueue = Queues.newConcurrentLinkedQueue();
+    private final PlayerMap playerMap;
+    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap;
+    private final Long2ByteMap chunkTypeCache;
+    private final Queue<Runnable> unloadQueue;
     int viewDistance;
+    public final com.destroystokyo.paper.util.PlayerMobDistanceMap playerMobDistanceMap; // Paper
+
+    // CraftBukkit start - recursion-safe executor for Chunk loadCallback() and unloadCallback()
+    public final CallbackExecutor callbackExecutor = new CallbackExecutor();
+    public static final class CallbackExecutor implements java.util.concurrent.Executor, Runnable {
+
+        // Paper start - replace impl with recursive safe multi entry queue
+        // it's possible to schedule multiple tasks currently, so it's vital we change this impl
+        // If we recurse into the executor again, we will append to another queue, ensuring task order consistency
+        private java.util.Queue<Runnable> queue = new java.util.ArrayDeque<>(); // Paper - remove final
+
+        @Override
+        public void execute(Runnable runnable) {
+            org.spigotmc.AsyncCatcher.catchOp("Callback Executor execute");
+            if (this.queue == null) {
+                this.queue = new java.util.ArrayDeque<>();
+            }
+            this.queue.add(runnable);
+        }
+
+        @Override
+        public void run() {
+            org.spigotmc.AsyncCatcher.catchOp("Callback Executor run");
+            if (this.queue == null) {
+                return;
+            }
+            java.util.Queue<Runnable> queue = this.queue;
+            this.queue = null;
+            // Paper end
+            Runnable task;
+            while ((task = queue.poll()) != null) { // Paper
+                task.run();
+            }
+        }
+    };
+    // CraftBukkit end
+
+    final CallbackExecutor chunkLoadConversionCallbackExecutor = new CallbackExecutor(); // Paper
+    // Paper start - distance maps
+    private final com.destroystokyo.paper.util.misc.PooledLinkedHashSets<ServerPlayer> pooledLinkedPlayerHashSets = new com.destroystokyo.paper.util.misc.PooledLinkedHashSets<>();
+    // Paper start - no-tick view distance
+    int noTickViewDistance;
+    public final int getRawNoTickViewDistance() {
+        return this.noTickViewDistance;
+    }
+    public final int getEffectiveNoTickViewDistance() {
+        return this.noTickViewDistance == -1 ? this.getEffectiveViewDistance() : this.noTickViewDistance;
+    }
+    public final int getLoadViewDistance() {
+        return Math.max(this.getEffectiveViewDistance(), this.getEffectiveNoTickViewDistance());
+    }
+
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerViewDistanceBroadcastMap;
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerViewDistanceTickMap;
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerViewDistanceNoTickMap;
+    // Paper end - no-tick view distance
+    // Paper start - use distance map to optimise tracker
+    public static boolean isLegacyTrackingEntity(Entity entity) {
+        return entity.isLegacyTrackingEntity;
+    }
 
+    // inlined EnumMap, TrackingRange.TrackingRangeType
+    static final org.spigotmc.TrackingRange.TrackingRangeType[] TRACKING_RANGE_TYPES = org.spigotmc.TrackingRange.TrackingRangeType.values();
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap[] playerEntityTrackerTrackMaps;
+    final int[] entityTrackerTrackRanges;
+
+    private int convertSpigotRangeToVanilla(final int vanilla) {
+        return MinecraftServer.getServer().getScaledTrackingDistance(vanilla);
+    }
+    // Paper end - use distance map to optimise tracker
+    // Paper start - optimise PlayerChunkMap#isOutsideRange
+    // A note about the naming used here:
+    // Previously, mojang used a "spawn range" of 8 for controlling both ticking and
+    // mob spawn range. However, spigot makes the spawn range configurable by
+    // checking if the chunk is in the tick range (8) and the spawn range
+    // obviously this means a spawn range > 8 cannot be implemented
+
+    // these maps are named after spigot's uses
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobSpawnMap; // this map is absent from updateMaps since it's controlled at the start of the chunkproviderserver tick
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerChunkTickRangeMap;
+    // Paper end - optimise PlayerChunkMap#isOutsideRange
+
+    void addPlayerToDistanceMaps(ServerPlayer player) {
+        int chunkX = MCUtil.getChunkCoordinate(player.getX());
+        int chunkZ = MCUtil.getChunkCoordinate(player.getZ());
+        // Note: players need to be explicitly added to distance maps before they can be updated
+        // Paper start - use distance map to optimise entity tracker
+        for (int i = 0, len = TRACKING_RANGE_TYPES.length; i < len; ++i) {
+            com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
+            int trackRange = this.entityTrackerTrackRanges[i];
+
+            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, this.getEffectiveViewDistance()));
+        }
+        // Paper end - use distance map to optimise entity tracker
+        // Paper start - optimise PlayerChunkMap#isOutsideRange
+        this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, DistanceManager.MOB_SPAWN_RANGE);
+        // Paper end - optimise PlayerChunkMap#isOutsideRange
+        // Paper start - optimise PlayerChunkMap#isOutsideRange
+        this.playerChunkTickRangeMap.add(player, chunkX, chunkZ, DistanceManager.MOB_SPAWN_RANGE);
+        // Paper end - optimise PlayerChunkMap#isOutsideRange
+        // Paper start - no-tick view distance
+        int effectiveTickViewDistance = this.getEffectiveViewDistance();
+        int effectiveNoTickViewDistance = Math.max(this.getEffectiveNoTickViewDistance(), effectiveTickViewDistance);
+
+        if (!this.skipPlayer(player)) {
+            this.playerViewDistanceTickMap.add(player, chunkX, chunkZ, effectiveTickViewDistance);
+            this.playerViewDistanceNoTickMap.add(player, chunkX, chunkZ, effectiveNoTickViewDistance + 2); // clients need chunk 1 neighbour, and we need another 1 for sending those extra neighbours (as we require neighbours to send)
+        }
+
+        player.needsChunkCenterUpdate = true;
+        this.playerViewDistanceBroadcastMap.add(player, chunkX, chunkZ, effectiveNoTickViewDistance + 1); // clients need an extra neighbour to render the full view distance configured
+        player.needsChunkCenterUpdate = false;
+        // Paper end - no-tick view distance
+    }
+
+    void removePlayerFromDistanceMaps(ServerPlayer player) {
+        // Paper start - use distance map to optimise tracker
+        for (int i = 0, len = TRACKING_RANGE_TYPES.length; i < len; ++i) {
+            this.playerEntityTrackerTrackMaps[i].remove(player);
+        }
+        // Paper end - use distance map to optimise tracker
+        // Paper start - optimise PlayerChunkMap#isOutsideRange
+        this.playerMobSpawnMap.remove(player);
+        this.playerChunkTickRangeMap.remove(player);
+        // Paper end - optimise PlayerChunkMap#isOutsideRange
+        // Paper start - no-tick view distance
+        this.playerViewDistanceBroadcastMap.remove(player);
+        this.playerViewDistanceTickMap.remove(player);
+        this.playerViewDistanceNoTickMap.remove(player);
+        // Paper end - no-tick view distance
+    }
+
+    void updateMaps(ServerPlayer player) {
+        int chunkX = MCUtil.getChunkCoordinate(player.getX());
+        int chunkZ = MCUtil.getChunkCoordinate(player.getZ());
+        // Note: players need to be explicitly added to distance maps before they can be updated
+        // Paper start - use distance map to optimise entity tracker
+        for (int i = 0, len = TRACKING_RANGE_TYPES.length; i < len; ++i) {
+            com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
+            int trackRange = this.entityTrackerTrackRanges[i];
+
+            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, this.getEffectiveViewDistance()));
+        }
+        // Paper end - use distance map to optimise entity tracker
+        // Paper start - optimise PlayerChunkMap#isOutsideRange
+        this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, DistanceManager.MOB_SPAWN_RANGE);
+        // Paper end - optimise PlayerChunkMap#isOutsideRange
+        // Paper start - no-tick view distance
+        int effectiveTickViewDistance = this.getEffectiveViewDistance();
+        int effectiveNoTickViewDistance = Math.max(this.getEffectiveNoTickViewDistance(), effectiveTickViewDistance);
+
+        if (!this.skipPlayer(player)) {
+            this.playerViewDistanceTickMap.update(player, chunkX, chunkZ, effectiveTickViewDistance);
+            this.playerViewDistanceNoTickMap.update(player, chunkX, chunkZ, effectiveNoTickViewDistance + 2); // clients need chunk 1 neighbour, and we need another 1 for sending those extra neighbours (as we require neighbours to send)
+        }
+
+        player.needsChunkCenterUpdate = true;
+        this.playerViewDistanceBroadcastMap.update(player, chunkX, chunkZ, effectiveNoTickViewDistance + 1); // clients need an extra neighbour to render the full view distance configured
+        player.needsChunkCenterUpdate = false;
+        // Paper end - no-tick view distance
+    }
+    // Paper end
+
+    private final java.util.concurrent.ExecutorService lightThread; // Paper
     public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureManager structureManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int viewDistance, boolean dsync) {
         super(new File(session.getDimensionPath(world.dimension()), "region"), dataFixer, dsync);
+        //this.visibleChunks = this.updatingChunks.clone(); // Paper - no more cloning
+        this.pendingUnloads = new Long2ObjectLinkedOpenHashMap();
+        this.entitiesInLevel = new LongOpenHashSet();
+        this.toDrop = new LongOpenHashSet();
+        this.tickingGenerated = new AtomicInteger();
+        this.playerMap = new PlayerMap();
+        this.entityMap = new Int2ObjectOpenHashMap();
+        this.chunkTypeCache = new Long2ByteOpenHashMap();
+        this.unloadQueue = new com.destroystokyo.paper.utils.CachedSizeConcurrentLinkedQueue<>(); // Paper - need constant-time size()
         this.structureManager = structureManager;
         File file = session.getDimensionPath(world.dimension());
+
         this.storageName = file.getName();
         this.level = world;
         this.generator = chunkGenerator;
         this.mainThreadExecutor = mainThreadExecutor;
-        ProcessorMailbox<Runnable> processorMailbox = ProcessorMailbox.create(executor, "worldgen");
-        ProcessorHandle<Runnable> processorHandle = ProcessorHandle.of("main", mainThreadExecutor::tell);
+        // Paper start
+        this.mainInvokingExecutor = (run) -> {
+            if (MCUtil.isMainThread()) {
+                run.run();
+            } else {
+                mainThreadExecutor.execute(run);
+            }
+        };
+        // Paper end
+        ProcessorMailbox<Runnable> threadedmailbox = ProcessorMailbox.create(executor, "worldgen");
+
+        Objects.requireNonNull(mainThreadExecutor);
+        ProcessorHandle<Runnable> mailbox = ProcessorHandle.of("main", mainThreadExecutor::tell);
+
         this.progressListener = worldGenerationProgressListener;
         this.chunkStatusListener = chunkStatusChangeListener;
-        ProcessorMailbox<Runnable> processorMailbox2 = ProcessorMailbox.create(executor, "light");
-        this.queueSorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(processorMailbox, processorHandle, processorMailbox2), executor, Integer.MAX_VALUE);
-        this.worldgenMailbox = this.queueSorter.getProcessor(processorMailbox, false);
-        this.mainThreadMailbox = this.queueSorter.getProcessor(processorHandle, false);
-        this.lightEngine = new ThreadedLevelLightEngine(chunkProvider, this, this.level.dimensionType().hasSkyLight(), processorMailbox2, this.queueSorter.getProcessor(processorMailbox2, false));
-        this.distanceManager = new ChunkMap.DistanceManager(executor, mainThreadExecutor);
+        // Paper start - use light thread
+        ProcessorMailbox<Runnable> lightthreaded; ProcessorMailbox<Runnable> threadedmailbox1 = lightthreaded = ProcessorMailbox.create(lightThread = java.util.concurrent.Executors.newSingleThreadExecutor(r -> {
+            Thread thread = new Thread(r);
+            thread.setName(((PrimaryLevelData)level.getLevelData()).getLevelName() + " - Light");
+            thread.setDaemon(true);
+            thread.setPriority(Thread.NORM_PRIORITY+1);
+            return thread;
+        }), "light");
+        // Paper end
+
+        this.queueSorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(threadedmailbox, mailbox, threadedmailbox1), executor, Integer.MAX_VALUE);
+        this.worldgenMailbox = this.queueSorter.getProcessor(threadedmailbox, false);
+        this.mainThreadMailbox = this.queueSorter.getProcessor(mailbox, false);
+        this.mailboxLight = this.queueSorter.getProcessor(lightthreaded, false);// Paper
+        this.lightEngine = new ThreadedLevelLightEngine(chunkProvider, this, this.level.dimensionType().hasSkyLight(), threadedmailbox1, this.queueSorter.getProcessor(threadedmailbox1, false));
+        this.distanceManager = new ChunkMap.ChunkDistanceManager(executor, mainThreadExecutor); this.distanceManager.chunkMap = this; // Paper
         this.overworldDataStorage = persistentStateManagerFactory;
         this.poiManager = new PoiManager(new File(file, "poi"), dataFixer, dsync, world);
         this.setViewDistance(viewDistance);
+        this.playerMobDistanceMap = this.level.paperConfig.perPlayerMobSpawns ? new com.destroystokyo.paper.util.PlayerMobDistanceMap() : null; // Paper
+        // Paper start - use distance map to optimise entity tracker
+        this.playerEntityTrackerTrackMaps = new com.destroystokyo.paper.util.misc.PlayerAreaMap[TRACKING_RANGE_TYPES.length];
+        this.entityTrackerTrackRanges = new int[TRACKING_RANGE_TYPES.length];
+
+        org.spigotmc.SpigotWorldConfig spigotWorldConfig = this.level.spigotConfig;
+
+        for (int ordinal = 0, len = TRACKING_RANGE_TYPES.length; ordinal < len; ++ordinal) {
+            org.spigotmc.TrackingRange.TrackingRangeType trackingRangeType = TRACKING_RANGE_TYPES[ordinal];
+            int configuredSpigotValue;
+            switch (trackingRangeType) {
+                case PLAYER:
+                    configuredSpigotValue = spigotWorldConfig.playerTrackingRange;
+                    break;
+                case ANIMAL:
+                    configuredSpigotValue = spigotWorldConfig.animalTrackingRange;
+                    break;
+                case MONSTER:
+                    configuredSpigotValue = spigotWorldConfig.monsterTrackingRange;
+                    break;
+                case MISC:
+                    configuredSpigotValue = spigotWorldConfig.miscTrackingRange;
+                    break;
+                case OTHER:
+                    configuredSpigotValue = spigotWorldConfig.otherTrackingRange;
+                    break;
+                case ENDERDRAGON:
+                    configuredSpigotValue = EntityType.ENDER_DRAGON.clientTrackingRange() * 16;
+                    break;
+                default:
+                    throw new IllegalStateException("Missing case for enum " + trackingRangeType);
+            }
+            configuredSpigotValue = convertSpigotRangeToVanilla(configuredSpigotValue);
+
+            int trackRange = (configuredSpigotValue >>> 4) + ((configuredSpigotValue & 15) != 0 ? 1 : 0);
+            this.entityTrackerTrackRanges[ordinal] = trackRange;
+
+            this.playerEntityTrackerTrackMaps[ordinal] = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets);
+        }
+        // Paper end - use distance map to optimise entity tracker
+        // Paper start - optimise PlayerChunkMap#isOutsideRange
+        this.playerChunkTickRangeMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                ChunkHolder playerChunk = ChunkMap.this.getUpdatingChunkIfPresent(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                if (playerChunk != null) {
+                    playerChunk.playersInChunkTickRange = newState;
+                }
+            },
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                ChunkHolder playerChunk = ChunkMap.this.getUpdatingChunkIfPresent(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                if (playerChunk != null) {
+                    playerChunk.playersInChunkTickRange = newState;
+                }
+            });
+        this.playerMobSpawnMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                ChunkHolder playerChunk = ChunkMap.this.getUpdatingChunkIfPresent(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                if (playerChunk != null) {
+                    playerChunk.playersInMobSpawnRange = newState;
+                }
+            },
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                ChunkHolder playerChunk = ChunkMap.this.getUpdatingChunkIfPresent(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                if (playerChunk != null) {
+                    playerChunk.playersInMobSpawnRange = newState;
+                }
+            });
+        // Paper end - optimise PlayerChunkMap#isOutsideRange
+        // Paper start - no-tick view distance
+        this.setNoTickViewDistance(this.level.paperConfig.noTickViewDistance);
+        this.playerViewDistanceTickMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                checkHighPriorityChunks(player);
+                if (newState.size() != 1) {
+                    return;
+                }
+                LevelChunk chunk = ChunkMap.this.level.getChunkSource().getChunkAtIfLoadedMainThreadNoCache(rangeX, rangeZ);
+                if (chunk == null || !chunk.areNeighboursLoaded(2)) {
+                    return;
+                }
+
+                ChunkPos chunkPos = new ChunkPos(rangeX, rangeZ);
+                ChunkMap.this.level.getChunkSource().addTicketAtLevel(TicketType.PLAYER, chunkPos, 31, chunkPos); // entity ticking level, TODO check on update
+            },
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                if (newState != null) {
+                    return;
+                }
+                ChunkPos chunkPos = new ChunkPos(rangeX, rangeZ);
+                ChunkMap.this.level.getChunkSource().removeTicketAtLevel(TicketType.PLAYER, chunkPos, 31, chunkPos); // entity ticking level, TODO check on update
+                // Paper start
+                ChunkMap.this.level.getChunkSource().clearPriorityTickets(chunkPos);
+            },
+            (player, prevPos, newPos) -> {
+            player.lastHighPriorityChecked = -1; // reset and recheck
+            checkHighPriorityChunks(player);
+        });
+        // Paper end
+        this.playerViewDistanceNoTickMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets);
+        this.playerViewDistanceBroadcastMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                if (player.needsChunkCenterUpdate) {
+                    player.needsChunkCenterUpdate = false;
+                    player.connection.send(new ClientboundSetChunkCacheCenterPacket(currPosX, currPosZ));
+                }
+                ChunkMap.this.updateChunkTracking(player, new ChunkPos(rangeX, rangeZ), new Packet[2], false, true); // unloaded, loaded
+            },
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                ChunkMap.this.updateChunkTracking(player, new ChunkPos(rangeX, rangeZ), null, true, false); // unloaded, loaded
+            });
+        // Paper end - no-tick view distance
+    }
+
+    // Paper start - Chunk Prioritization
+    public void queueHolderUpdate(ChunkHolder playerchunk) {
+        Runnable runnable = () -> {
+            if (isUnloading(playerchunk)) {
+                return; // unloaded
+            }
+            distanceManager.pendingChunkUpdates.add(playerchunk);
+            if (!distanceManager.pollingPendingChunkUpdates) {
+                level.getChunkSource().runDistanceManagerUpdates();
+            }
+        };
+        if (MCUtil.isMainThread()) {
+            // We can't use executor here because it will not execute tasks if its currently in the middle of executing tasks...
+            runnable.run();
+        } else {
+            mainThreadExecutor.execute(runnable);
+        }
+    }
+
+    private boolean isUnloading(ChunkHolder playerchunk) {
+        return playerchunk == null || toDrop.contains(playerchunk.pos.toLong());
+    }
+
+    private void updateChunkPriorityMap(it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap map, long chunk, int level) {
+        int prev = map.getOrDefault(chunk, -1);
+        if (level > prev) {
+            map.put(chunk, level);
+        }
+    }
+
+    public void checkHighPriorityChunks(ServerPlayer player) {
+        int currentTick = MinecraftServer.currentTick;
+        if (currentTick - player.lastHighPriorityChecked < 20 || !player.isRealPlayer) { // weed out fake players
+            return;
+        }
+        player.lastHighPriorityChecked = currentTick;
+        it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap priorities = new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap();
+
+        int viewDistance = getEffectiveNoTickViewDistance();
+        net.minecraft.core.BlockPos.MutableBlockPos pos = new net.minecraft.core.BlockPos.MutableBlockPos();
+
+        // Prioritize circular near
+        double playerChunkX = Mth.floor(player.getX()) >> 4;
+        double playerChunkZ = Mth.floor(player.getZ()) >> 4;
+        pos.set(player.getX(), 0, player.getZ());
+        double twoThirdModifier = 2D / 3D;
+        MCUtil.getSpiralOutChunks(pos, Math.min(6, viewDistance)).forEach(coord -> {
+            if (shouldSkipPrioritization(coord)) return;
+
+            double dist = MCUtil.distance(playerChunkX, 0, playerChunkZ, coord.x, 0, coord.z);
+            // Prioritize immediate
+            if (dist <= 4) {
+                updateChunkPriorityMap(priorities, coord.toLong(), (int) (27 - dist));
+                return;
+            }
+
+            // Prioritize nearby chunks
+            updateChunkPriorityMap(priorities, coord.toLong(), (int) (20 - dist * twoThirdModifier));
+        });
+
+        // Prioritize Frustum near 3
+        ChunkPos front3 = player.getChunkInFront(3);
+        pos.set(front3.x << 4, 0, front3.z << 4);
+        MCUtil.getSpiralOutChunks(pos, Math.min(5, viewDistance)).forEach(coord -> {
+            if (shouldSkipPrioritization(coord)) return;
+
+            double dist = MCUtil.distance(playerChunkX, 0, playerChunkZ, coord.x, 0, coord.z);
+            updateChunkPriorityMap(priorities, coord.toLong(), (int) (25 - dist * twoThirdModifier));
+        });
+
+        // Prioritize Frustum near 5
+        if (viewDistance > 4) {
+            ChunkPos front5 = player.getChunkInFront(5);
+            pos.set(front5.x << 4, 0, front5.z << 4);
+            MCUtil.getSpiralOutChunks(pos, 4).forEach(coord -> {
+                if (shouldSkipPrioritization(coord)) return;
+
+                double dist = MCUtil.distance(playerChunkX, 0, playerChunkZ, coord.x, 0, coord.z);
+                updateChunkPriorityMap(priorities, coord.toLong(), (int) (25 - dist * twoThirdModifier));
+            });
+        }
+
+        // Prioritize Frustum far 7
+        if (viewDistance > 6) {
+            ChunkPos front7 = player.getChunkInFront(7);
+            pos.set(front7.x << 4, 0, front7.z << 4);
+            MCUtil.getSpiralOutChunks(pos, 3).forEach(coord -> {
+                if (shouldSkipPrioritization(coord)) {
+                    return;
+                }
+                double dist = MCUtil.distance(playerChunkX, 0, playerChunkZ, coord.x, 0, coord.z);
+                updateChunkPriorityMap(priorities, coord.toLong(), (int) (25 - dist * twoThirdModifier));
+            });
+        }
+
+        if (priorities.isEmpty()) return;
+        distanceManager.delayDistanceManagerTick = true;
+        priorities.long2IntEntrySet().fastForEach(entry -> distanceManager.markHighPriority(new ChunkPos(entry.getLongKey()), entry.getIntValue()));
+        distanceManager.delayDistanceManagerTick = false;
+        level.getChunkSource().runDistanceManagerUpdates();
+
+    }
+
+    private boolean shouldSkipPrioritization(ChunkPos coord) {
+        if (playerViewDistanceNoTickMap.getObjectsInRange(coord.toLong()) == null) return true;
+        ChunkHolder chunk = getUpdatingChunkIfPresent(coord.toLong());
+        return chunk != null && (chunk.isFullChunkReady());
+    }
+    // Paper end
+
+    // Paper start
+    public void updatePlayerMobTypeMap(Entity entity) {
+        if (!this.level.paperConfig.perPlayerMobSpawns) {
+            return;
+        }
+        int chunkX = (int)Math.floor(entity.getX()) >> 4;
+        int chunkZ = (int)Math.floor(entity.getZ()) >> 4;
+        int index = entity.getType().getCategory().ordinal();
+
+        for (ServerPlayer player : this.playerMobDistanceMap.getPlayersInRange(chunkX, chunkZ)) {
+            ++player.mobCounts[index];
+        }
     }
 
+    public int getMobCountNear(ServerPlayer entityPlayer, net.minecraft.world.entity.MobCategory mobCategory) {
+        return entityPlayer.mobCounts[mobCategory.ordinal()];
+    }
+    // Paper end
+
     private static double euclideanDistanceSquared(ChunkPos pos, Entity entity) {
-        double d = (double)SectionPos.sectionToBlockCoord(pos.x, 8);
-        double e = (double)SectionPos.sectionToBlockCoord(pos.z, 8);
-        double f = d - entity.getX();
-        double g = e - entity.getZ();
-        return f * f + g * g;
+        double d0 = (double) SectionPos.sectionToBlockCoord(pos.x, 8);
+        double d1 = (double) SectionPos.sectionToBlockCoord(pos.z, 8);
+        double d2 = d0 - entity.getX();
+        double d3 = d1 - entity.getZ();
+
+        return d2 * d2 + d3 * d3;
     }
 
     private static int checkerboardDistance(ChunkPos pos, ServerPlayer player, boolean useWatchedPosition) {
         int i;
         int j;
+
         if (useWatchedPosition) {
-            SectionPos sectionPos = player.getLastSectionPos();
-            i = sectionPos.x();
-            j = sectionPos.z();
+            SectionPos sectionposition = player.getLastSectionPos();
+
+            i = sectionposition.x();
+            j = sectionposition.z();
         } else {
             i = SectionPos.blockToSectionCoord(player.getBlockX());
             j = SectionPos.blockToSectionCoord(player.getBlockZ());
         }
 
-        return checkerboardDistance(pos, i, j);
+        return ChunkMap.checkerboardDistance(pos, i, j);
     }
 
     private static int checkerboardDistance(ChunkPos chunkPos, Entity entity) {
-        return checkerboardDistance(chunkPos, SectionPos.blockToSectionCoord(entity.getBlockX()), SectionPos.blockToSectionCoord(entity.getBlockZ()));
+        return ChunkMap.checkerboardDistance(chunkPos, SectionPos.blockToSectionCoord(entity.getBlockX()), SectionPos.blockToSectionCoord(entity.getBlockZ()));
     }
 
     private static int checkerboardDistance(ChunkPos pos, int x, int z) {
-        int i = pos.x - x;
-        int j = pos.z - z;
-        return Math.max(Math.abs(i), Math.abs(j));
+        int k = pos.x - x;
+        int l = pos.z - z;
+
+        return Math.max(Math.abs(k), Math.abs(l));
     }
 
     protected ThreadedLevelLightEngine getLightEngine() {
@@ -183,87 +685,159 @@
     }
 
     @Nullable
-    protected ChunkHolder getUpdatingChunkIfPresent(long pos) {
-        return this.updatingChunkMap.get(pos);
+    public ChunkHolder getUpdatingChunkIfPresent(long pos) {
+        return (ChunkHolder) this.updatingChunkMap.get(pos);
     }
 
+    // Paper start - remove cloning of visible chunks unless accessed as a collection async
+    private static final boolean DEBUG_ASYNC_VISIBLE_CHUNKS = Boolean.getBoolean("paper.debug-async-visible-chunks");
+    private boolean isIterating = false;
+    private boolean hasPendingVisibleUpdate = false;
+    public void forEachVisibleChunk(java.util.function.Consumer<ChunkHolder> consumer) {
+        org.spigotmc.AsyncCatcher.catchOp("forEachVisibleChunk");
+        boolean prev = isIterating;
+        isIterating = true;
+        try {
+            for (ChunkHolder value : this.visibleChunkMap.values()) {
+                consumer.accept(value);
+            }
+        } finally {
+            this.isIterating = prev;
+            if (!this.isIterating && this.hasPendingVisibleUpdate) {
+                ((ProtectedVisibleChunksMap)this.visibleChunkMap).copyFrom(this.pendingVisibleChunks);
+                this.pendingVisibleChunks.clear();
+                this.hasPendingVisibleUpdate = false;
+            }
+        }
+    }
+    public Long2ObjectLinkedOpenHashMap<ChunkHolder> getVisibleChunks() {
+        if (Thread.currentThread() == this.level.thread) {
+            return this.visibleChunkMap;
+        } else {
+            synchronized (this.visibleChunkMap) {
+                if (DEBUG_ASYNC_VISIBLE_CHUNKS) new Throwable("Async getVisibleChunks").printStackTrace();
+                if (this.visibleChunksClone == null) {
+                    this.visibleChunksClone = this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.clone() : ((ProtectedVisibleChunksMap)this.visibleChunkMap).clone();
+                }
+                return this.visibleChunksClone;
+            }
+        }
+    }
+    // Paper end
+
     @Nullable
-    protected ChunkHolder getVisibleChunkIfPresent(long pos) {
-        return this.visibleChunkMap.get(pos);
+    public ChunkHolder getVisibleChunkIfPresent(long pos) {
+        // Paper start - mt safe get
+        if (Thread.currentThread() != this.level.thread) {
+            synchronized (this.visibleChunkMap) {
+                return (ChunkHolder) (this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.get(pos) : ((ProtectedVisibleChunksMap)this.visibleChunkMap).safeGet(pos));
+            }
+        }
+        return (ChunkHolder) (this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.get(pos) : ((ProtectedVisibleChunksMap)this.visibleChunkMap).safeGet(pos));
+        // Paper end
     }
 
     protected IntSupplier getChunkQueueLevel(long pos) {
         return () -> {
-            ChunkHolder chunkHolder = this.getVisibleChunkIfPresent(pos);
-            return chunkHolder == null ? ChunkTaskPriorityQueue.PRIORITY_LEVEL_COUNT - 1 : Math.min(chunkHolder.getQueueLevel(), ChunkTaskPriorityQueue.PRIORITY_LEVEL_COUNT - 1);
+            ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos);
+
+            return playerchunk == null ? ChunkTaskPriorityQueue.PRIORITY_LEVEL_COUNT - 1 : Math.min(playerchunk.getQueueLevel(), ChunkTaskPriorityQueue.PRIORITY_LEVEL_COUNT - 1);
         };
     }
 
     public String getChunkDebugData(ChunkPos chunkPos) {
-        ChunkHolder chunkHolder = this.getVisibleChunkIfPresent(chunkPos.toLong());
-        if (chunkHolder == null) {
+        ChunkHolder playerchunk = this.getVisibleChunkIfPresent(chunkPos.toLong());
+
+        if (playerchunk == null) {
             return "null";
         } else {
-            String string = chunkHolder.getTicketLevel() + "\n";
-            ChunkStatus chunkStatus = chunkHolder.getLastAvailableStatus();
-            ChunkAccess chunkAccess = chunkHolder.getLastAvailable();
-            if (chunkStatus != null) {
-                string = string + "St: \u00a7" + chunkStatus.getIndex() + chunkStatus + "\u00a7r\n";
+            String s = playerchunk.getTicketLevel() + "\n";
+            ChunkStatus chunkstatus = playerchunk.getLastAvailableStatus();
+            ChunkAccess ichunkaccess = playerchunk.getLastAvailable();
+
+            if (chunkstatus != null) {
+                s = s + "St: \u00a7" + chunkstatus.getIndex() + chunkstatus + "\u00a7r\n";
             }
 
-            if (chunkAccess != null) {
-                string = string + "Ch: \u00a7" + chunkAccess.getStatus().getIndex() + chunkAccess.getStatus() + "\u00a7r\n";
+            if (ichunkaccess != null) {
+                s = s + "Ch: \u00a7" + ichunkaccess.getStatus().getIndex() + ichunkaccess.getStatus() + "\u00a7r\n";
             }
 
-            ChunkHolder.FullChunkStatus fullChunkStatus = chunkHolder.getFullStatus();
-            string = string + "\u00a7" + fullChunkStatus.ordinal() + fullChunkStatus;
-            return string + "\u00a7r";
+            ChunkHolder.FullChunkStatus playerchunk_state = playerchunk.getFullStatus();
+
+            s = s + "\u00a7" + playerchunk_state.ordinal() + playerchunk_state;
+            return s + "\u00a7r";
         }
     }
 
+    // Paper start
+    public final int getEffectiveViewDistance() {
+        // TODO this needs to be checked on update
+        // Mojang currently sets it to +1 of the configured view distance. So subtract one to get the one we really want.
+        return this.viewDistance - 1;
+    }
+    // Paper end
+
     private CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> getChunkRangeFuture(ChunkPos centerChunk, int margin, IntFunction<ChunkStatus> distanceToStatus) {
         List<CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> list = Lists.newArrayList();
-        int i = centerChunk.x;
-        int j = centerChunk.z;
+        int j = centerChunk.x;
+        int k = centerChunk.z;
+        ChunkHolder requestingNeighbor = getUpdatingChunkIfPresent(centerChunk.toLong()); // Paper
 
-        for(int k = -margin; k <= margin; ++k) {
-            for(int l = -margin; l <= margin; ++l) {
-                int m = Math.max(Math.abs(l), Math.abs(k));
-                final ChunkPos chunkPos = new ChunkPos(i + l, j + k);
-                long n = chunkPos.toLong();
-                ChunkHolder chunkHolder = this.getUpdatingChunkIfPresent(n);
-                if (chunkHolder == null) {
+        for (int l = -margin; l <= margin; ++l) {
+            for (int i1 = -margin; i1 <= margin; ++i1) {
+                int j1 = Math.max(Math.abs(i1), Math.abs(l));
+                final ChunkPos chunkcoordintpair1 = new ChunkPos(j + i1, k + l);
+                long k1 = chunkcoordintpair1.toLong();
+                ChunkHolder playerchunk = this.getUpdatingChunkIfPresent(k1);
+
+                if (playerchunk == null) {
                     return CompletableFuture.completedFuture(Either.right(new ChunkHolder.ChunkLoadingFailure() {
                         public String toString() {
-                            return "Unloaded " + chunkPos;
+                            return "Unloaded " + chunkcoordintpair1;
                         }
                     }));
                 }
 
-                ChunkStatus chunkStatus = distanceToStatus.apply(m);
-                CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completableFuture = chunkHolder.getOrScheduleFuture(chunkStatus, this);
-                list.add(completableFuture);
+                ChunkStatus chunkstatus = (ChunkStatus) distanceToStatus.apply(j1);
+                CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = playerchunk.getOrScheduleFuture(chunkstatus, this);
+                // Paper start
+                if (requestingNeighbor != null && requestingNeighbor != playerchunk && !completablefuture.isDone()) {
+                    requestingNeighbor.onNeighborRequest(playerchunk, chunkstatus);
+                    completablefuture.thenAccept(either -> {
+                        requestingNeighbor.onNeighborDone(playerchunk, chunkstatus, either.left().orElse(null));
+                    });
+                }
+                // Paper end
+
+                list.add(completablefuture);
             }
         }
 
-        CompletableFuture<List<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> completableFuture2 = Util.sequence(list);
-        return completableFuture2.thenApply((listx) -> {
+        CompletableFuture<List<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> completablefuture1 = Util.sequence((List) list);
+
+        return completablefuture1.thenApply((list1) -> {
             List<ChunkAccess> list2 = Lists.newArrayList();
-            int l = 0;
+            // CraftBukkit start - decompile error
+            int cnt = 0;
 
-            for(final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either : listx) {
+            for (Iterator iterator = list1.iterator(); iterator.hasNext(); ++cnt) {
+                final int l1 = cnt;
+                // CraftBukkit end
+                final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = (Either) iterator.next();
                 Optional<ChunkAccess> optional = either.left();
+
                 if (!optional.isPresent()) {
-                    final int m = l;
                     return Either.right(new ChunkHolder.ChunkLoadingFailure() {
                         public String toString() {
-                            return "Unloaded " + new ChunkPos(i + m % (margin * 2 + 1), j + m / (margin * 2 + 1)) + " " + either.right().get();
+                            ChunkPos chunkcoordintpair2 = new ChunkPos(j + l1 % (margin * 2 + 1), k + l1 / (margin * 2 + 1));
+
+                            return "Unloaded " + chunkcoordintpair2 + " " + either.right().get();
                         }
                     });
                 }
 
-                list2.add(optional.get());
-                ++l;
+                list2.add((ChunkAccess) optional.get());
             }
 
             return Either.left(list2);
@@ -275,30 +849,31 @@
             return ChunkStatus.FULL;
         }).thenApplyAsync((either) -> {
             return either.mapLeft((list) -> {
-                return (LevelChunk)list.get(list.size() / 2);
+                return (LevelChunk) list.get(list.size() / 2);
             });
-        }, this.mainThreadExecutor);
+        }, this.mainInvokingExecutor); // Paper
     }
 
     @Nullable
-    ChunkHolder updateChunkScheduling(long pos, int level, @Nullable ChunkHolder holder, int i) {
-        if (i > MAX_CHUNK_DISTANCE && level > MAX_CHUNK_DISTANCE) {
+    ChunkHolder updateChunkScheduling(long pos, int level, @Nullable ChunkHolder holder, int k) {
+        if (k > ChunkMap.MAX_CHUNK_DISTANCE && level > ChunkMap.MAX_CHUNK_DISTANCE) {
             return holder;
         } else {
             if (holder != null) {
                 holder.setTicketLevel(level);
+                holder.updateRanges(); // Paper - optimise isOutsideOfRange
             }
 
             if (holder != null) {
-                if (level > MAX_CHUNK_DISTANCE) {
+                if (level > ChunkMap.MAX_CHUNK_DISTANCE) {
                     this.toDrop.add(pos);
                 } else {
                     this.toDrop.remove(pos);
                 }
             }
 
-            if (level <= MAX_CHUNK_DISTANCE && holder == null) {
-                holder = this.pendingUnloads.remove(pos);
+            if (level <= ChunkMap.MAX_CHUNK_DISTANCE && holder == null) {
+                holder = (ChunkHolder) this.pendingUnloads.remove(pos);
                 if (holder != null) {
                     holder.setTicketLevel(level);
                 } else {
@@ -313,9 +888,12 @@
         }
     }
 
+    @Override
     public void close() throws IOException {
         try {
+            this.lightThread.shutdown(); // Paper
             this.queueSorter.close();
+            this.level.asyncChunkTaskManager.close(true); // Paper - Required since we're closing regionfiles in the next line
             this.poiManager.close();
         } finally {
             super.close();
@@ -323,38 +901,104 @@
 
     }
 
+    // Paper start - incremental autosave
+    final ObjectRBTreeSet<ChunkHolder> autoSaveQueue = new ObjectRBTreeSet<>((playerchunk1, playerchunk2) -> {
+        int timeCompare =  Long.compare(playerchunk1.lastAutoSaveTime, playerchunk2.lastAutoSaveTime);
+        if (timeCompare != 0) {
+            return timeCompare;
+        }
+
+        return Long.compare(MCUtil.getCoordinateKey(playerchunk1.pos), MCUtil.getCoordinateKey(playerchunk2.pos));
+    });
+
+    protected void saveIncrementally() {
+        int savedThisTick = 0;
+        // optimized since we search far less chunks to hit ones that need to be saved
+        List<ChunkHolder> reschedule = new java.util.ArrayList<>(this.level.paperConfig.maxAutoSaveChunksPerTick);
+        long currentTick = this.level.getGameTime();
+        long maxSaveTime = currentTick - this.level.paperConfig.autoSavePeriod;
+
+        for (Iterator<ChunkHolder> iterator = this.autoSaveQueue.iterator(); iterator.hasNext();) {
+            ChunkHolder playerchunk = iterator.next();
+            if (playerchunk.lastAutoSaveTime > maxSaveTime) {
+                break;
+            }
+
+            iterator.remove();
+
+            ChunkAccess ichunkaccess = playerchunk.getChunkToSave().getNow(null);
+            if (ichunkaccess instanceof LevelChunk) {
+                boolean shouldSave = ((LevelChunk)ichunkaccess).lastSaveTime <= maxSaveTime;
+
+                if (shouldSave && this.save(ichunkaccess) && this.level.entityManager.storeChunkSections(playerchunk.pos.toLong(), entity -> {})) {
+                    ++savedThisTick;
+
+                    if (!playerchunk.setHasBeenLoaded()) {
+                        // do not fall through to reschedule logic
+                        playerchunk.inactiveTimeStart = currentTick;
+                        if (savedThisTick >= this.level.paperConfig.maxAutoSaveChunksPerTick) {
+                            break;
+                        }
+                        continue;
+                    }
+                }
+            }
+
+            reschedule.add(playerchunk);
+
+            if (savedThisTick >= this.level.paperConfig.maxAutoSaveChunksPerTick) {
+                break;
+            }
+        }
+
+        for (int i = 0, len = reschedule.size(); i < len; ++i) {
+            ChunkHolder playerchunk = reschedule.get(i);
+            playerchunk.lastAutoSaveTime = this.level.getGameTime();
+            this.autoSaveQueue.add(playerchunk);
+        }
+    }
+    // Paper end
+
     protected void saveAllChunks(boolean flush) {
+        Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunks = this.getVisibleChunks(); // Paper remove clone of visible Chunks unless saving off main thread (watchdog kill)
         if (flush) {
-            List<ChunkHolder> list = this.visibleChunkMap.values().stream().filter(ChunkHolder::wasAccessibleSinceLastSave).peek(ChunkHolder::refreshAccessibility).collect(Collectors.toList());
-            MutableBoolean mutableBoolean = new MutableBoolean();
+            List<ChunkHolder> list = (List) visibleChunks.values().stream().filter(ChunkHolder::wasAccessibleSinceLastSave).peek(ChunkHolder::refreshAccessibility).collect(Collectors.toList()); // Paper - remove cloning of visible chunks
+            MutableBoolean mutableboolean = new MutableBoolean();
 
             do {
-                mutableBoolean.setFalse();
-                list.stream().map((chunkHolder) -> {
-                    CompletableFuture<ChunkAccess> completableFuture;
+                boolean isShuttingDown = level.getServer().hasStopped(); // Paper
+                mutableboolean.setFalse();
+                list.stream().map((playerchunk) -> {
+                    CompletableFuture completablefuture;
+
                     do {
-                        completableFuture = chunkHolder.getChunkToSave();
-                        this.mainThreadExecutor.managedBlock(completableFuture::isDone);
-                    } while(completableFuture != chunkHolder.getChunkToSave());
+                        completablefuture = playerchunk.getChunkToSave();
+                        BlockableEventLoop iasynctaskhandler = this.mainThreadExecutor;
 
-                    return completableFuture.join();
-                }).filter((chunkAccess) -> {
-                    return chunkAccess instanceof ImposterProtoChunk || chunkAccess instanceof LevelChunk;
-                }).filter(this::save).forEach((chunkAccess) -> {
-                    mutableBoolean.setTrue();
+                        Objects.requireNonNull(completablefuture);
+                        iasynctaskhandler.managedBlock(completablefuture::isDone);
+                    } while (completablefuture != playerchunk.getChunkToSave());
+
+                    return (ChunkAccess) completablefuture.join();
+                }).filter((ichunkaccess) -> {
+                    return ichunkaccess instanceof ImposterProtoChunk || ichunkaccess instanceof LevelChunk;
+                }).filter(this::save).forEach((ichunkaccess) -> {
+                    mutableboolean.setTrue();
                 });
-            } while(mutableBoolean.isTrue());
+            } while (mutableboolean.isTrue());
 
             this.processUnloads(() -> {
                 return true;
             });
-            this.flushWorker();
+            this.level.asyncChunkTaskManager.flush(); // Paper - flush to preserve behavior compat with pre-async behaviour
+//            this.i(); // Paper - nuke IOWorker
         } else {
-            this.visibleChunkMap.values().stream().filter(ChunkHolder::wasAccessibleSinceLastSave).forEach((chunkHolder) -> {
-                ChunkAccess chunkAccess = chunkHolder.getChunkToSave().getNow((ChunkAccess)null);
-                if (chunkAccess instanceof ImposterProtoChunk || chunkAccess instanceof LevelChunk) {
-                    this.save(chunkAccess);
-                    chunkHolder.refreshAccessibility();
+            visibleChunks.values().stream().filter(ChunkHolder::wasAccessibleSinceLastSave).forEach((playerchunk) -> {
+                ChunkAccess ichunkaccess = (ChunkAccess) playerchunk.getChunkToSave().getNow(null); // CraftBukkit - decompile error
+
+                if (ichunkaccess instanceof ImposterProtoChunk || ichunkaccess instanceof LevelChunk) {
+                    this.save(ichunkaccess);
+                    playerchunk.refreshAccessibility();
                 }
 
             });
@@ -362,66 +1006,144 @@
 
     }
 
+    private static final double UNLOAD_QUEUE_RESIZE_FACTOR = 0.90; // Spigot // Paper - unload more
+
     protected void tick(BooleanSupplier shouldKeepTicking) {
-        ProfilerFiller profilerFiller = this.level.getProfiler();
-        profilerFiller.push("poi");
+        ProfilerFiller gameprofilerfiller = this.level.getProfiler();
+
+        try (Timing ignored = this.level.timings.poiUnload.startTiming()) { // Paper
+        gameprofilerfiller.push("poi");
         this.poiManager.tick(shouldKeepTicking);
-        profilerFiller.popPush("chunk_unload");
+        } // Paper
+        gameprofilerfiller.popPush("chunk_unload");
         if (!this.level.noSave()) {
+            try (Timing ignored = this.level.timings.chunkUnload.startTiming()) { // Paper
             this.processUnloads(shouldKeepTicking);
+            }// Paper
         }
 
-        profilerFiller.pop();
+        gameprofilerfiller.pop();
     }
 
     private void processUnloads(BooleanSupplier shouldKeepTicking) {
-        LongIterator longIterator = this.toDrop.iterator();
+        LongIterator longiterator = this.toDrop.iterator();
+        // Spigot start
+        org.spigotmc.SlackActivityAccountant activityAccountant = this.level.getServer().slackActivityAccountant;
+        activityAccountant.startActivity(0.5);
+        int targetSize = Math.min(this.toDrop.size() - 100,  (int) (this.toDrop.size() * ChunkMap.UNLOAD_QUEUE_RESIZE_FACTOR)); // Paper - Make more aggressive
+        // Spigot end
+        while (longiterator.hasNext()) { // Spigot
+            long j = longiterator.nextLong();
+            longiterator.remove(); // Spigot
+            ChunkHolder playerchunk = (ChunkHolder) this.updatingChunkMap.remove(j);
 
-        for(int i = 0; longIterator.hasNext() && (shouldKeepTicking.getAsBoolean() || i < 200 || this.toDrop.size() > 2000); longIterator.remove()) {
-            long l = longIterator.nextLong();
-            ChunkHolder chunkHolder = this.updatingChunkMap.remove(l);
-            if (chunkHolder != null) {
-                this.pendingUnloads.put(l, chunkHolder);
+            if (playerchunk != null) {
+                this.pendingUnloads.put(j, playerchunk);
                 this.modified = true;
-                ++i;
-                this.scheduleUnload(l, chunkHolder);
+                this.scheduleUnload(j, playerchunk); // Paper - Move up - don't leak chunks
+                // Spigot start
+                if (!shouldKeepTicking.getAsBoolean() && this.toDrop.size() <= targetSize && activityAccountant.activityTimeIsExhausted()) {
+                    break;
+                }
+                // Spigot end
+                //this.a(j, playerchunk); // Paper - move up because spigot did a dumb
             }
         }
+        activityAccountant.endActivity(); // Spigot
 
         Runnable runnable;
-        while((shouldKeepTicking.getAsBoolean() || this.unloadQueue.size() > 2000) && (runnable = this.unloadQueue.poll()) != null) {
+
+        int queueTarget = Math.min(this.unloadQueue.size() - 100, (int) (this.unloadQueue.size() * UNLOAD_QUEUE_RESIZE_FACTOR)); // Paper - Target this queue as well
+        while ((shouldKeepTicking.getAsBoolean() || this.unloadQueue.size() > queueTarget) && (runnable = (Runnable)this.unloadQueue.poll()) != null) { // Paper - Target this queue as well
             runnable.run();
         }
 
     }
 
+    // Paper start - async chunk save for unload
+    // Note: This is very unsafe to call if the chunk is still in use.
+    // This is also modeled after PlayerChunkMap#save(IChunkAccess, boolean), with the intentional difference being
+    // serializing the chunk is left to a worker thread.
+    private void asyncSave(ChunkAccess chunk) {
+        ChunkPos chunkPos = chunk.getPos();
+        CompoundTag poiData;
+        try (Timing ignored = this.level.timings.chunkUnloadPOISerialization.startTiming()) {
+            poiData = this.getVillagePlace().getData(chunk.getPos());
+        }
+
+        com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.level, chunkPos.x, chunkPos.z,
+            poiData, null, com.destroystokyo.paper.io.PrioritizedTaskQueue.LOW_PRIORITY);
+
+        if (!chunk.isUnsaved()) {
+            return;
+        }
+
+        ChunkStatus chunkstatus = chunk.getStatus();
+
+        // Copied from PlayerChunkMap#save(IChunkAccess, boolean)
+        if (chunkstatus.getChunkType() != ChunkStatus.ChunkType.LEVELCHUNK) {
+            // Paper start - Optimize save by using status cache
+            if (chunkstatus == ChunkStatus.EMPTY && chunk.getAllStarts().values().stream().noneMatch(StructureStart::isValid)) {
+                return;
+            }
+        }
+
+        ChunkSerializer.AsyncSaveData asyncSaveData;
+        try (Timing ignored = this.level.timings.chunkUnloadPrepareSave.startTiming()) {
+            asyncSaveData = ChunkSerializer.getAsyncSaveData(this.level, chunk);
+        }
+
+        this.level.asyncChunkTaskManager.scheduleChunkSave(chunkPos.x, chunkPos.z, com.destroystokyo.paper.io.PrioritizedTaskQueue.LOW_PRIORITY,
+            asyncSaveData, chunk);
+
+        chunk.setUnsaved(false);
+        chunk.setLastSaved(this.level.getGameTime()); // Paper - track last saved time
+    }
+    // Paper end
+
     private void scheduleUnload(long pos, ChunkHolder holder) {
-        CompletableFuture<ChunkAccess> completableFuture = holder.getChunkToSave();
-        completableFuture.thenAcceptAsync((chunk) -> {
-            CompletableFuture<ChunkAccess> completableFuture2 = holder.getChunkToSave();
-            if (completableFuture2 != completableFuture) {
+        CompletableFuture<ChunkAccess> completablefuture = holder.getChunkToSave();
+        Consumer<ChunkAccess> consumer = (ichunkaccess) -> { // CraftBukkit - decompile error
+            CompletableFuture<ChunkAccess> completablefuture1 = holder.getChunkToSave();
+
+            if (completablefuture1 != completablefuture) {
                 this.scheduleUnload(pos, holder);
             } else {
-                if (this.pendingUnloads.remove(pos, holder) && chunk != null) {
-                    if (chunk instanceof LevelChunk) {
-                        ((LevelChunk)chunk).setLoaded(false);
+                if (this.pendingUnloads.remove(pos, holder) && ichunkaccess != null) {
+                    if (ichunkaccess instanceof LevelChunk) {
+                        ((LevelChunk) ichunkaccess).setLoaded(false);
                     }
 
-                    this.save(chunk);
-                    if (this.entitiesInLevel.remove(pos) && chunk instanceof LevelChunk) {
-                        LevelChunk levelChunk = (LevelChunk)chunk;
-                        this.level.unload(levelChunk);
+                    // Paper start - async chunk saving
+                    try {
+                        this.asyncSave(ichunkaccess);
+                    } catch (ThreadDeath ex) {
+                        throw ex; // bye
+                    } catch (Throwable ex) {
+                        LOGGER.fatal("Failed to prepare async save, attempting synchronous save", ex);
+                        this.save(ichunkaccess);
+                    }
+                    // Paper end - async chunk saving
+                    if (this.entitiesInLevel.remove(pos) && ichunkaccess instanceof LevelChunk) {
+                        LevelChunk chunk = (LevelChunk) ichunkaccess;
+
+                        this.level.unload(chunk);
                     }
+                    this.autoSaveQueue.remove(holder); // Paper
 
-                    this.lightEngine.updateChunkStatus(chunk.getPos());
+                    this.lightEngine.updateChunkStatus(ichunkaccess.getPos());
                     this.lightEngine.tryScheduleUpdate();
-                    this.progressListener.onStatusChange(chunk.getPos(), (ChunkStatus)null);
+                    this.progressListener.onStatusChange(ichunkaccess.getPos(), (ChunkStatus) null);
                 }
 
             }
-        }, this.unloadQueue::add).whenComplete((void_, throwable) -> {
+        };
+        Queue queue = this.unloadQueue;
+
+        Objects.requireNonNull(this.unloadQueue);
+        completablefuture.thenAcceptAsync(consumer, queue::add).whenComplete((ovoid, throwable) -> {
             if (throwable != null) {
-                LOGGER.error("Failed to save chunk {}", holder.getPos(), throwable);
+                ChunkMap.LOGGER.error("Failed to save chunk {}", holder.getPos(), throwable);
             }
 
         });
@@ -431,28 +1153,44 @@
         if (!this.modified) {
             return false;
         } else {
-            this.visibleChunkMap = this.updatingChunkMap.clone();
+            // Paper start - stop cloning visibleChunks
+            synchronized (this.visibleChunkMap) {
+                if (isIterating) {
+                    hasPendingVisibleUpdate = true;
+                    this.pendingVisibleChunks.copyFrom((com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<ChunkHolder>)this.updatingChunkMap);
+                } else {
+                    hasPendingVisibleUpdate = false;
+                    this.pendingVisibleChunks.clear();
+                    ((ProtectedVisibleChunksMap)this.visibleChunkMap).copyFrom((com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<ChunkHolder>)this.updatingChunkMap);
+                    this.visibleChunksClone = null;
+                }
+            }
+            // Paper end
+
             this.modified = false;
             return true;
         }
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> schedule(ChunkHolder holder, ChunkStatus requiredStatus) {
-        ChunkPos chunkPos = holder.getPos();
+        ChunkPos chunkcoordintpair = holder.getPos();
+
         if (requiredStatus == ChunkStatus.EMPTY) {
-            return this.scheduleChunkLoad(chunkPos);
+            return this.scheduleChunkLoad(chunkcoordintpair);
         } else {
             if (requiredStatus == ChunkStatus.LIGHT) {
-                this.distanceManager.addTicket(TicketType.LIGHT, chunkPos, 33 + ChunkStatus.getDistance(ChunkStatus.LIGHT), chunkPos);
+                this.distanceManager.addTicket(TicketType.LIGHT, chunkcoordintpair, 33 + ChunkStatus.getDistance(ChunkStatus.LIGHT), chunkcoordintpair);
             }
 
-            Optional<ChunkAccess> optional = holder.getOrScheduleFuture(requiredStatus.getParent(), this).getNow(ChunkHolder.UNLOADED_CHUNK).left();
-            if (optional.isPresent() && optional.get().getStatus().isOrAfter(requiredStatus)) {
-                CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completableFuture = requiredStatus.load(this.level, this.structureManager, this.lightEngine, (chunkAccess) -> {
+            Optional<ChunkAccess> optional = ((Either) holder.getOrScheduleFuture(requiredStatus.getParent(), this).getNow(ChunkHolder.UNLOADED_CHUNK)).left();
+
+            if (optional.isPresent() && ((ChunkAccess) optional.get()).getStatus().isOrAfter(requiredStatus)) {
+                CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = requiredStatus.load(this.level, this.structureManager, this.lightEngine, (ichunkaccess) -> {
                     return this.protoChunkToFullChunk(holder);
-                }, optional.get());
-                this.progressListener.onStatusChange(chunkPos, requiredStatus);
-                return completableFuture;
+                }, (ChunkAccess) optional.get());
+
+                this.progressListener.onStatusChange(chunkcoordintpair, requiredStatus);
+                return completablefuture;
             } else {
                 return this.scheduleChunkGeneration(holder, requiredStatus);
             }
@@ -460,76 +1198,132 @@
     }
 
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> scheduleChunkLoad(ChunkPos pos) {
-        return CompletableFuture.supplyAsync(() -> {
-            try {
+        // Paper start - Async chunk io
+        final java.util.function.BiFunction<ChunkSerializer.InProgressChunkHolder, Throwable, Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> syncLoadComplete = (chunkHolder, ioThrowable) -> {
+            try (Timing ignored = this.level.timings.chunkLoad.startTimingIfSync()) { // Paper
                 this.level.getProfiler().incrementCounter("chunkLoad");
-                CompoundTag compoundTag = this.readChunk(pos);
-                if (compoundTag != null) {
-                    boolean bl = compoundTag.contains("Level", 10) && compoundTag.getCompound("Level").contains("Status", 8);
-                    if (bl) {
-                        ChunkAccess chunkAccess = ChunkSerializer.read(this.level, this.structureManager, this.poiManager, pos, compoundTag);
-                        this.markPosition(pos, chunkAccess.getStatus().getChunkType());
-                        return Either.left(chunkAccess);
+                // Paper start
+                if (ioThrowable != null) {
+                    com.destroystokyo.paper.util.SneakyThrow.sneaky(ioThrowable);
+                }
+
+                this.getVillagePlace().loadInData(pos, chunkHolder.poiData);
+                chunkHolder.tasks.forEach(Runnable::run);
+                // Paper end
+
+                if (chunkHolder.protoChunk != null) {try (Timing ignored2 = this.level.timings.chunkLoadLevelTimer.startTimingIfSync()) { // Paper start - timings // Paper - chunk is created async
+
+                    if (true) {
+                        ProtoChunk protochunk = chunkHolder.protoChunk;
+
+                        this.markPosition(pos, protochunk.getStatus().getChunkType());
+                        return Either.left(protochunk);
                     }
 
-                    LOGGER.error("Chunk file at {} is missing level data, skipping", (Object)pos);
-                }
-            } catch (ReportedException var5) {
-                Throwable throwable = var5.getCause();
+                    ChunkMap.LOGGER.error("Chunk file at {} is missing level data, skipping", pos);
+                }} // Paper
+            } catch (ReportedException reportedexception) {
+                Throwable throwable = reportedexception.getCause();
+
                 if (!(throwable instanceof IOException)) {
                     this.markPositionReplaceable(pos);
-                    throw var5;
+                    throw reportedexception;
                 }
 
-                LOGGER.error("Couldn't load chunk {}", pos, throwable);
-            } catch (Exception var6) {
-                LOGGER.error("Couldn't load chunk {}", pos, var6);
+                ChunkMap.LOGGER.error("Couldn't load chunk {}", pos, throwable);
+            } catch (Exception exception) {
+                ChunkMap.LOGGER.error("Couldn't load chunk {}", pos, exception);
             }
 
             this.markPositionReplaceable(pos);
-            return Either.left(new ProtoChunk(pos, UpgradeData.EMPTY, this.level));
-        }, this.mainThreadExecutor);
+            return Either.left(new ProtoChunk(pos, UpgradeData.EMPTY, this.level, this.level)); // Paper - add level
+            // Paper start - Async chunk io
+        };
+        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> ret = new CompletableFuture<>();
+
+        Consumer<ChunkSerializer.InProgressChunkHolder> chunkHolderConsumer = (ChunkSerializer.InProgressChunkHolder holder) -> {
+            // Go into the chunk load queue and not server task queue so we can be popped out even faster.
+            com.destroystokyo.paper.io.chunk.ChunkTaskManager.queueChunkWaitTask(() -> {
+                try {
+                    ret.complete(syncLoadComplete.apply(holder, null));
+                } catch (Exception e) {
+                    ret.completeExceptionally(e);
+                }
+            });
+        };
+
+        CompletableFuture<CompoundTag> chunkSaveFuture = this.level.asyncChunkTaskManager.getChunkSaveFuture(pos.x, pos.z);
+        // Paper start
+        ChunkHolder playerChunk = getUpdatingChunkIfPresent(pos.toLong());
+        int chunkPriority = playerChunk != null ? playerChunk.queueLevel : 33;
+        int priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY;
+
+        if (chunkPriority <= 10) {
+            priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
+        } else if (chunkPriority <= 20) {
+            priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY;
+        }
+        boolean isHighestPriority = priority == com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
+        // Paper end
+        if (chunkSaveFuture != null) {
+            this.level.asyncChunkTaskManager.scheduleChunkLoad(pos.x, pos.z, priority, chunkHolderConsumer, isHighestPriority, chunkSaveFuture); // Paper
+        } else {
+            this.level.asyncChunkTaskManager.scheduleChunkLoad(pos.x, pos.z, priority, chunkHolderConsumer, isHighestPriority); // Paper
+        }
+        this.level.asyncChunkTaskManager.raisePriority(pos.x, pos.z, priority); // Paper
+        return ret;
+        // Paper end
     }
 
-    private void markPositionReplaceable(ChunkPos chunkPos) {
-        this.chunkTypeCache.put(chunkPos.toLong(), (byte)-1);
+    private void markPositionReplaceable(ChunkPos chunkcoordintpair) {
+        this.chunkTypeCache.put(chunkcoordintpair.toLong(), (byte) -1);
     }
 
-    private byte markPosition(ChunkPos chunkPos, ChunkStatus.ChunkType chunkType) {
-        return this.chunkTypeCache.put(chunkPos.toLong(), (byte)(chunkType == ChunkStatus.ChunkType.PROTOCHUNK ? -1 : 1));
+    private byte markPosition(ChunkPos chunkcoordintpair, ChunkStatus.ChunkType chunkstatus_type) {
+        return this.chunkTypeCache.put(chunkcoordintpair.toLong(), (byte) (chunkstatus_type == ChunkStatus.ChunkType.PROTOCHUNK ? -1 : 1));
     }
 
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> scheduleChunkGeneration(ChunkHolder holder, ChunkStatus requiredStatus) {
-        ChunkPos chunkPos = holder.getPos();
-        CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> completableFuture = this.getChunkRangeFuture(chunkPos, requiredStatus.getRange(), (i) -> {
-            return this.getDependencyStatus(requiredStatus, i);
+        ChunkPos chunkcoordintpair = holder.getPos();
+        CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getChunkRangeFuture(chunkcoordintpair, requiredStatus.getRange(), (i) -> {
+            return this.a(requiredStatus, i);
         });
+
         this.level.getProfiler().incrementCounter(() -> {
             return "chunkGenerate " + requiredStatus.getName();
         });
         Executor executor = (runnable) -> {
+            // Paper start - optimize chunk status progression without jumping through thread pool
+            if (holder.canAdvanceStatus()) {
+                this.mainInvokingExecutor.execute(runnable);
+                return;
+            }
+            // Paper end
             this.worldgenMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, runnable));
         };
-        return completableFuture.thenComposeAsync((either) -> {
-            return either.map((list) -> {
+
+        return completablefuture.thenComposeAsync((either) -> {
+            return (CompletionStage) either.map((list) -> {
                 try {
-                    CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completableFuture = requiredStatus.generate(executor, this.level, this.generator, this.structureManager, this.lightEngine, (chunkAccess) -> {
+                    CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture1 = requiredStatus.generate(executor, this.level, this.generator, this.structureManager, this.lightEngine, (ichunkaccess) -> {
                         return this.protoChunkToFullChunk(holder);
                     }, list);
-                    this.progressListener.onStatusChange(chunkPos, requiredStatus);
-                    return completableFuture;
-                } catch (Exception var9) {
-                    var9.getStackTrace();
-                    CrashReport crashReport = CrashReport.forThrowable(var9, "Exception generating new chunk");
-                    CrashReportCategory crashReportCategory = crashReport.addCategory("Chunk to be generated");
-                    crashReportCategory.setDetail("Location", String.format("%d,%d", chunkPos.x, chunkPos.z));
-                    crashReportCategory.setDetail("Position hash", ChunkPos.asLong(chunkPos.x, chunkPos.z));
-                    crashReportCategory.setDetail("Generator", this.generator);
-                    throw new ReportedException(crashReport);
+
+                    this.progressListener.onStatusChange(chunkcoordintpair, requiredStatus);
+                    return completablefuture1;
+                } catch (Exception exception) {
+                    exception.getStackTrace();
+                    CrashReport crashreport = CrashReport.forThrowable(exception, "Exception generating new chunk");
+                    CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Chunk to be generated");
+
+                    crashreportsystemdetails.setDetail("Location", (Object) String.format("%d,%d", chunkcoordintpair.x, chunkcoordintpair.z));
+                    crashreportsystemdetails.setDetail("Position hash", (Object) ChunkPos.asLong(chunkcoordintpair.x, chunkcoordintpair.z));
+                    crashreportsystemdetails.setDetail("Generator", (Object) this.generator);
+                    throw new ReportedException(crashreport);
                 }
-            }, (chunkLoadingFailure) -> {
-                this.releaseLightTicket(chunkPos);
-                return CompletableFuture.completedFuture(Either.right(chunkLoadingFailure));
+            }, (playerchunk_failure) -> {
+                this.releaseLightTicket(chunkcoordintpair);
+                return CompletableFuture.completedFuture(Either.right(playerchunk_failure));
             });
         }, executor);
     }
@@ -542,94 +1336,156 @@
         }));
     }
 
-    private ChunkStatus getDependencyStatus(ChunkStatus centerChunkTargetStatus, int distance) {
-        ChunkStatus chunkStatus;
-        if (distance == 0) {
-            chunkStatus = centerChunkTargetStatus.getParent();
+    private ChunkStatus a(ChunkStatus chunkstatus, int i) {
+        ChunkStatus chunkstatus1;
+
+        if (i == 0) {
+            chunkstatus1 = chunkstatus.getParent();
         } else {
-            chunkStatus = ChunkStatus.getStatusAroundFullChunk(ChunkStatus.getDistance(centerChunkTargetStatus) + distance);
+            chunkstatus1 = ChunkStatus.getStatusAroundFullChunk(ChunkStatus.getDistance(chunkstatus) + i);
         }
 
-        return chunkStatus;
+        return chunkstatus1;
     }
 
-    private static void postLoadProtoChunk(ServerLevel serverLevel, List<CompoundTag> list) {
+    private static void postLoadProtoChunk(ServerLevel worldserver, List<CompoundTag> list) {
         if (!list.isEmpty()) {
-            serverLevel.addWorldGenChunkEntities(EntityType.loadEntitiesRecursive(list, serverLevel));
+            // CraftBukkit start - these are spawned serialized (DefinedStructure) and we don't call an add event below at the moment due to ordering complexities
+            worldserver.addWorldGenChunkEntities(EntityType.loadEntitiesRecursive(list, (Level) worldserver).filter((entity) -> {
+                boolean needsRemoval = false;
+                net.minecraft.server.dedicated.DedicatedServer server = worldserver.getCraftServer().getServer();
+                if (!server.areNpcsEnabled() && entity instanceof net.minecraft.world.entity.npc.Npc) {
+                    entity.discard();
+                    needsRemoval = true;
+                }
+                if (!server.isSpawningAnimals() && (entity instanceof net.minecraft.world.entity.animal.Animal || entity instanceof net.minecraft.world.entity.animal.WaterAnimal)) {
+                    entity.discard();
+                    needsRemoval = true;
+                }
+                checkDupeUUID(worldserver, entity); // Paper
+                return !needsRemoval;
+            }));
+            // CraftBukkit end
         }
 
     }
 
-    private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> protoChunkToFullChunk(ChunkHolder chunkHolder) {
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completableFuture = chunkHolder.getFutureIfPresentUnchecked(ChunkStatus.FULL.getParent());
-        return completableFuture.thenApplyAsync((either) -> {
-            ChunkStatus chunkStatus = ChunkHolder.getStatus(chunkHolder.getTicketLevel());
-            return !chunkStatus.isOrAfter(ChunkStatus.FULL) ? ChunkHolder.UNLOADED_CHUNK : either.mapLeft((chunkAccess) -> {
-                ChunkPos chunkPos = chunkHolder.getPos();
-                ProtoChunk protoChunk = (ProtoChunk)chunkAccess;
-                LevelChunk levelChunk;
-                if (protoChunk instanceof ImposterProtoChunk) {
-                    levelChunk = ((ImposterProtoChunk)protoChunk).getWrapped();
+    private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> protoChunkToFullChunk(ChunkHolder playerchunk) {
+        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = playerchunk.getFutureIfPresentUnchecked(ChunkStatus.FULL.getParent());
+
+        return completablefuture.thenApplyAsync((either) -> {
+            ChunkStatus chunkstatus = ChunkHolder.getStatus(playerchunk.getTicketLevel());
+
+            return !chunkstatus.isOrAfter(ChunkStatus.FULL) ? ChunkHolder.UNLOADED_CHUNK : either.mapLeft((ichunkaccess) -> {
+            try (Timing ignored = level.timings.chunkPostLoad.startTimingIfSync()) { // Paper
+                ChunkPos chunkcoordintpair = playerchunk.getPos();
+                ProtoChunk protochunk = (ProtoChunk) ichunkaccess;
+                LevelChunk chunk;
+
+                if (protochunk instanceof ImposterProtoChunk) {
+                    chunk = ((ImposterProtoChunk) protochunk).getWrapped();
                 } else {
-                    levelChunk = new LevelChunk(this.level, protoChunk, (levelChunk) -> {
-                        postLoadProtoChunk(this.level, protoChunk.getEntities());
+                    chunk = new LevelChunk(this.level, protochunk, (chunk1) -> {
+                        ChunkMap.postLoadProtoChunk(this.level, protochunk.getEntities());
                     });
-                    chunkHolder.replaceProtoChunk(new ImposterProtoChunk(levelChunk));
+                    playerchunk.replaceProtoChunk(new ImposterProtoChunk(chunk));
                 }
 
-                levelChunk.setFullStatus(() -> {
-                    return ChunkHolder.getFullChunkStatus(chunkHolder.getTicketLevel());
+                chunk.setFullStatus(() -> {
+                    return ChunkHolder.getFullChunkStatus(playerchunk.getTicketLevel());
                 });
-                levelChunk.runPostLoad();
-                if (this.entitiesInLevel.add(chunkPos.toLong())) {
-                    levelChunk.setLoaded(true);
-                    levelChunk.registerAllBlockEntitiesAfterLevelLoad();
+                chunk.runPostLoad();
+                if (this.entitiesInLevel.add(chunkcoordintpair.toLong())) {
+                    chunk.setLoaded(true);
+                    chunk.registerAllBlockEntitiesAfterLevelLoad();
                 }
 
-                return levelChunk;
+                return chunk;
+                } // Paper
             });
         }, (runnable) -> {
-            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(runnable, chunkHolder.getPos().toLong(), chunkHolder::getTicketLevel));
+            ProcessorHandle mailbox = this.mainThreadMailbox;
+            long i = playerchunk.getPos().toLong();
+
+            Objects.requireNonNull(playerchunk);
+            mailbox.tell(ChunkTaskPriorityQueueSorter.message(runnable, i, () -> 1)); // Paper - final loads are always urgent!
         });
     }
 
+    // Paper start
+    private static void checkDupeUUID(ServerLevel level, Entity entity) {
+        PaperWorldConfig.DuplicateUUIDMode mode = level.paperConfig.duplicateUUIDMode;
+        if (mode != PaperWorldConfig.DuplicateUUIDMode.WARN
+            && mode != PaperWorldConfig.DuplicateUUIDMode.DELETE
+            && mode != PaperWorldConfig.DuplicateUUIDMode.SAFE_REGEN) {
+            return;
+        }
+        Entity other = level.getEntity(entity.getUUID());
+
+        if (mode == PaperWorldConfig.DuplicateUUIDMode.SAFE_REGEN && other != null && !other.isRemoved()
+            && Objects.equals(other.getEncodeId(), entity.getEncodeId())
+            && entity.getBukkitEntity().getLocation().distance(other.getBukkitEntity().getLocation()) < level.paperConfig.duplicateUUIDDeleteRange
+        ) {
+            if (Level.DEBUG_ENTITIES) LOGGER.warn("[DUPE-UUID] Duplicate UUID found used by " + other + ", deleted entity " + entity + " because it was near the duplicate and likely an actual duplicate. See https://github.com/PaperMC/Paper/issues/1223 for discussion on what this is about.");
+            entity.discard();
+            return;
+        }
+        if (other != null && !other.isRemoved()) {
+            switch (mode) {
+                case SAFE_REGEN: {
+                    entity.setUUID(UUID.randomUUID());
+                    if (Level.DEBUG_ENTITIES) LOGGER.warn("[DUPE-UUID] Duplicate UUID found used by " + other + ", regenerated UUID for " + entity + ". See https://github.com/PaperMC/Paper/issues/1223 for discussion on what this is about.");
+                    break;
+                }
+                case DELETE: {
+                    if (Level.DEBUG_ENTITIES) LOGGER.warn("[DUPE-UUID] Duplicate UUID found used by " + other + ", deleted entity " + entity + ". See https://github.com/PaperMC/Paper/issues/1223 for discussion on what this is about.");
+                    entity.discard();
+                    break;
+                }
+                default:
+                    if (Level.DEBUG_ENTITIES) LOGGER.warn("[DUPE-UUID] Duplicate UUID found used by " + other + ", doing nothing to " + entity + ". See https://github.com/PaperMC/Paper/issues/1223 for discussion on what this is about.");
+                    break;
+            }
+        }
+    }
+    // Paper end
     public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> prepareTickingChunk(ChunkHolder holder) {
-        ChunkPos chunkPos = holder.getPos();
-        CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> completableFuture = this.getChunkRangeFuture(chunkPos, 1, (i) -> {
+        ChunkPos chunkcoordintpair = holder.getPos();
+        CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getChunkRangeFuture(chunkcoordintpair, 1, (i) -> {
             return ChunkStatus.FULL;
         });
-        CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completableFuture2 = completableFuture.thenApplyAsync((either) -> {
+        CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture1 = completablefuture.thenApplyAsync((either) -> {
             return either.flatMap((list) -> {
-                LevelChunk levelChunk = (LevelChunk)list.get(list.size() / 2);
-                levelChunk.postProcessGeneration();
-                return Either.left(levelChunk);
+                LevelChunk chunk = (LevelChunk) list.get(list.size() / 2);
+
+                chunk.postProcessGeneration();
+                return Either.left(chunk);
             });
         }, (runnable) -> {
-            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, runnable));
+            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, () -> ChunkMap.this.chunkLoadConversionCallbackExecutor.execute(runnable))); // Paper - delay running Chunk post processing until outside of the sorter to prevent a deadlock scenario when post processing causes another chunk request.
         });
-        completableFuture2.thenAcceptAsync((either) -> {
-            either.ifLeft((levelChunk) -> {
+
+        completablefuture1.thenAcceptAsync((either) -> {
+            either.ifLeft((chunk) -> {
                 this.tickingGenerated.getAndIncrement();
-                Packet<?>[] packets = new Packet[2];
-                this.getPlayers(chunkPos, false).forEach((serverPlayer) -> {
-                    this.playerLoadedChunk(serverPlayer, packets, levelChunk);
-                });
+                // Paper - no-tick view distance - moved to Chunk neighbour update
             });
         }, (runnable) -> {
-            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, runnable));
+            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, runnable)); // Paper - diff on change, this is the scheduling method copied in Chunk used to schedule chunk broadcasts (on change it needs to be copied again)
         });
-        return completableFuture2;
+        return completablefuture1;
     }
 
-    public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> prepareAccessibleChunk(ChunkHolder chunkHolder) {
-        return this.getChunkRangeFuture(chunkHolder.getPos(), 1, ChunkStatus::getStatusAroundFullChunk).thenApplyAsync((either) -> {
+    public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> prepareAccessibleChunk(ChunkHolder playerchunk) {
+        return this.getChunkRangeFuture(playerchunk.getPos(), 1, ChunkStatus::getStatusAroundFullChunk).thenApplyAsync((either) -> {
             return either.mapLeft((list) -> {
-                LevelChunk levelChunk = (LevelChunk)list.get(list.size() / 2);
-                levelChunk.unpackTicks();
-                return levelChunk;
+                LevelChunk chunk = (LevelChunk) list.get(list.size() / 2);
+
+                chunk.unpackTicks();
+                return chunk;
             });
         }, (runnable) -> {
-            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(chunkHolder, runnable));
+            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(playerchunk, runnable));
         });
     }
 
@@ -637,77 +1493,106 @@
         return this.tickingGenerated.get();
     }
 
-    private boolean save(ChunkAccess chunk) {
+    public boolean save(ChunkAccess chunk) {
+        try (co.aikar.timings.Timing ignored = this.level.timings.chunkSave.startTiming()) { // Paper
         this.poiManager.flush(chunk.getPos());
         if (!chunk.isUnsaved()) {
             return false;
         } else {
+            chunk.setLastSaved(this.level.getGameTime()); // Paper - track save time
             chunk.setUnsaved(false);
-            ChunkPos chunkPos = chunk.getPos();
+            ChunkPos chunkcoordintpair = chunk.getPos();
 
             try {
-                ChunkStatus chunkStatus = chunk.getStatus();
-                if (chunkStatus.getChunkType() != ChunkStatus.ChunkType.LEVELCHUNK) {
-                    if (this.isExistingChunkFull(chunkPos)) {
+                ChunkStatus chunkstatus = chunk.getStatus();
+
+                if (chunkstatus.getChunkType() != ChunkStatus.ChunkType.LEVELCHUNK) {
+                    if (false && this.isExistingChunkFull(chunkcoordintpair)) { // Paper
                         return false;
                     }
 
-                    if (chunkStatus == ChunkStatus.EMPTY && chunk.getAllStarts().values().stream().noneMatch(StructureStart::isValid)) {
+                    if (chunkstatus == ChunkStatus.EMPTY && chunk.getAllStarts().values().stream().noneMatch(StructureStart::isValid)) {
                         return false;
                     }
                 }
 
                 this.level.getProfiler().incrementCounter("chunkSave");
-                CompoundTag compoundTag = ChunkSerializer.write(this.level, chunk);
-                this.write(chunkPos, compoundTag);
-                this.markPosition(chunkPos, chunkStatus.getChunkType());
+                CompoundTag nbttagcompound;
+                try (co.aikar.timings.Timing ignored1 = this.level.timings.chunkSaveDataSerialization.startTiming()) { // Paper
+                    nbttagcompound = ChunkSerializer.write(this.level, chunk);
+                } // Paper
+
+
+                // Paper start - async chunk io
+                com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.level, chunkcoordintpair.x, chunkcoordintpair.z,
+                    null, nbttagcompound, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY);
+                // Paper end - async chunk io
+                this.markPosition(chunkcoordintpair, chunkstatus.getChunkType());
                 return true;
-            } catch (Exception var5) {
-                LOGGER.error("Failed to save chunk {},{}", chunkPos.x, chunkPos.z, var5);
+            } catch (Exception exception) {
+                ChunkMap.LOGGER.error("Failed to save chunk {},{}", chunkcoordintpair.x, chunkcoordintpair.z, exception);
+                com.destroystokyo.paper.exception.ServerInternalException.reportInternalException(exception); // Paper
                 return false;
             }
         }
+        } // Paper
     }
 
-    private boolean isExistingChunkFull(ChunkPos chunkPos) {
-        byte b = this.chunkTypeCache.get(chunkPos.toLong());
-        if (b != 0) {
-            return b == 1;
+    private boolean isExistingChunkFull(ChunkPos chunkcoordintpair) {
+        byte b0 = this.chunkTypeCache.get(chunkcoordintpair.toLong());
+
+        if (b0 != 0) {
+            return b0 == 1;
         } else {
-            CompoundTag compoundTag;
+            CompoundTag nbttagcompound;
+
             try {
-                compoundTag = this.readChunk(chunkPos);
-                if (compoundTag == null) {
-                    this.markPositionReplaceable(chunkPos);
+                nbttagcompound = this.readChunk(chunkcoordintpair);
+                if (nbttagcompound == null) {
+                    this.markPositionReplaceable(chunkcoordintpair);
                     return false;
                 }
-            } catch (Exception var5) {
-                LOGGER.error("Failed to read chunk {}", chunkPos, var5);
-                this.markPositionReplaceable(chunkPos);
+            } catch (Exception exception) {
+                ChunkMap.LOGGER.error("Failed to read chunk {}", chunkcoordintpair, exception);
+                this.markPositionReplaceable(chunkcoordintpair);
                 return false;
             }
 
-            ChunkStatus.ChunkType chunkType = ChunkSerializer.getChunkTypeFromTag(compoundTag);
-            return this.markPosition(chunkPos, chunkType) == 1;
+            ChunkStatus.ChunkType chunkstatus_type = ChunkSerializer.getChunkTypeFromTag(nbttagcompound);
+
+            return this.markPosition(chunkcoordintpair, chunkstatus_type) == 1;
         }
     }
 
-    protected void setViewDistance(int watchDistance) {
-        int i = Mth.clamp(watchDistance + 1, 3, 33);
-        if (i != this.viewDistance) {
-            int j = this.viewDistance;
-            this.viewDistance = i;
-            this.distanceManager.updatePlayerTickets(this.viewDistance);
+    public void setViewDistance(int watchDistance) {
+        int j = Mth.clamp(watchDistance + 1, 3, 33); // Paper - diff on change, these make the lower view distance limit 2 and the upper 32
 
-            for(ChunkHolder chunkHolder : this.updatingChunkMap.values()) {
-                ChunkPos chunkPos = chunkHolder.getPos();
-                Packet<?>[] packets = new Packet[2];
-                this.getPlayers(chunkPos, false).forEach((serverPlayer) -> {
-                    int j = checkerboardDistance(chunkPos, serverPlayer, true);
-                    boolean bl = j <= j;
-                    boolean bl2 = j <= this.viewDistance;
-                    this.updateChunkTracking(serverPlayer, chunkPos, packets, bl, bl2);
-                });
+        if (j != this.viewDistance) {
+            int k = this.viewDistance;
+
+            this.viewDistance = j;
+            this.setNoTickViewDistance(this.getRawNoTickViewDistance()); //Paper - no-tick view distance - propagate changes to no-tick, which does the actual chunk loading/sending
+        }
+
+    }
+
+    // Paper start - no-tick view distance
+    public final void setNoTickViewDistance(int viewDistance) {
+        viewDistance = viewDistance == -1 ? -1 : Mth.clamp(viewDistance, 2, 32);
+
+        this.noTickViewDistance = viewDistance;
+        int loadViewDistance = this.getLoadViewDistance();
+        this.distanceManager.setNoTickViewDistance(loadViewDistance + 2 + 2); // add 2 to account for the change to 31 -> 33 tickets // see notes in the distance map updating for the other + 2
+
+        if (this.level != null && this.level.players != null) { // this can be called from constructor, where these aren't set
+            for (ServerPlayer player : this.level.players) {
+                net.minecraft.server.network.ServerGamePacketListenerImpl connection = player.connection;
+                if (connection != null) {
+                    // moved in from PlayerList
+                    connection.send(new net.minecraft.network.protocol.game.ClientboundSetChunkCacheRadiusPacket(loadViewDistance));
+                }
+                this.updateMaps(player);
+                // Paper end - no-tick view distance
             }
         }
 
@@ -716,11 +1601,13 @@
     protected void updateChunkTracking(ServerPlayer player, ChunkPos pos, Packet<?>[] packets, boolean withinMaxWatchDistance, boolean withinViewDistance) {
         if (player.level == this.level) {
             if (withinViewDistance && !withinMaxWatchDistance) {
-                ChunkHolder chunkHolder = this.getVisibleChunkIfPresent(pos.toLong());
-                if (chunkHolder != null) {
-                    LevelChunk levelChunk = chunkHolder.getTickingChunk();
-                    if (levelChunk != null) {
-                        this.playerLoadedChunk(player, packets, levelChunk);
+                ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos.toLong());
+
+                if (playerchunk != null) {
+                    LevelChunk chunk = playerchunk.getSendingChunk(); // Paper - no-tick view distance
+
+                    if (chunk != null) {
+                        this.playerLoadedChunk(player, packets, chunk);
                     }
 
                     DebugPackets.sendPoiPacketsForChunk(this.level, pos);
@@ -738,207 +1625,393 @@
         return this.visibleChunkMap.size();
     }
 
-    protected net.minecraft.server.level.DistanceManager getDistanceManager() {
+    protected DistanceManager getDistanceManager() {
         return this.distanceManager;
     }
 
     protected Iterable<ChunkHolder> getChunks() {
-        return Iterables.unmodifiableIterable(this.visibleChunkMap.values());
+        return Iterables.unmodifiableIterable(this.getVisibleChunks().values()); // Paper
     }
 
     void dumpChunks(Writer writer) throws IOException {
-        CsvOutput csvOutput = CsvOutput.builder().addColumn("x").addColumn("z").addColumn("level").addColumn("in_memory").addColumn("status").addColumn("full_status").addColumn("accessible_ready").addColumn("ticking_ready").addColumn("entity_ticking_ready").addColumn("ticket").addColumn("spawning").addColumn("block_entity_count").build(writer);
+        CsvOutput csvwriter = CsvOutput.builder().addColumn("x").addColumn("z").addColumn("level").addColumn("in_memory").addColumn("status").addColumn("full_status").addColumn("accessible_ready").addColumn("ticking_ready").addColumn("entity_ticking_ready").addColumn("ticket").addColumn("spawning").addColumn("block_entity_count").build(writer);
+        ObjectBidirectionalIterator objectbidirectionaliterator = this.getVisibleChunks().long2ObjectEntrySet().iterator(); // Paper
 
-        for(Entry<ChunkHolder> entry : this.visibleChunkMap.long2ObjectEntrySet()) {
-            ChunkPos chunkPos = new ChunkPos(entry.getLongKey());
-            ChunkHolder chunkHolder = entry.getValue();
-            Optional<ChunkAccess> optional = Optional.ofNullable(chunkHolder.getLastAvailable());
-            Optional<LevelChunk> optional2 = optional.flatMap((chunk) -> {
-                return chunk instanceof LevelChunk ? Optional.of((LevelChunk)chunk) : Optional.empty();
+        while (objectbidirectionaliterator.hasNext()) {
+            Entry<ChunkHolder> entry = (Entry) objectbidirectionaliterator.next();
+            ChunkPos chunkcoordintpair = new ChunkPos(entry.getLongKey());
+            ChunkHolder playerchunk = (ChunkHolder) entry.getValue();
+            Optional<ChunkAccess> optional = Optional.ofNullable(playerchunk.getLastAvailable());
+            Optional<LevelChunk> optional1 = optional.flatMap((ichunkaccess) -> {
+                return ichunkaccess instanceof LevelChunk ? Optional.of((LevelChunk) ichunkaccess) : Optional.empty();
             });
-            csvOutput.writeRow(chunkPos.x, chunkPos.z, chunkHolder.getTicketLevel(), optional.isPresent(), optional.map(ChunkAccess::getStatus).orElse((ChunkStatus)null), optional2.map(LevelChunk::getFullStatus).orElse((ChunkHolder.FullChunkStatus)null), printFuture(chunkHolder.getFullChunkFuture()), printFuture(chunkHolder.getTickingChunkFuture()), printFuture(chunkHolder.getEntityTickingChunkFuture()), this.distanceManager.getTicketDebugString(entry.getLongKey()), !this.noPlayersCloseForSpawning(chunkPos), optional2.map((levelChunk) -> {
-                return levelChunk.getBlockEntities().size();
+
+            // CraftBukkit - decompile error
+            csvwriter.writeRow(chunkcoordintpair.x, chunkcoordintpair.z, playerchunk.getTicketLevel(), optional.isPresent(), optional.map(ChunkAccess::getStatus).orElse(null), optional1.map(LevelChunk::getFullStatus).orElse(null), ChunkMap.printFuture(playerchunk.getFullChunkFuture()), ChunkMap.printFuture(playerchunk.getTickingChunkFuture()), ChunkMap.printFuture(playerchunk.getEntityTickingChunkFuture()), this.distanceManager.getTicketDebugString(entry.getLongKey()), !this.noPlayersCloseForSpawning(chunkcoordintpair), optional1.map((chunk) -> {
+                return chunk.getBlockEntities().size();
             }).orElse(0));
         }
 
     }
 
-    private static String printFuture(CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completableFuture) {
+    private static String printFuture(CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture) {
         try {
-            Either<LevelChunk, ChunkHolder.ChunkLoadingFailure> either = completableFuture.getNow((Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>)null);
-            return either != null ? either.map((levelChunk) -> {
+            Either<LevelChunk, ChunkHolder.ChunkLoadingFailure> either = (Either) completablefuture.getNow(null); // CraftBukkit - decompile error
+
+            return either != null ? (String) either.map((chunk) -> {
                 return "done";
-            }, (chunkLoadingFailure) -> {
+            }, (playerchunk_failure) -> {
                 return "unloaded";
             }) : "not completed";
-        } catch (CompletionException var2) {
-            return "failed " + var2.getCause().getMessage();
-        } catch (CancellationException var3) {
+        } catch (CompletionException completionexception) {
+            return "failed " + completionexception.getCause().getMessage();
+        } catch (CancellationException cancellationexception) {
             return "cancelled";
         }
     }
 
+    // Paper start - Asynchronous chunk io
     @Nullable
-    private CompoundTag readChunk(ChunkPos pos) throws IOException {
-        CompoundTag compoundTag = this.read(pos);
-        return compoundTag == null ? null : this.upgradeChunkTag(this.level.dimension(), this.overworldDataStorage, compoundTag);
+    @Override
+    public CompoundTag read(ChunkPos chunkcoordintpair) throws IOException {
+        if (Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
+            CompoundTag ret = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE
+                .loadChunkDataAsyncFuture(this.level, chunkcoordintpair.x, chunkcoordintpair.z, com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread(),
+                    false, true, true).join().chunkData;
+
+            if (ret == com.destroystokyo.paper.io.PaperFileIOThread.FAILURE_VALUE) {
+                throw new IOException("See logs for further detail");
+            }
+            return ret;
+        }
+        return super.read(chunkcoordintpair);
+    }
+
+    @Override
+    public void write(ChunkPos chunkcoordintpair, CompoundTag nbttagcompound) throws IOException {
+        if (Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
+            com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(
+                this.level, chunkcoordintpair.x, chunkcoordintpair.z, null, nbttagcompound,
+                com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
+            return;
+        }
+        super.write(chunkcoordintpair, nbttagcompound);
+    }
+    // Paper end
+
+    @Nullable
+    public CompoundTag readChunk(ChunkPos pos) throws IOException {
+        CompoundTag nbttagcompound = this.read(pos);
+        // Paper start - Cache chunk status on disk
+        if (nbttagcompound == null) {
+            return null;
+        }
+
+        nbttagcompound = this.getChunkData(this.level.getTypeKey(), this.overworldDataStorage, nbttagcompound, pos, level); // CraftBukkit
+        if (nbttagcompound == null) {
+            return null;
+        }
+
+        this.updateChunkStatusOnDisk(pos, nbttagcompound);
+
+        return nbttagcompound;
+        // Paper end
+    }
+
+    // Paper start - chunk status cache "api"
+    public ChunkStatus getChunkStatusOnDiskIfCached(ChunkPos chunkPos) {
+        RegionFile regionFile = regionFileCache.getRegionFileIfLoaded(chunkPos);
+
+        return regionFile == null ? null : regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
+    }
+
+    public ChunkStatus getChunkStatusOnDisk(ChunkPos chunkPos) throws IOException {
+        RegionFile regionFile = regionFileCache.getFile(chunkPos, true);
+
+        if (regionFile == null || !regionFileCache.chunkExists(chunkPos)) {
+            return null;
+        }
+
+        ChunkStatus status = regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
+
+        if (status != null) {
+            return status;
+        }
+
+        this.readChunk(chunkPos);
+
+        return regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
+    }
+
+    public void updateChunkStatusOnDisk(ChunkPos chunkPos, @Nullable CompoundTag compound) throws IOException {
+        RegionFile regionFile = regionFileCache.getFile(chunkPos, false);
+
+        regionFile.setStatus(chunkPos.x, chunkPos.z, ChunkSerializer.getStatus(compound));
+    }
+
+    public ChunkAccess getUnloadingChunk(int chunkX, int chunkZ) {
+        ChunkHolder chunkHolder = this.pendingUnloads.get(ChunkPos.asLong(chunkX, chunkZ));
+        return chunkHolder == null ? null : chunkHolder.getAvailableChunkNow();
     }
+    // Paper end
 
     boolean noPlayersCloseForSpawning(ChunkPos chunkPos) {
-        long l = chunkPos.toLong();
-        return !this.distanceManager.hasPlayersNearby(l) ? true : this.playerMap.getPlayers(l).noneMatch((serverPlayer) -> {
-            return !serverPlayer.isSpectator() && euclideanDistanceSquared(chunkPos, serverPlayer) < 16384.0D;
-        });
+        // Spigot start
+        return this.isOutsideOfRange(chunkPos, false);
+    }
+
+    // Paper start - optimise isOutsideOfRange
+    final boolean isOutsideOfRange(ChunkPos chunkcoordintpair, boolean reducedRange) {
+        return this.isOutsideOfRange(this.getUpdatingChunkIfPresent(chunkcoordintpair.toLong()), chunkcoordintpair, reducedRange);
+    }
+    final boolean isOutsideOfRange(ChunkHolder playerchunk, ChunkPos chunkcoordintpair, boolean reducedRange) {
+        // this function is so hot that removing the map lookup call can have an order of magnitude impact on its performance
+        // tested and confirmed via System.nanoTime()
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInRange = reducedRange ? playerchunk.playersInMobSpawnRange : playerchunk.playersInChunkTickRange;
+        if (playersInRange == null) {
+            return true;
+        }
+        Object[] backingSet = playersInRange.getBackingSet();
+
+        if (reducedRange) {
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object raw = backingSet[i];
+                if (!(raw instanceof ServerPlayer)) {
+                    continue;
+                }
+                ServerPlayer player = (ServerPlayer) raw;
+                // don't check spectator and whatnot, already handled by mob spawn map update
+                if (player.lastEntitySpawnRadiusSquared > euclideanDistanceSquared(chunkcoordintpair, player)) {
+                    return false; // in range
+                }
+            }
+        } else {
+            final double range = (DistanceManager.MOB_SPAWN_RANGE * 16) * (DistanceManager.MOB_SPAWN_RANGE * 16);
+            // before spigot, mob spawn range was actually mob spawn range + tick range, but it was split
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object raw = backingSet[i];
+                if (!(raw instanceof ServerPlayer)) {
+                    continue;
+                }
+                ServerPlayer player = (ServerPlayer) raw;
+                // don't check spectator and whatnot, already handled by mob spawn map update
+                if (range > euclideanDistanceSquared(chunkcoordintpair, player)) {
+                    return false; // in range
+                }
+            }
+        }
+        // no players in range
+        return true;
     }
+    // Paper end - optimise isOutsideOfRange
 
     private boolean skipPlayer(ServerPlayer player) {
         return player.isSpectator() && !this.level.getGameRules().getBoolean(GameRules.RULE_SPECTATORSGENERATECHUNKS);
     }
 
     void updatePlayerStatus(ServerPlayer player, boolean added) {
-        boolean bl = this.skipPlayer(player);
-        boolean bl2 = this.playerMap.ignoredOrUnknown(player);
+        boolean flag1 = this.skipPlayer(player);
+        boolean flag2 = this.playerMap.ignoredOrUnknown(player);
         int i = SectionPos.blockToSectionCoord(player.getBlockX());
         int j = SectionPos.blockToSectionCoord(player.getBlockZ());
+
         if (added) {
-            this.playerMap.addPlayer(ChunkPos.asLong(i, j), player, bl);
+            this.playerMap.addPlayer(ChunkPos.asLong(i, j), player, flag1);
             this.updatePlayerPos(player);
-            if (!bl) {
-                this.distanceManager.addPlayer(SectionPos.of(player), player);
+            if (!flag1) {
+                this.distanceManager.addPlayer(SectionPos.of((Entity) player), player);
             }
+            this.addPlayerToDistanceMaps(player); // Paper - distance maps
         } else {
-            SectionPos sectionPos = player.getLastSectionPos();
-            this.playerMap.removePlayer(sectionPos.chunk().toLong(), player);
-            if (!bl2) {
-                this.distanceManager.removePlayer(sectionPos, player);
-            }
-        }
+            SectionPos sectionposition = player.getLastSectionPos();
 
-        for(int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
-            for(int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
-                ChunkPos chunkPos = new ChunkPos(k, l);
-                this.updateChunkTracking(player, chunkPos, new Packet[2], !added, added);
+            this.playerMap.removePlayer(sectionposition.chunk().toLong(), player);
+            if (!flag2) {
+                this.distanceManager.removePlayer(sectionposition, player);
             }
+            this.removePlayerFromDistanceMaps(player); // Paper - distance maps
         }
 
+        // Paper - broadcast view distance map handles this (see remove/add calls above)
+
     }
 
     private SectionPos updatePlayerPos(ServerPlayer player) {
-        SectionPos sectionPos = SectionPos.of(player);
-        player.setLastSectionPos(sectionPos);
-        player.connection.send(new ClientboundSetChunkCacheCenterPacket(sectionPos.x(), sectionPos.z()));
-        return sectionPos;
+        SectionPos sectionposition = SectionPos.of((Entity) player);
+
+        player.setLastSectionPos(sectionposition);
+        // player.connection.send(new ClientboundSetChunkCacheCenterPacket(sectionposition.x(), sectionposition.z())); // Paper - distance map handles this now
+        return sectionposition;
     }
 
     public void move(ServerPlayer player) {
-        for(ChunkMap.TrackedEntity trackedEntity : this.entityMap.values()) {
-            if (trackedEntity.entity == player) {
-                trackedEntity.updatePlayers(this.level.players());
-            } else {
-                trackedEntity.updatePlayer(player);
-            }
-        }
+        // Paper - delay this logic for the entity tracker tick, no need to duplicate it
 
         int i = SectionPos.blockToSectionCoord(player.getBlockX());
         int j = SectionPos.blockToSectionCoord(player.getBlockZ());
-        SectionPos sectionPos = player.getLastSectionPos();
-        SectionPos sectionPos2 = SectionPos.of(player);
-        long l = sectionPos.chunk().toLong();
-        long m = sectionPos2.chunk().toLong();
-        boolean bl = this.playerMap.ignored(player);
-        boolean bl2 = this.skipPlayer(player);
-        boolean bl3 = sectionPos.asLong() != sectionPos2.asLong();
-        if (bl3 || bl != bl2) {
+        SectionPos sectionposition = player.getLastSectionPos();
+        SectionPos sectionposition1 = SectionPos.of((Entity) player);
+        long k = sectionposition.chunk().toLong();
+        long l = sectionposition1.chunk().toLong();
+        boolean flag = this.playerMap.ignored(player);
+        boolean flag1 = this.skipPlayer(player);
+        boolean flag2 = sectionposition.asLong() != sectionposition1.asLong();
+
+        if (flag2 || flag != flag1) {
             this.updatePlayerPos(player);
-            if (!bl) {
-                this.distanceManager.removePlayer(sectionPos, player);
+            if (!flag) {
+                this.distanceManager.removePlayer(sectionposition, player);
             }
 
-            if (!bl2) {
-                this.distanceManager.addPlayer(sectionPos2, player);
+            if (!flag1) {
+                this.distanceManager.addPlayer(sectionposition1, player);
             }
 
-            if (!bl && bl2) {
+            if (!flag && flag1) {
                 this.playerMap.ignorePlayer(player);
             }
 
-            if (bl && !bl2) {
+            if (flag && !flag1) {
                 this.playerMap.unIgnorePlayer(player);
             }
 
-            if (l != m) {
-                this.playerMap.updatePlayer(l, m, player);
+            if (k != l) {
+                this.playerMap.updatePlayer(k, l, player);
             }
         }
 
-        int k = sectionPos.x();
-        int n = sectionPos.z();
-        if (Math.abs(k - i) <= this.viewDistance * 2 && Math.abs(n - j) <= this.viewDistance * 2) {
-            int o = Math.min(i, k) - this.viewDistance;
-            int p = Math.min(j, n) - this.viewDistance;
-            int q = Math.max(i, k) + this.viewDistance;
-            int r = Math.max(j, n) + this.viewDistance;
+        int i1 = sectionposition.x();
+        int j1 = sectionposition.z();
+        int k1;
+        int l1;
 
-            for(int s = o; s <= q; ++s) {
-                for(int t = p; t <= r; ++t) {
-                    ChunkPos chunkPos = new ChunkPos(s, t);
-                    boolean bl4 = checkerboardDistance(chunkPos, k, n) <= this.viewDistance;
-                    boolean bl5 = checkerboardDistance(chunkPos, i, j) <= this.viewDistance;
-                    this.updateChunkTracking(player, chunkPos, new Packet[2], bl4, bl5);
+        /* // Paper start - replaced by distance map
+        if (Math.abs(i1 - i) <= this.viewDistance * 2 && Math.abs(j1 - j) <= this.viewDistance * 2) {
+            k1 = Math.min(i, i1) - this.viewDistance;
+            l1 = Math.min(j, j1) - this.viewDistance;
+            int i2 = Math.max(i, i1) + this.viewDistance;
+            int j2 = Math.max(j, j1) + this.viewDistance;
+
+            for (int k2 = k1; k2 <= i2; ++k2) {
+                for (int l2 = l1; l2 <= j2; ++l2) {
+                    ChunkPos chunkcoordintpair = new ChunkPos(k2, l2);
+                    boolean flag3 = ChunkMap.checkerboardDistance(chunkcoordintpair, i1, j1) <= this.viewDistance;
+                    boolean flag4 = ChunkMap.checkerboardDistance(chunkcoordintpair, i, j) <= this.viewDistance;
+
+                    this.updateChunkTracking(player, chunkcoordintpair, new Packet[2], flag3, flag4);
                 }
             }
         } else {
-            for(int u = k - this.viewDistance; u <= k + this.viewDistance; ++u) {
-                for(int v = n - this.viewDistance; v <= n + this.viewDistance; ++v) {
-                    ChunkPos chunkPos2 = new ChunkPos(u, v);
-                    boolean bl6 = true;
-                    boolean bl7 = false;
-                    this.updateChunkTracking(player, chunkPos2, new Packet[2], true, false);
+            ChunkPos chunkcoordintpair1;
+            boolean flag5;
+            boolean flag6;
+
+            for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
+                for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
+                    chunkcoordintpair1 = new ChunkPos(k1, l1);
+                    flag5 = true;
+                    flag6 = false;
+                    this.updateChunkTracking(player, chunkcoordintpair1, new Packet[2], true, false);
                 }
             }
 
-            for(int w = i - this.viewDistance; w <= i + this.viewDistance; ++w) {
-                for(int x = j - this.viewDistance; x <= j + this.viewDistance; ++x) {
-                    ChunkPos chunkPos3 = new ChunkPos(w, x);
-                    boolean bl8 = false;
-                    boolean bl9 = true;
-                    this.updateChunkTracking(player, chunkPos3, new Packet[2], false, true);
+            for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
+                for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
+                    chunkcoordintpair1 = new ChunkPos(k1, l1);
+                    flag5 = false;
+                    flag6 = true;
+                    this.updateChunkTracking(player, chunkcoordintpair1, new Packet[2], false, true);
                 }
             }
         }
+        */ // Paper end - replaced by distance map
+
+        this.updateMaps(player); // Paper - distance maps
 
     }
 
+    @Override
     public Stream<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge) {
-        return this.playerMap.getPlayers(chunkPos.toLong()).filter((serverPlayer) -> {
-            int i = checkerboardDistance(chunkPos, serverPlayer, true);
-            if (i > this.viewDistance) {
-                return false;
-            } else {
-                return !onlyOnWatchDistanceEdge || i == this.viewDistance;
+        // Paper start - per player view distance
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> inRange = this.playerViewDistanceBroadcastMap.getObjectsInRange(chunkPos);
+
+        if (inRange == null) {
+            return Stream.empty();
+        }
+        // all current cases are inlined so we wont hit this code, it's just in case plugins or future updates use it
+        List<ServerPlayer> players = new java.util.ArrayList<>();
+        Object[] backingSet = inRange.getBackingSet();
+
+        if (onlyOnWatchDistanceEdge) { // flag -> border only
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof ServerPlayer)) {
+                    continue;
+                }
+                ServerPlayer player = (ServerPlayer)temp;
+                int viewDistance = this.playerViewDistanceBroadcastMap.getLastViewDistance(player);
+                long lastPosition = this.playerViewDistanceBroadcastMap.getLastCoordinate(player);
+
+                int distX = Math.abs(MCUtil.getCoordinateX(lastPosition) - chunkPos.x);
+                int distZ = Math.abs(MCUtil.getCoordinateZ(lastPosition) - chunkPos.z);
+                if (Math.max(distX, distZ) == viewDistance) {
+                    players.add(player);
+                }
             }
-        });
+        } else {
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof ServerPlayer)) {
+                    continue;
+                }
+                ServerPlayer player = (ServerPlayer)temp;
+                players.add(player);
+            }
+        }
+        return players.stream();
+        // Paper end - per player view distance
     }
 
-    protected void addEntity(Entity entity) {
+    public void addEntity(Entity entity) {
+        org.spigotmc.AsyncCatcher.catchOp("entity track"); // Spigot
+        // Paper start - ignore and warn about illegal addEntity calls instead of crashing server
+        if (!entity.valid || entity.level != this.level || this.entityMap.containsKey(entity.getId())) {
+            new Throwable("[ERROR] Illegal PlayerChunkMap::addEntity for world " + this.level.getWorld().getName()
+                + ": " + entity  + (this.entityMap.containsKey(entity.getId()) ? " ALREADY CONTAINED (This would have crashed your server)" : ""))
+                .printStackTrace();
+            return;
+        }
+        if (entity instanceof ServerPlayer && ((ServerPlayer) entity).supressTrackerForLogin) return; // Delay adding to tracker until after list packets
+        // Paper end
         if (!(entity instanceof EnderDragonPart)) {
-            EntityType<?> entityType = entity.getType();
-            int i = entityType.clientTrackingRange() * 16;
+            EntityType<?> entitytypes = entity.getType();
+            int i = entitytypes.clientTrackingRange() * 16;
+            i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
+
             if (i != 0) {
-                int j = entityType.updateInterval();
+                int j = entitytypes.updateInterval();
+
                 if (this.entityMap.containsKey(entity.getId())) {
-                    throw (IllegalStateException)Util.pauseInIde(new IllegalStateException("Entity is already tracked!"));
+                    throw (IllegalStateException) Util.pauseInIde((Throwable) (new IllegalStateException("Entity is already tracked!")));
                 } else {
-                    ChunkMap.TrackedEntity trackedEntity = new ChunkMap.TrackedEntity(entity, i, j, entityType.trackDeltas());
-                    this.entityMap.put(entity.getId(), trackedEntity);
-                    trackedEntity.updatePlayers(this.level.players());
+                    ChunkMap.TrackedEntity playerchunkmap_entitytracker = new ChunkMap.TrackedEntity(entity, i, j, entitytypes.trackDeltas());
+
+                    entity.tracker = playerchunkmap_entitytracker; // Paper - Fast access to tracker
+                    this.entityMap.put(entity.getId(), playerchunkmap_entitytracker);
+                    playerchunkmap_entitytracker.updatePlayers(entity.getPlayersInTrackRange()); // Paper - don't search all players
                     if (entity instanceof ServerPlayer) {
-                        ServerPlayer serverPlayer = (ServerPlayer)entity;
-                        this.updatePlayerStatus(serverPlayer, true);
+                        ServerPlayer entityplayer = (ServerPlayer) entity;
 
-                        for(ChunkMap.TrackedEntity trackedEntity2 : this.entityMap.values()) {
-                            if (trackedEntity2.entity != serverPlayer) {
-                                trackedEntity2.updatePlayer(serverPlayer);
+                        this.updatePlayerStatus(entityplayer, true);
+                        ObjectIterator objectiterator = this.entityMap.values().iterator();
+
+                        while (objectiterator.hasNext()) {
+                            ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = (ChunkMap.TrackedEntity) objectiterator.next();
+
+                            if (playerchunkmap_entitytracker1.entity != entityplayer) {
+                                playerchunkmap_entitytracker1.updatePlayer(entityplayer);
                             }
                         }
                     }
@@ -949,105 +2022,217 @@
     }
 
     protected void removeEntity(Entity entity) {
+        org.spigotmc.AsyncCatcher.catchOp("entity untrack"); // Spigot
         if (entity instanceof ServerPlayer) {
-            ServerPlayer serverPlayer = (ServerPlayer)entity;
-            this.updatePlayerStatus(serverPlayer, false);
+            ServerPlayer entityplayer = (ServerPlayer) entity;
 
-            for(ChunkMap.TrackedEntity trackedEntity : this.entityMap.values()) {
-                trackedEntity.removePlayer(serverPlayer);
+            this.updatePlayerStatus(entityplayer, false);
+            ObjectIterator objectiterator = this.entityMap.values().iterator();
+
+            while (objectiterator.hasNext()) {
+                ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
+
+                playerchunkmap_entitytracker.removePlayer(entityplayer);
             }
         }
 
-        ChunkMap.TrackedEntity trackedEntity2 = this.entityMap.remove(entity.getId());
-        if (trackedEntity2 != null) {
-            trackedEntity2.broadcastRemoved();
+        ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = (ChunkMap.TrackedEntity) this.entityMap.remove(entity.getId());
+
+        if (playerchunkmap_entitytracker1 != null) {
+            playerchunkmap_entitytracker1.broadcastRemoved();
+        }
+        entity.tracker = null; // Paper - We're no longer tracked
+    }
+
+    // Paper start - optimised tracker
+    private final void processTrackQueue() {
+        this.level.timings.tracker1.startTiming();
+        try {
+            for (TrackedEntity tracker : this.entityMap.values()) {
+                // update tracker entry
+                tracker.updatePlayers(tracker.entity.getPlayersInTrackRange());
+            }
+        } finally {
+            this.level.timings.tracker1.stopTiming();
         }
 
+
+        this.level.timings.tracker2.startTiming();
+        try {
+            for (TrackedEntity tracker : this.entityMap.values()) {
+                tracker.serverEntity.sendChanges();
+            }
+        } finally {
+            this.level.timings.tracker2.stopTiming();
+        }
     }
+    // Paper end - optimised tracker
 
     protected void tick() {
+        // Paper start - optimized tracker
+        if (true) {
+            this.processTrackQueue();
+            return;
+        }
+        // Paper end - optimized tracker
         List<ServerPlayer> list = Lists.newArrayList();
-        List<ServerPlayer> list2 = this.level.players();
+        List<ServerPlayer> list1 = this.level.players();
+
+        ChunkMap.TrackedEntity playerchunkmap_entitytracker;
+        ObjectIterator objectiterator;
+        level.timings.tracker1.startTiming(); // Paper
+
+        for (objectiterator = this.entityMap.values().iterator(); objectiterator.hasNext(); playerchunkmap_entitytracker.serverEntity.sendChanges()) {
+            playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
+            SectionPos sectionposition = playerchunkmap_entitytracker.lastSectionPos;
+            SectionPos sectionposition1 = SectionPos.of(playerchunkmap_entitytracker.entity);
+
+            if (!Objects.equals(sectionposition, sectionposition1)) {
+                playerchunkmap_entitytracker.updatePlayers(list1);
+                Entity entity = playerchunkmap_entitytracker.entity;
 
-        for(ChunkMap.TrackedEntity trackedEntity : this.entityMap.values()) {
-            SectionPos sectionPos = trackedEntity.lastSectionPos;
-            SectionPos sectionPos2 = SectionPos.of(trackedEntity.entity);
-            if (!Objects.equals(sectionPos, sectionPos2)) {
-                trackedEntity.updatePlayers(list2);
-                Entity entity = trackedEntity.entity;
                 if (entity instanceof ServerPlayer) {
-                    list.add((ServerPlayer)entity);
+                    list.add((ServerPlayer) entity);
                 }
 
-                trackedEntity.lastSectionPos = sectionPos2;
+                playerchunkmap_entitytracker.lastSectionPos = sectionposition1;
             }
-
-            trackedEntity.serverEntity.sendChanges();
         }
+        level.timings.tracker1.stopTiming(); // Paper
 
         if (!list.isEmpty()) {
-            for(ChunkMap.TrackedEntity trackedEntity2 : this.entityMap.values()) {
-                trackedEntity2.updatePlayers(list);
+            objectiterator = this.entityMap.values().iterator();
+
+            level.timings.tracker2.startTiming(); // Paper
+            while (objectiterator.hasNext()) {
+                playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
+                playerchunkmap_entitytracker.updatePlayers(list);
             }
+            level.timings.tracker2.stopTiming(); // Paper
         }
 
+
     }
 
     public void broadcast(Entity entity, Packet<?> packet) {
-        ChunkMap.TrackedEntity trackedEntity = this.entityMap.get(entity.getId());
-        if (trackedEntity != null) {
-            trackedEntity.broadcast(packet);
+        ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) this.entityMap.get(entity.getId());
+
+        if (playerchunkmap_entitytracker != null) {
+            playerchunkmap_entitytracker.broadcast(packet);
         }
 
     }
 
     protected void broadcastAndSend(Entity entity, Packet<?> packet) {
-        ChunkMap.TrackedEntity trackedEntity = this.entityMap.get(entity.getId());
-        if (trackedEntity != null) {
-            trackedEntity.broadcastAndSend(packet);
+        ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) this.entityMap.get(entity.getId());
+
+        if (playerchunkmap_entitytracker != null) {
+            playerchunkmap_entitytracker.broadcastAndSend(packet);
         }
 
     }
 
-    private void playerLoadedChunk(ServerPlayer player, Packet<?>[] packets, LevelChunk chunk) {
+    // Paper start
+    private static int getLightMask(final LevelChunk chunk) {
+        final net.minecraft.world.level.chunk.LevelChunkSection[] chunkSections = chunk.getSections();
+        int mask = 0;
+
+        for (int i = 0; i < chunkSections.length; ++i) {
+            /*
+
+
+Lightmasks have 18 bits, from the -1 (void) section until the 17th (air) section.
+Sections go from 0..16. Now whenever a section is not empty, it can potentially change lighting for the section itself, the section below and the section above, hence the bitmask 111b, which is 7d.
+
+             */
+            mask |= (net.minecraft.world.level.chunk.LevelChunkSection.isEmpty(chunkSections[i]) ? 0 : 7) << i;
+        }
+
+        return mask;
+    }
+
+    private static int getCeilingLightMask(final LevelChunk chunk) {
+        int mask = getLightMask(chunk);
+
+        /*
+         It is similar to get highest bit, it would turn an 001010 into an 001111 so basically the highest bit and all below.
+         We then invert this, so we'd have 110000 and compare that to the "main" chunk.
+         This is because the bug only appears when the current chunks lightmaps are higher than those of the neighbors, thus we can omit sending neighbors which are lower than the current chunks lights.
+
+         so TLDR is that getCeilingLightMask returns a light mask with all bits set below the highest affected section. We could also count the number of leading zeros and invert them, somehow.
+         @TODO: Implement Leafs suggestion
+         either use Integer#numberOfLeadingZeros or document what this bithack is supposed to be doing then
+         */
+        mask |= mask >> 1;
+        mask |= mask >> 2;
+        mask |= mask >> 4;
+        mask |= mask >> 8;
+        mask |= mask >> 16;
+
+        return mask;
+    }
+    // Paper end
+
+    public void playerLoadedChunk(ServerPlayer player, Packet<?>[] packets, LevelChunk chunk) {
         if (packets[0] == null) {
-            packets[0] = new ClientboundLevelChunkPacket(chunk);
-            packets[1] = new ClientboundLightUpdatePacket(chunk.getPos(), this.lightEngine, (BitSet)null, (BitSet)null, true);
+            packets[0] = new ClientboundLevelChunkPacket(chunk, chunk.level.chunkPacketBlockController.shouldModify(player, chunk)); // Paper - Ani-Xray - Bypass
+            packets[1] = new ClientboundLightUpdatePacket(chunk.getPos(), this.lightEngine, (BitSet) null, (BitSet) null, true);
         }
 
         player.trackChunk(chunk.getPos(), packets[0], packets[1]);
         DebugPackets.sendPoiPacketsForChunk(this.level, chunk.getPos());
         List<Entity> list = Lists.newArrayList();
-        List<Entity> list2 = Lists.newArrayList();
+        List<Entity> list1 = Lists.newArrayList();
+        // Paper start - optimise entity tracker
+        // use the chunk entity list, not the whole trackedEntities map...
+        Entity[] entities = chunk.entities.getRawData();
+        for (int i = 0, size = chunk.entities.size(); i < size; ++i) {
+            Entity entity = entities[i];
+            if (entity == player) {
+                continue;
+            }
+            ChunkMap.TrackedEntity tracker = this.entityMap.get(entity.getId());
+            if (tracker != null) { // dumb plugins... move on...
+                tracker.updatePlayer(player);
+            }
 
-        for(ChunkMap.TrackedEntity trackedEntity : this.entityMap.values()) {
-            Entity entity = trackedEntity.entity;
-            if (entity != player && entity.chunkPosition().equals(chunk.getPos())) {
-                trackedEntity.updatePlayer(player);
-                if (entity instanceof Mob && ((Mob)entity).getLeashHolder() != null) {
-                    list.add(entity);
-                }
+            // keep the vanilla logic here - this is REQUIRED or else passengers and their vehicles disappear!
+            // (and god knows what the leash thing is)
 
-                if (!entity.getPassengers().isEmpty()) {
-                    list2.add(entity);
-                }
+            if (entity instanceof Mob && ((Mob)entity).getLeashHolder() != null) {
+                list.add(entity);
+            }
+
+            if (!entity.getPassengers().isEmpty()) {
+                list1.add(entity);
             }
         }
+        // Paper end - optimise entity tracker
+
+        Iterator iterator;
+        Entity entity1;
 
         if (!list.isEmpty()) {
-            for(Entity entity2 : list) {
-                player.connection.send(new ClientboundSetEntityLinkPacket(entity2, ((Mob)entity2).getLeashHolder()));
+            iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                entity1 = (Entity) iterator.next();
+                player.connection.send(new ClientboundSetEntityLinkPacket(entity1, ((Mob) entity1).getLeashHolder()));
             }
         }
 
-        if (!list2.isEmpty()) {
-            for(Entity entity3 : list2) {
-                player.connection.send(new ClientboundSetPassengersPacket(entity3));
+        if (!list1.isEmpty()) {
+            iterator = list1.iterator();
+
+            while (iterator.hasNext()) {
+                entity1 = (Entity) iterator.next();
+                player.connection.send(new ClientboundSetPassengersPacket(entity1));
             }
         }
 
     }
 
+    @Deprecated public PoiManager getVillagePlace() { return this.getPoiManager(); } // Paper - OBFHELPER
     protected PoiManager getPoiManager() {
         return this.poiManager;
     }
@@ -1062,59 +2247,100 @@
         });
     }
 
-    void onFullChunkStatusChange(ChunkPos chunkPos, ChunkHolder.FullChunkStatus fullChunkStatus) {
-        this.chunkStatusListener.onChunkStatusChange(chunkPos, fullChunkStatus);
+    void onFullChunkStatusChange(ChunkPos chunkcoordintpair, ChunkHolder.FullChunkStatus playerchunk_state) {
+        this.chunkStatusListener.onChunkStatusChange(chunkcoordintpair, playerchunk_state);
     }
 
-    class DistanceManager extends net.minecraft.server.level.DistanceManager {
-        protected DistanceManager(Executor mainThreadExecutor, Executor executor) {
-            super(mainThreadExecutor, executor);
+    public class ChunkDistanceManager extends DistanceManager {
+
+        protected ChunkDistanceManager(Executor workerExecutor, Executor mainThreadExecutor) {
+            super(workerExecutor, mainThreadExecutor);
         }
 
+        @Override
         protected boolean isChunkToRemove(long pos) {
             return ChunkMap.this.toDrop.contains(pos);
         }
 
         @Nullable
+        @Override
         protected ChunkHolder getChunk(long pos) {
             return ChunkMap.this.getUpdatingChunkIfPresent(pos);
         }
 
         @Nullable
-        protected ChunkHolder updateChunkScheduling(long pos, int level, @Nullable ChunkHolder holder, int i) {
-            return ChunkMap.this.updateChunkScheduling(pos, level, holder, i);
+        @Override
+        protected ChunkHolder updateChunkScheduling(long pos, int level, @Nullable ChunkHolder holder, int k) {
+            return ChunkMap.this.updateChunkScheduling(pos, level, holder, k);
         }
     }
 
-    class TrackedEntity {
+    public class TrackedEntity {
+
         final ServerEntity serverEntity;
         final Entity entity;
         private final int range;
         SectionPos lastSectionPos;
-        private final Set<ServerPlayerConnection> seenBy = Sets.newIdentityHashSet();
+        public final Set<ServerPlayerConnection> seenBy = Sets.newIdentityHashSet();
 
-        public TrackedEntity(Entity entity, int maxDistance, int tickInterval, boolean alwaysUpdateVelocity) {
-            this.serverEntity = new ServerEntity(ChunkMap.this.level, entity, tickInterval, alwaysUpdateVelocity, this::broadcast);
+        public TrackedEntity(Entity entity, int i, int j, boolean flag) {
+            this.serverEntity = new ServerEntity(ChunkMap.this.level, entity, j, flag, this::broadcast, this.seenBy); // CraftBukkit
             this.entity = entity;
-            this.range = maxDistance;
+            this.range = i;
             this.lastSectionPos = SectionPos.of(entity);
         }
 
-        public boolean equals(Object object) {
-            if (object instanceof ChunkMap.TrackedEntity) {
-                return ((ChunkMap.TrackedEntity)object).entity.getId() == this.entity.getId();
-            } else {
-                return false;
+        // Paper start - use distance map to optimise tracker
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> lastTrackerCandidates;
+
+        final void updatePlayers(com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newTrackerCandidates) {
+            com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> oldTrackerCandidates = this.lastTrackerCandidates;
+            this.lastTrackerCandidates = newTrackerCandidates;
+
+            if (newTrackerCandidates != null) {
+                Object[] rawData = newTrackerCandidates.getBackingSet();
+                for (int i = 0, len = rawData.length; i < len; ++i) {
+                    Object raw = rawData[i];
+                    if (!(raw instanceof ServerPlayer)) {
+                        continue;
+                    }
+                    ServerPlayer player = (ServerPlayer)raw;
+                    this.updatePlayer(player);
+                }
+            }
+
+            if (oldTrackerCandidates == newTrackerCandidates) {
+                // this is likely the case.
+                // means there has been no range changes, so we can just use the above for tracking.
+                return;
+            }
+
+            // stuff could have been removed, so we need to check the trackedPlayers set
+            // for players that were removed
+
+            for (ServerPlayerConnection conn : this.seenBy.toArray(new ServerPlayerConnection[0])) { // avoid CME
+                if (newTrackerCandidates == null || !newTrackerCandidates.contains(conn)) {
+                    this.updatePlayer(conn.getPlayer());
+                }
             }
         }
+        // Paper end - use distance map to optimise tracker
+
+        public boolean equals(Object object) {
+            return object instanceof ChunkMap.TrackedEntity ? ((ChunkMap.TrackedEntity) object).entity.getId() == this.entity.getId() : false;
+        }
 
         public int hashCode() {
             return this.entity.getId();
         }
 
         public void broadcast(Packet<?> packet) {
-            for(ServerPlayerConnection serverPlayerConnection : this.seenBy) {
-                serverPlayerConnection.send(packet);
+            Iterator iterator = this.seenBy.iterator();
+
+            while (iterator.hasNext()) {
+                ServerPlayerConnection serverplayerconnection = (ServerPlayerConnection) iterator.next();
+
+                serverplayerconnection.send(packet);
             }
 
         }
@@ -1122,19 +2348,24 @@
         public void broadcastAndSend(Packet<?> packet) {
             this.broadcast(packet);
             if (this.entity instanceof ServerPlayer) {
-                ((ServerPlayer)this.entity).connection.send(packet);
+                ((ServerPlayer) this.entity).connection.send(packet);
             }
 
         }
 
         public void broadcastRemoved() {
-            for(ServerPlayerConnection serverPlayerConnection : this.seenBy) {
-                this.serverEntity.removePairing(serverPlayerConnection.getPlayer());
+            Iterator iterator = this.seenBy.iterator();
+
+            while (iterator.hasNext()) {
+                ServerPlayerConnection serverplayerconnection = (ServerPlayerConnection) iterator.next();
+
+                this.serverEntity.removePairing(serverplayerconnection.getPlayer());
             }
 
         }
 
         public void removePlayer(ServerPlayer player) {
+            org.spigotmc.AsyncCatcher.catchOp("player tracker clear"); // Spigot
             if (this.seenBy.remove(player.connection)) {
                 this.serverEntity.removePairing(player);
             }
@@ -1142,11 +2373,26 @@
         }
 
         public void updatePlayer(ServerPlayer player) {
+            org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
             if (player != this.entity) {
-                Vec3 vec3 = player.position().subtract(this.serverEntity.sentPos());
+                // Paper start - remove allocation of Vec3D here
+                //Vec3D vec3d = entityplayer.getPositionVector().d(this.tracker.getPositionVector()); // MC-155077, SPIGOT-5113
+                double vec3d_dx = player.getX() - this.entity.getX();
+                double vec3d_dy = player.getY() - this.entity.getY();
+                double vec3d_dz = player.getZ() - this.entity.getZ();
+                // Paper end - remove allocation of Vec3D here
                 int i = Math.min(this.getEffectiveRange(), (ChunkMap.this.viewDistance - 1) * 16);
-                boolean bl = vec3.x >= (double)(-i) && vec3.x <= (double)i && vec3.z >= (double)(-i) && vec3.z <= (double)i && this.entity.broadcastToPlayer(player);
-                if (bl) {
+                boolean flag = vec3d_dx >= (double) (-i) && vec3d_dx <= (double) i && vec3d_dz >= (double) (-i) && vec3d_dz <= (double) i && this.entity.broadcastToPlayer(player); // Paper - remove allocation of Vec3D here
+
+                // CraftBukkit start - respect vanish API
+                if (this.entity instanceof ServerPlayer) {
+                    Player player1 = ((ServerPlayer) this.entity).getBukkitEntity();
+                    if (!player.getBukkitEntity().canSee(player1)) {
+                        flag = false;
+                    }
+                }
+                // CraftBukkit end
+                if (flag) {
                     if (this.seenBy.add(player.connection)) {
                         this.serverEntity.addPairing(player);
                     }
@@ -1163,10 +2409,14 @@
 
         private int getEffectiveRange() {
             int i = this.range;
+            Iterator iterator = this.entity.getIndirectPassengers().iterator();
 
-            for(Entity entity : this.entity.getIndirectPassengers()) {
+            while (iterator.hasNext()) {
+                Entity entity = (Entity) iterator.next();
                 int j = entity.getType().clientTrackingRange() * 16;
-                if (j > i) {
+                j = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, j); // Paper
+
+                if (j < i) { // Paper - we need the lowest range thanks to the fact that our tracker doesn't account for passenger logic
                     i = j;
                 }
             }
@@ -1175,8 +2425,12 @@
         }
 
         public void updatePlayers(List<ServerPlayer> players) {
-            for(ServerPlayer serverPlayer : players) {
-                this.updatePlayer(serverPlayer);
+            Iterator iterator = players.iterator();
+
+            while (iterator.hasNext()) {
+                ServerPlayer entityplayer = (ServerPlayer) iterator.next();
+
+                this.updatePlayer(entityplayer);
             }
 
         }
