--- a/net/minecraft/network/protocol/game/ClientboundLevelChunkPacket.java
+++ b/net/minecraft/network/protocol/game/ClientboundLevelChunkPacket.java
@@ -27,8 +27,34 @@
     private final int[] biomes;
     private final byte[] buffer;
     private final List<CompoundTag> blockEntitiesTags;
+    // Paper start
+    private final java.util.List<Packet> extraPackets = new java.util.ArrayList<>();
+    private static final int TE_LIMIT = Integer.getInteger("Paper.excessiveTELimit", 750);
 
-    public ClientboundLevelChunkPacket(LevelChunk chunk) {
+    @Override
+    public java.util.List<Packet> getExtraPackets() {
+        return extraPackets;
+    }
+    // Paper end
+
+    // Paper start - Async-Anti-Xray - Ready flag for the connection
+    private volatile boolean ready;
+
+    @Override
+    public boolean isReady() {
+        return this.ready;
+    }
+
+    public void setReady(boolean ready) {
+        this.ready = ready;
+    }
+    // Paper end
+
+    // Paper start - Anti-Xray - Add chunk packet info
+    @Deprecated public ClientboundLevelChunkPacket(LevelChunk chunk) { this(chunk, true); } // Notice for updates: Please make sure this constructor isn't used anywhere
+    public ClientboundLevelChunkPacket(LevelChunk chunk, boolean modifyBlocks) {
+        com.destroystokyo.paper.antixray.ChunkPacketInfo<net.minecraft.world.level.block.state.BlockState> chunkPacketInfo = modifyBlocks ? chunk.level.chunkPacketBlockController.getChunkPacketInfo(this, chunk) : null;
+        // Paper end
         ChunkPos chunkPos = chunk.getPos();
         this.x = chunkPos.x;
         this.z = chunkPos.z;
@@ -42,15 +68,34 @@
 
         this.biomes = chunk.getBiomes().writeBiomes();
         this.buffer = new byte[this.calculateChunkSize(chunk)];
-        this.availableSections = this.extractChunkData(new FriendlyByteBuf(this.getWriteBuffer()), chunk);
+
+        // Paper start - Anti-Xray - Add chunk packet info
+        if (chunkPacketInfo != null) {
+            chunkPacketInfo.setBuffer(this.buffer);
+        }
+
+        this.availableSections = this.extractChunkData(new FriendlyByteBuf(this.getWriteBuffer()), chunk, chunkPacketInfo);
+        // Paper end
         this.blockEntitiesTags = Lists.newArrayList();
+        int totalTileEntities = 0; // Paper
 
         for(Entry<BlockPos, BlockEntity> entry2 : chunk.getBlockEntities().entrySet()) {
             BlockEntity blockEntity = entry2.getValue();
+            // Paper start - improve oversized chunk data packet handling
+            if (++totalTileEntities > TE_LIMIT) {
+                ClientboundBlockEntityDataPacket updatePacket = blockEntity.getUpdatePacket();
+                if (updatePacket != null) {
+                    this.extraPackets.add(updatePacket);
+                    continue;
+                }
+            }
+            // Paper end
             CompoundTag compoundTag = blockEntity.getUpdateTag();
+            if (blockEntity instanceof net.minecraft.world.level.block.entity.SkullBlockEntity) { net.minecraft.world.level.block.entity.SkullBlockEntity.sanitizeTileEntityUUID(compoundTag); } // Paper
             this.blockEntitiesTags.add(compoundTag);
         }
 
+        chunk.level.chunkPacketBlockController.modifyBlocks(this, chunkPacketInfo); // Paper - Anti-Xray - Modify blocks
     }
 
     public ClientboundLevelChunkPacket(FriendlyByteBuf buf) {
@@ -63,7 +108,7 @@
         } else {
             this.biomes = buf.readVarIntArray(ChunkBiomeContainer.MAX_SIZE);
             int i = buf.readVarInt();
-            if (i > 2097152) {
+            if (i > 2097152) { // Paper - diff on change - if this changes, update PacketEncoder
                 throw new RuntimeException("Chunk Packet trying to allocate too much memory on read.");
             } else {
                 this.buffer = new byte[i];
@@ -73,6 +118,7 @@
         }
     }
 
+    @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeInt(this.x);
         buf.writeInt(this.z);
@@ -84,6 +130,7 @@
         buf.writeCollection(this.blockEntitiesTags, FriendlyByteBuf::writeNbt);
     }
 
+    @Override
     public void handle(ClientGamePacketListener listener) {
         listener.handleLevelChunk(this);
     }
@@ -98,7 +145,10 @@
         return byteBuf;
     }
 
-    public BitSet extractChunkData(FriendlyByteBuf buf, LevelChunk chunk) {
+    // Paper start - Anti-Xray - Add chunk packet info
+    @Deprecated public BitSet extractChunkData(FriendlyByteBuf buf, LevelChunk chunk) { return extractChunkData(buf, chunk, null); } // Notice for updates: Please make sure this method isn't used anywhere
+    public BitSet extractChunkData(FriendlyByteBuf buf, LevelChunk chunk, com.destroystokyo.paper.antixray.ChunkPacketInfo<net.minecraft.world.level.block.state.BlockState> chunkPacketInfo) {
+        // Paper end
         BitSet bitSet = new BitSet();
         LevelChunkSection[] levelChunkSections = chunk.getSections();
         int i = 0;
@@ -107,7 +157,7 @@
             LevelChunkSection levelChunkSection = levelChunkSections[i];
             if (levelChunkSection != LevelChunk.EMPTY_SECTION && !levelChunkSection.isEmpty()) {
                 bitSet.set(i);
-                levelChunkSection.write(buf);
+                levelChunkSection.write(buf, chunkPacketInfo); // Paper - Anti-Xray - Add chunk packet info
             }
         }
 
