--- a/net/minecraft/server/level/ChunkHolder.java
+++ b/net/minecraft/server/level/ChunkHolder.java
@@ -5,6 +5,7 @@
 import it.unimi.dsi.fastutil.shorts.ShortSet;
 import java.util.BitSet;
 import java.util.List;
+import java.util.Objects;
 import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
@@ -36,39 +37,229 @@
 import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.chunk.ProtoChunk;
 import net.minecraft.world.level.lighting.LevelLightEngine;
+// CraftBukkit start
+import net.minecraft.server.MinecraftServer;
+// CraftBukkit end
 
 public class ChunkHolder {
+
     public static final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> UNLOADED_CHUNK = Either.right(ChunkHolder.ChunkLoadingFailure.UNLOADED);
-    public static final CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> UNLOADED_CHUNK_FUTURE = CompletableFuture.completedFuture(UNLOADED_CHUNK);
+    public static final CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> UNLOADED_CHUNK_FUTURE = CompletableFuture.completedFuture(ChunkHolder.UNLOADED_CHUNK);
     public static final Either<LevelChunk, ChunkHolder.ChunkLoadingFailure> UNLOADED_LEVEL_CHUNK = Either.right(ChunkHolder.ChunkLoadingFailure.UNLOADED);
-    private static final CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> UNLOADED_LEVEL_CHUNK_FUTURE = CompletableFuture.completedFuture(UNLOADED_LEVEL_CHUNK);
+    private static final CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> UNLOADED_LEVEL_CHUNK_FUTURE = CompletableFuture.completedFuture(ChunkHolder.UNLOADED_LEVEL_CHUNK);
     private static final List<ChunkStatus> CHUNK_STATUSES = ChunkStatus.getStatusList();
     private static final ChunkHolder.FullChunkStatus[] FULL_CHUNK_STATUSES = ChunkHolder.FullChunkStatus.values();
     private static final int BLOCKS_BEFORE_RESEND_FUDGE = 64;
-    private final AtomicReferenceArray<CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> futures = new AtomicReferenceArray<>(CHUNK_STATUSES.size());
+    private final AtomicReferenceArray<CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> futures;
     private final LevelHeightAccessor levelHeightAccessor;
-    private volatile CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> fullChunkFuture = UNLOADED_LEVEL_CHUNK_FUTURE;
-    private volatile CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> tickingChunkFuture = UNLOADED_LEVEL_CHUNK_FUTURE;
-    private volatile CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> entityTickingChunkFuture = UNLOADED_LEVEL_CHUNK_FUTURE;
-    private CompletableFuture<ChunkAccess> chunkToSave = CompletableFuture.completedFuture((ChunkAccess)null);
+    private volatile CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> fullChunkFuture; private int fullChunkCreateCount; private volatile boolean isFullChunkReady; // Paper - cache chunk ticking stage
+    private volatile CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> tickingChunkFuture; private volatile boolean isTickingReady; // Paper - cache chunk ticking stage
+    private volatile CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> entityTickingChunkFuture; private volatile boolean isEntityTickingReady; // Paper - cache chunk ticking stage
+    private CompletableFuture<ChunkAccess> chunkToSave;
     @Nullable
-    private final DebugBuffer<ChunkHolder.ChunkSaveDebug> chunkToSaveHistory = null;
-    private int oldTicketLevel;
+    private final DebugBuffer<ChunkHolder.ChunkSaveDebug> chunkToSaveHistory;
+    public int oldTicketLevel;
     private int ticketLevel;
-    private int queueLevel;
-    final ChunkPos pos;
+    public volatile int queueLevel; // Paper - private->public, make volatile since this is concurrently accessed
+    public final ChunkPos pos;
     private boolean hasChangedSections;
     private final ShortSet[] changedBlocksPerSection;
-    private final BitSet blockChangedLightSectionFilter = new BitSet();
-    private final BitSet skyChangedLightSectionFilter = new BitSet();
+    private final BitSet blockChangedLightSectionFilter;
+    private final BitSet skyChangedLightSectionFilter;
     private final LevelLightEngine lightEngine;
     private final ChunkHolder.LevelChangeListener onLevelChange;
-    private final ChunkHolder.PlayerProvider playerProvider;
+    public final ChunkHolder.PlayerProvider playerProvider;
     private boolean wasAccessibleSinceLastSave;
     private boolean resendLight;
-    private CompletableFuture<Void> pendingFullStateConfirmation = CompletableFuture.completedFuture((Void)null);
+    private CompletableFuture<Void> pendingFullStateConfirmation;
+
+    boolean isUpdateQueued = false; // Paper
+    private final ChunkMap chunkMap; // Paper
+    public ServerLevel getWorld() { return chunkMap.level; } // Paper
+    // Paper start - no-tick view distance
+    public final LevelChunk getSendingChunk() {
+        // it's important that we use getChunkAtIfLoadedImmediately to mirror the chunk sending logic used
+        // in Chunk's neighbour callback
+        LevelChunk ret = this.chunkMap.level.getChunkSource().getChunkAtIfLoadedImmediately(this.pos.x, this.pos.z);
+        if (ret != null && ret.areNeighboursLoaded(1)) {
+            return ret;
+        }
+        return null;
+    }
+    // Paper end - no-tick view distance
+    // Paper start
+    public final boolean isEntityTickingReady() {
+        return this.isEntityTickingReady;
+    }
+
+    public final boolean isTickingReady() {
+        return this.isTickingReady;
+    }
+
+    public final boolean isFullChunkReady() {
+        return this.isFullChunkReady;
+    }
+    // Paper end
+
+    // Paper start - Chunk gen/load priority system
+    volatile int neighborPriority = -1;
+    volatile int priorityBoost = 0;
+    public final java.util.concurrent.ConcurrentHashMap<ChunkHolder, ChunkStatus> neighbors = new java.util.concurrent.ConcurrentHashMap<>();
+    public final it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<Integer> neighborPriorities = new it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<>();
+
+    private int getDemandedPriority() {
+        int priority = neighborPriority; // if we have a neighbor priority, use it
+        int myPriority = getMyPriority();
+
+        if (priority == -1 || (ticketLevel <= 33 && priority > myPriority)) {
+            priority = myPriority;
+        }
+
+        return Math.max(1, Math.min(Math.max(ticketLevel, ChunkMap.MAX_CHUNK_DISTANCE), priority));
+    }
+
+    private int getMyPriority() {
+        if (priorityBoost == DistanceManager.URGENT_PRIORITY) {
+            return 2; // Urgent - ticket level isn't always 31 so 33-30 = 3, but allow 1 more tasks to go below this for dependents
+        }
+        return ticketLevel - priorityBoost;
+    }
+
+    private int getNeighborsPriority() {
+        return (neighborPriorities.isEmpty() ? getMyPriority() : getDemandedPriority()) + 1;
+    }
+
+    public void onNeighborRequest(ChunkHolder neighbor, ChunkStatus status) {
+        neighbor.setNeighborPriority(this, getNeighborsPriority());
+        this.neighbors.compute(neighbor, (playerChunk, currentWantedStatus) -> {
+            if (currentWantedStatus == null || !currentWantedStatus.isOrAfter(status)) {
+                //System.out.println(this + " request " + neighbor + " at " + status + " currently " + currentWantedStatus);
+                return status;
+            } else {
+                //System.out.println(this + " requested " + neighbor + " at " + status + " but thats lower than other wanted status " + currentWantedStatus);
+                return currentWantedStatus;
+            }
+        });
+
+    }
+
+    public void onNeighborDone(ChunkHolder neighbor, ChunkStatus chunkstatus, ChunkAccess chunk) {
+        this.neighbors.compute(neighbor, (playerChunk, wantedStatus) -> {
+            if (wantedStatus != null && chunkstatus.isOrAfter(wantedStatus)) {
+                //System.out.println(this + " neighbor done at " + neighbor + " for status " + chunkstatus + " wanted " + wantedStatus);
+                neighbor.removeNeighborPriority(this);
+                return null;
+            } else {
+                //System.out.println(this + " neighbor finished our previous request at " + neighbor + " for status " + chunkstatus + " but we now want instead " + wantedStatus);
+                return wantedStatus;
+            }
+        });
+    }
+
+    private void removeNeighborPriority(ChunkHolder requester) {
+        synchronized (neighborPriorities) {
+            neighborPriorities.remove(requester.pos.toLong());
+            recalcNeighborPriority();
+        }
+        checkPriority();
+    }
+
+
+    private void setNeighborPriority(ChunkHolder requester, int priority) {
+        synchronized (neighborPriorities) {
+            neighborPriorities.put(requester.pos.toLong(), Integer.valueOf(priority));
+            recalcNeighborPriority();
+        }
+        checkPriority();
+    }
+
+    private void recalcNeighborPriority() {
+        neighborPriority = -1;
+        if (!neighborPriorities.isEmpty()) {
+            synchronized (neighborPriorities) {
+                for (Integer neighbor : neighborPriorities.values()) {
+                    if (neighbor < neighborPriority || neighborPriority == -1) {
+                        neighborPriority = neighbor;
+                    }
+                }
+            }
+        }
+    }
+    private void checkPriority() {
+        if (queueLevel != getDemandedPriority()) this.chunkMap.queueHolderUpdate(this);
+    }
+
+    public final double getDistance(ServerPlayer player) {
+        return getDistance(player.getX(), player.getZ());
+    }
+    public final double getDistance(double blockX, double blockZ) {
+        int cx = net.minecraft.server.MCUtil.fastFloor(blockX) >> 4;
+        int cz = net.minecraft.server.MCUtil.fastFloor(blockZ) >> 4;
+        final double x = pos.x - cx;
+        final double z = pos.z - cz;
+        return (x * x) + (z * z);
+    }
+
+    public final double getDistanceFrom(BlockPos pos) {
+        return getDistance(pos.getX(), pos.getZ());
+    }
+
+    public static ChunkStatus getNextStatus(ChunkStatus status) {
+        if (status == ChunkStatus.FULL) {
+            return status;
+        }
+        return CHUNK_STATUSES.get(status.getIndex() + 1);
+    }
+    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getStatusFutureUncheckedMain(ChunkStatus chunkstatus) {
+        return ensureMain(getFutureIfPresentUnchecked(chunkstatus));
+    }
+    public <T> CompletableFuture<T> ensureMain(CompletableFuture<T> future) {
+        return future.thenApplyAsync(r -> r, chunkMap.mainInvokingExecutor);
+    }
+
+    @Override
+    public String toString() {
+        return "PlayerChunk{" +
+            "location=" + pos +
+            ", ticketLevel=" + ticketLevel + "/" + getStatus(this.ticketLevel) +
+            ", chunkHolderStatus=" + getChunkHolderStatus() +
+            ", neighborPriority=" + getNeighborsPriority() +
+            ", priority=(" + ticketLevel + " - " + priorityBoost +" vs N " + neighborPriority + ") = " + getDemandedPriority() + " A " + queueLevel +
+            '}';
+    }
+    // Paper end
+
+    // Paper start - optimise isOutsideOfRange
+    // cached here to avoid a map lookup
+    com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInMobSpawnRange;
+    com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInChunkTickRange;
+
+    void updateRanges() {
+        long key = net.minecraft.server.MCUtil.getCoordinateKey(this.pos);
+        this.playersInMobSpawnRange = this.chunkMap.playerMobSpawnMap.getObjectsInRange(key);
+        this.playersInChunkTickRange = this.chunkMap.playerChunkTickRangeMap.getObjectsInRange(key);
+    }
+    // Paper end - optimise isOutsideOfRange
+    long lastAutoSaveTime; // Paper - incremental autosave
+    long inactiveTimeStart; // Paper - incremental autosave
+    // Paper start - optimize chunk status progression without jumping through thread pool
+    public boolean canAdvanceStatus() {
+        ChunkStatus status = getChunkHolderStatus();
+        ChunkAccess chunk = getAvailableChunkNow();
+        return chunk != null && (status == null || chunk.getStatus().isOrAfter(getNextStatus(status)));
+    }
+    // Paper end
 
     public ChunkHolder(ChunkPos pos, int level, LevelHeightAccessor world, LevelLightEngine lightingProvider, ChunkHolder.LevelChangeListener levelUpdateListener, ChunkHolder.PlayerProvider playersWatchingChunkProvider) {
+        this.futures = new AtomicReferenceArray(ChunkHolder.CHUNK_STATUSES.size());
+        this.fullChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
+        this.tickingChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
+        this.entityTickingChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
+        this.chunkToSave = CompletableFuture.completedFuture(null); // CraftBukkit - decompile error
+        this.chunkToSaveHistory = null;
+        this.blockChangedLightSectionFilter = new BitSet();
+        this.skyChangedLightSectionFilter = new BitSet();
+        this.pendingFullStateConfirmation = CompletableFuture.completedFuture(null); // CraftBukkit - decompile error
         this.pos = pos;
         this.levelHeightAccessor = world;
         this.lightEngine = lightingProvider;
@@ -79,58 +270,103 @@
         this.queueLevel = this.oldTicketLevel;
         this.setTicketLevel(level);
         this.changedBlocksPerSection = new ShortSet[world.getSectionsCount()];
+        this.chunkMap = (ChunkMap)playersWatchingChunkProvider; // Paper
+        this.updateRanges(); // Paper - optimise isOutsideOfRange
+    }
+
+    // CraftBukkit start
+    public final LevelChunk getFullChunk() { // Paper - final for inline
+        if (!ChunkHolder.getFullChunkStatus(this.oldTicketLevel).isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) return null; // note: using oldTicketLevel for isLoaded checks
+        return this.getFullChunkUnchecked();
+    }
+
+    public LevelChunk getFullChunkUnchecked() {
+        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> statusFuture = this.getFutureIfPresentUnchecked(ChunkStatus.FULL);
+        Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = (Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>) statusFuture.getNow(null);
+        return (either == null) ? null : (LevelChunk) either.left().orElse(null);
     }
 
+    public ChunkAccess getAvailableChunkNow() {
+        // TODO can we just getStatusFuture(EMPTY)?
+        for (ChunkStatus curr = ChunkStatus.FULL, next = curr.getParent(); curr != next; curr = next, next = next.getParent()) {
+            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = this.getFutureIfPresentUnchecked(curr);
+            Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = future.getNow(null);
+            if (either == null || !either.left().isPresent()) {
+                continue;
+            }
+            return either.left().get();
+        }
+        return null;
+    }
+    // CraftBukkit end
+
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getFutureIfPresentUnchecked(ChunkStatus leastStatus) {
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completableFuture = this.futures.get(leastStatus.getIndex());
-        return completableFuture == null ? UNLOADED_CHUNK_FUTURE : completableFuture;
+        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = (CompletableFuture) this.futures.get(leastStatus.getIndex());
+
+        return completablefuture == null ? ChunkHolder.UNLOADED_CHUNK_FUTURE : completablefuture;
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getFutureIfPresent(ChunkStatus leastStatus) {
-        return getStatus(this.ticketLevel).isOrAfter(leastStatus) ? this.getFutureIfPresentUnchecked(leastStatus) : UNLOADED_CHUNK_FUTURE;
+        return ChunkHolder.getStatus(this.ticketLevel).isOrAfter(leastStatus) ? this.getFutureIfPresentUnchecked(leastStatus) : ChunkHolder.UNLOADED_CHUNK_FUTURE;
     }
 
-    public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> getTickingChunkFuture() {
+    public final CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> getTickingChunkFuture() { // Paper - final for inline
         return this.tickingChunkFuture;
     }
 
-    public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> getEntityTickingChunkFuture() {
+    public final CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> getEntityTickingChunkFuture() { // Paper - final for inline
         return this.entityTickingChunkFuture;
     }
 
-    public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> getFullChunkFuture() {
+    public final CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> getFullChunkFuture() { // Paper - final for inline
         return this.fullChunkFuture;
     }
 
     @Nullable
-    public LevelChunk getTickingChunk() {
-        CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completableFuture = this.getTickingChunkFuture();
-        Either<LevelChunk, ChunkHolder.ChunkLoadingFailure> either = completableFuture.getNow((Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>)null);
-        return either == null ? null : either.left().orElse((LevelChunk)null);
+    public final LevelChunk getTickingChunk() { // Paper - final for inline
+        CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getTickingChunkFuture();
+        Either<LevelChunk, ChunkHolder.ChunkLoadingFailure> either = (Either) completablefuture.getNow(null); // CraftBukkit - decompile error
+
+        return either == null ? null : (LevelChunk) either.left().orElse(null); // CraftBukkit - decompile error
     }
 
     @Nullable
     public ChunkStatus getLastAvailableStatus() {
-        for(int i = CHUNK_STATUSES.size() - 1; i >= 0; --i) {
-            ChunkStatus chunkStatus = CHUNK_STATUSES.get(i);
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completableFuture = this.getFutureIfPresentUnchecked(chunkStatus);
-            if (completableFuture.getNow(UNLOADED_CHUNK).left().isPresent()) {
-                return chunkStatus;
+        for (int i = ChunkHolder.CHUNK_STATUSES.size() - 1; i >= 0; --i) {
+            ChunkStatus chunkstatus = (ChunkStatus) ChunkHolder.CHUNK_STATUSES.get(i);
+            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getFutureIfPresentUnchecked(chunkstatus);
+
+            if (((Either) completablefuture.getNow(ChunkHolder.UNLOADED_CHUNK)).left().isPresent()) {
+                return chunkstatus;
             }
         }
+        return null;
+    }
+
+    public ChunkStatus getChunkHolderStatus() {
+        for (ChunkStatus curr = ChunkStatus.FULL, next = curr.getParent(); curr != next; curr = next, next = next.getParent()) {
+            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = this.getFutureIfPresentUnchecked(curr);
+            Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = future.getNow(null);
+            if (either == null || !either.left().isPresent()) {
+                continue;
+            }
+            return curr;
+        }
 
         return null;
     }
 
     @Nullable
     public ChunkAccess getLastAvailable() {
-        for(int i = CHUNK_STATUSES.size() - 1; i >= 0; --i) {
-            ChunkStatus chunkStatus = CHUNK_STATUSES.get(i);
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completableFuture = this.getFutureIfPresentUnchecked(chunkStatus);
-            if (!completableFuture.isCompletedExceptionally()) {
-                Optional<ChunkAccess> optional = completableFuture.getNow(UNLOADED_CHUNK).left();
+        for (int i = ChunkHolder.CHUNK_STATUSES.size() - 1; i >= 0; --i) {
+            ChunkStatus chunkstatus = (ChunkStatus) ChunkHolder.CHUNK_STATUSES.get(i);
+            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getFutureIfPresentUnchecked(chunkstatus);
+
+            if (!completablefuture.isCompletedExceptionally()) {
+                Optional<ChunkAccess> optional = ((Either) completablefuture.getNow(ChunkHolder.UNLOADED_CHUNK)).left();
+
                 if (optional.isPresent()) {
-                    return optional.get();
+                    return (ChunkAccess) optional.get();
                 }
             }
         }
@@ -138,14 +374,18 @@
         return null;
     }
 
-    public CompletableFuture<ChunkAccess> getChunkToSave() {
+    public final CompletableFuture<ChunkAccess> getChunkToSave() { // Paper - final for inline
         return this.chunkToSave;
     }
 
     public void blockChanged(BlockPos pos) {
-        LevelChunk levelChunk = this.getTickingChunk();
-        if (levelChunk != null) {
+        if (!pos.isValidLocation(levelHeightAccessor)) return; // Paper - SPIGOT-6086 for all invalid locations; avoid acquiring locks
+        LevelChunk chunk = this.getSendingChunk(); // Paper - no-tick view distance
+
+        if (chunk != null) {
             int i = this.levelHeightAccessor.getSectionIndex(pos.getY());
+
+            if (i < 0 || i >= this.changedBlocksPerSection.length) return; // CraftBukkit - SPIGOT-6086, SPIGOT-6296
             if (this.changedBlocksPerSection[i] == null) {
                 this.hasChangedSections = true;
                 this.changedBlocksPerSection[i] = new ShortArraySet();
@@ -156,17 +396,20 @@
     }
 
     public void sectionLightChanged(LightLayer lightType, int y) {
-        LevelChunk levelChunk = this.getTickingChunk();
-        if (levelChunk != null) {
-            levelChunk.setUnsaved(true);
-            int i = this.lightEngine.getMinLightSection();
-            int j = this.lightEngine.getMaxLightSection();
-            if (y >= i && y <= j) {
-                int k = y - i;
+        LevelChunk chunk = this.getSendingChunk(); // Paper - no-tick view distance
+
+        if (chunk != null) {
+            chunk.setUnsaved(true);
+            int j = this.lightEngine.getMinLightSection();
+            int k = this.lightEngine.getMaxLightSection();
+
+            if (y >= j && y <= k) {
+                int l = y - j;
+
                 if (lightType == LightLayer.SKY) {
-                    this.skyChangedLightSectionFilter.set(k);
+                    this.skyChangedLightSectionFilter.set(l);
                 } else {
-                    this.blockChangedLightSectionFilter.set(k);
+                    this.blockChangedLightSectionFilter.set(l);
                 }
 
             }
@@ -175,10 +418,12 @@
 
     public void broadcastChanges(LevelChunk chunk) {
         if (this.hasChangedSections || !this.skyChangedLightSectionFilter.isEmpty() || !this.blockChangedLightSectionFilter.isEmpty()) {
-            Level level = chunk.getLevel();
+            Level world = chunk.getLevel();
             int i = 0;
 
-            for(int j = 0; j < this.changedBlocksPerSection.length; ++j) {
+            int j;
+
+            for (j = 0; j < this.changedBlocksPerSection.length; ++j) {
                 i += this.changedBlocksPerSection[j] != null ? this.changedBlocksPerSection[j].size() : 0;
             }
 
@@ -189,26 +434,30 @@
                 this.blockChangedLightSectionFilter.clear();
             }
 
-            for(int k = 0; k < this.changedBlocksPerSection.length; ++k) {
-                ShortSet shortSet = this.changedBlocksPerSection[k];
-                if (shortSet != null) {
-                    int l = this.levelHeightAccessor.getSectionYFromSectionIndex(k);
-                    SectionPos sectionPos = SectionPos.of(chunk.getPos(), l);
-                    if (shortSet.size() == 1) {
-                        BlockPos blockPos = sectionPos.relativeToBlockPos(shortSet.iterator().nextShort());
-                        BlockState blockState = level.getBlockState(blockPos);
-                        this.broadcast(new ClientboundBlockUpdatePacket(blockPos, blockState), false);
-                        this.broadcastBlockEntityIfNeeded(level, blockPos, blockState);
+            for (j = 0; j < this.changedBlocksPerSection.length; ++j) {
+                ShortSet shortset = this.changedBlocksPerSection[j];
+
+                if (shortset != null) {
+                    int k = this.levelHeightAccessor.getSectionYFromSectionIndex(j);
+                    SectionPos sectionposition = SectionPos.of(chunk.getPos(), k);
+
+                    if (shortset.size() == 1) {
+                        BlockPos blockposition = sectionposition.relativeToBlockPos(shortset.iterator().nextShort());
+                        BlockState iblockdata = world.getBlockState(blockposition);
+
+                        this.broadcast(new ClientboundBlockUpdatePacket(blockposition, iblockdata), false);
+                        this.a(world, blockposition, iblockdata);
                     } else {
-                        LevelChunkSection levelChunkSection = chunk.getSections()[k];
-                        ClientboundSectionBlocksUpdatePacket clientboundSectionBlocksUpdatePacket = new ClientboundSectionBlocksUpdatePacket(sectionPos, shortSet, levelChunkSection, this.resendLight);
-                        this.broadcast(clientboundSectionBlocksUpdatePacket, false);
-                        clientboundSectionBlocksUpdatePacket.runUpdates((pos, state) -> {
-                            this.broadcastBlockEntityIfNeeded(level, pos, state);
+                        LevelChunkSection chunksection = chunk.getSections()[j];
+                        ClientboundSectionBlocksUpdatePacket packetplayoutmultiblockchange = new ClientboundSectionBlocksUpdatePacket(sectionposition, shortset, chunksection, this.resendLight);
+
+                        this.broadcast(packetplayoutmultiblockchange, false);
+                        packetplayoutmultiblockchange.runUpdates((blockposition1, iblockdata1) -> {
+                            this.a(world, blockposition1, iblockdata1);
                         });
                     }
 
-                    this.changedBlocksPerSection[k] = null;
+                    this.changedBlocksPerSection[j] = null;
                 }
             }
 
@@ -216,48 +465,92 @@
         }
     }
 
-    private void broadcastBlockEntityIfNeeded(Level world, BlockPos pos, BlockState state) {
-        if (state.hasBlockEntity()) {
-            this.broadcastBlockEntity(world, pos);
+    private void a(Level world, BlockPos blockposition, BlockState iblockdata) {
+        if (iblockdata.hasBlockEntity()) {
+            this.broadcastBlockEntity(world, blockposition);
         }
 
     }
 
     private void broadcastBlockEntity(Level world, BlockPos pos) {
-        BlockEntity blockEntity = world.getBlockEntity(pos);
-        if (blockEntity != null) {
-            ClientboundBlockEntityDataPacket clientboundBlockEntityDataPacket = blockEntity.getUpdatePacket();
-            if (clientboundBlockEntityDataPacket != null) {
-                this.broadcast(clientboundBlockEntityDataPacket, false);
+        BlockEntity tileentity = world.getBlockEntity(pos);
+
+        if (tileentity != null) {
+            ClientboundBlockEntityDataPacket packetplayouttileentitydata = tileentity.getUpdatePacket();
+
+            if (packetplayouttileentitydata != null) {
+                this.broadcast(packetplayouttileentitydata, false);
             }
         }
 
     }
 
-    private void broadcast(Packet<?> packet, boolean onlyOnWatchDistanceEdge) {
-        this.playerProvider.getPlayers(this.pos, onlyOnWatchDistanceEdge).forEach((serverPlayer) -> {
-            serverPlayer.connection.send(packet);
-        });
+    public void broadcast(Packet<?> packet, boolean onlyOnWatchDistanceEdge) {
+        // Paper start - per player view distance
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        com.destroystokyo.paper.util.misc.PlayerAreaMap viewDistanceMap = this.chunkMap.playerViewDistanceBroadcastMap;
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = viewDistanceMap.getObjectsInRange(this.pos);
+        if (players == null) {
+            return;
+        }
+
+        if (onlyOnWatchDistanceEdge) { // flag -> border only
+            Object[] backingSet = players.getBackingSet();
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof ServerPlayer)) {
+                    continue;
+                }
+                ServerPlayer player = (ServerPlayer)temp;
+
+                int viewDistance = viewDistanceMap.getLastViewDistance(player);
+                long lastPosition = viewDistanceMap.getLastCoordinate(player);
+
+                int distX = Math.abs(net.minecraft.server.MCUtil.getCoordinateX(lastPosition) - this.pos.x);
+                int distZ = Math.abs(net.minecraft.server.MCUtil.getCoordinateZ(lastPosition) - this.pos.z);
+
+                if (Math.max(distX, distZ) == viewDistance) {
+                    player.connection.send(packet);
+                }
+            }
+        } else {
+            Object[] backingSet = players.getBackingSet();
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof ServerPlayer)) {
+                    continue;
+                }
+                ServerPlayer player = (ServerPlayer)temp;
+                player.connection.send(packet);
+            }
+        }
+
+        return;
+        // Paper end - per player view distance
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getOrScheduleFuture(ChunkStatus targetStatus, ChunkMap chunkStorage) {
         int i = targetStatus.getIndex();
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completableFuture = this.futures.get(i);
-        if (completableFuture != null) {
-            Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = completableFuture.getNow((Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>)null);
-            boolean bl = either != null && either.right().isPresent();
-            if (!bl) {
-                return completableFuture;
+        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = (CompletableFuture) this.futures.get(i);
+
+        if (completablefuture != null) {
+            Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = (Either) completablefuture.getNow(null); // CraftBukkit - decompile error
+            boolean flag = either != null && either.right().isPresent();
+
+            if (!flag) {
+                return completablefuture;
             }
         }
 
-        if (getStatus(this.ticketLevel).isOrAfter(targetStatus)) {
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completableFuture2 = chunkStorage.schedule(this, targetStatus);
-            this.updateChunkToSave(completableFuture2, "schedule " + targetStatus);
-            this.futures.set(i, completableFuture2);
-            return completableFuture2;
+        if (ChunkHolder.getStatus(this.ticketLevel).isOrAfter(targetStatus)) {
+            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture1 = chunkStorage.schedule(this, targetStatus);
+
+            this.updateChunkToSave(completablefuture1, "schedule " + targetStatus);
+            this.futures.set(i, completablefuture1);
+            return completablefuture1;
         } else {
-            return completableFuture == null ? UNLOADED_CHUNK_FUTURE : completableFuture;
+            return completablefuture == null ? ChunkHolder.UNLOADED_CHUNK_FUTURE : completablefuture;
         }
     }
 
@@ -266,24 +559,24 @@
             this.chunkToSaveHistory.push(new ChunkHolder.ChunkSaveDebug(Thread.currentThread(), then, thenDesc));
         }
 
-        this.chunkToSave = this.chunkToSave.thenCombine(then, (chunkAccess, either) -> {
-            return either.map((chunkAccessx) -> {
-                return chunkAccessx;
-            }, (chunkLoadingFailure) -> {
-                return chunkAccess;
+        this.chunkToSave = this.chunkToSave.thenCombine(then, (ichunkaccess, either) -> {
+            return (ChunkAccess) either.map((ichunkaccess1) -> {
+                return ichunkaccess1;
+            }, (playerchunk_failure) -> {
+                return ichunkaccess;
             });
         });
     }
 
     public ChunkHolder.FullChunkStatus getFullStatus() {
-        return getFullChunkStatus(this.ticketLevel);
+        return ChunkHolder.getFullChunkStatus(this.ticketLevel);
     }
 
-    public ChunkPos getPos() {
+    public final ChunkPos getPos() { // Paper - final for inline
         return this.pos;
     }
 
-    public int getTicketLevel() {
+    public final int getTicketLevel() { // Paper - final for inline
         return this.ticketLevel;
     }
 
@@ -299,100 +592,217 @@
         this.ticketLevel = level;
     }
 
-    private void scheduleFullChunkPromotion(ChunkMap chunkMap, CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completableFuture, Executor executor, ChunkHolder.FullChunkStatus fullChunkStatus) {
+    private void scheduleFullChunkPromotion(ChunkMap playerchunkmap, CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture, Executor executor, ChunkHolder.FullChunkStatus playerchunk_state) {
         this.pendingFullStateConfirmation.cancel(false);
-        CompletableFuture<Void> completableFuture2 = new CompletableFuture<>();
-        completableFuture2.thenRunAsync(() -> {
-            chunkMap.onFullChunkStatusChange(this.pos, fullChunkStatus);
+        CompletableFuture<Void> completablefuture1 = new CompletableFuture();
+
+        completablefuture1.thenRunAsync(() -> {
+            playerchunkmap.onFullChunkStatusChange(this.pos, playerchunk_state);
         }, executor);
-        this.pendingFullStateConfirmation = completableFuture2;
-        completableFuture.thenAccept((either) -> {
-            either.ifLeft((levelChunk) -> {
-                completableFuture2.complete((Void)null);
+        this.pendingFullStateConfirmation = completablefuture1;
+        completablefuture.thenAccept((either) -> {
+            either.ifLeft((chunk) -> {
+                completablefuture1.complete(null); // CraftBukkit - decompile error
             });
         });
     }
 
-    private void demoteFullChunk(ChunkMap chunkMap, ChunkHolder.FullChunkStatus fullChunkStatus) {
+    private void demoteFullChunk(ChunkMap playerchunkmap, ChunkHolder.FullChunkStatus playerchunk_state) {
         this.pendingFullStateConfirmation.cancel(false);
-        chunkMap.onFullChunkStatusChange(this.pos, fullChunkStatus);
+        playerchunkmap.onFullChunkStatusChange(this.pos, playerchunk_state);
     }
 
     protected void updateFutures(ChunkMap chunkStorage, Executor executor) {
-        ChunkStatus chunkStatus = getStatus(this.oldTicketLevel);
-        ChunkStatus chunkStatus2 = getStatus(this.ticketLevel);
-        boolean bl = this.oldTicketLevel <= ChunkMap.MAX_CHUNK_DISTANCE;
-        boolean bl2 = this.ticketLevel <= ChunkMap.MAX_CHUNK_DISTANCE;
-        ChunkHolder.FullChunkStatus fullChunkStatus = getFullChunkStatus(this.oldTicketLevel);
-        ChunkHolder.FullChunkStatus fullChunkStatus2 = getFullChunkStatus(this.ticketLevel);
-        if (bl) {
+        ChunkStatus chunkstatus = ChunkHolder.getStatus(this.oldTicketLevel);
+        ChunkStatus chunkstatus1 = ChunkHolder.getStatus(this.ticketLevel);
+        boolean flag = this.oldTicketLevel <= ChunkMap.MAX_CHUNK_DISTANCE;
+        boolean flag1 = this.ticketLevel <= ChunkMap.MAX_CHUNK_DISTANCE; // Paper - diff on change: (flag1 = new ticket level is in loadable range)
+        ChunkHolder.FullChunkStatus playerchunk_state = ChunkHolder.getFullChunkStatus(this.oldTicketLevel);
+        ChunkHolder.FullChunkStatus playerchunk_state1 = ChunkHolder.getFullChunkStatus(this.ticketLevel);
+        // CraftBukkit start
+        // ChunkUnloadEvent: Called before the chunk is unloaded: isChunkLoaded is still true and chunk can still be modified by plugins.
+        if (playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && !playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+            this.getStatusFutureUncheckedMain(ChunkStatus.FULL).thenAccept((either) -> { // Paper - ensure main
+                LevelChunk chunk = (LevelChunk)either.left().orElse(null);
+                if (chunk != null) {
+                    chunkStorage.callbackExecutor.execute(() -> {
+                        // Minecraft will apply the chunks tick lists to the world once the chunk got loaded, and then store the tick
+                        // lists again inside the chunk once the chunk becomes inaccessible and set the chunk's needsSaving flag.
+                        // These actions may however happen deferred, so we manually set the needsSaving flag already here.
+                        chunk.setUnsaved(true);
+                        chunk.unloadCallback();
+                    });
+                }
+            }).exceptionally((throwable) -> {
+                // ensure exceptions are printed, by default this is not the case
+                MinecraftServer.LOGGER.fatal("Failed to schedule unload callback for chunk " + ChunkHolder.this.pos, throwable);
+                return null;
+            });
+
+            // Run callback right away if the future was already done
+            chunkStorage.callbackExecutor.run();
+        }
+        // CraftBukkit end
+        CompletableFuture completablefuture;
+
+        if (flag) {
             Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = Either.right(new ChunkHolder.ChunkLoadingFailure() {
                 public String toString() {
                     return "Unloaded ticket level " + ChunkHolder.this.pos;
                 }
             });
 
-            for(int i = bl2 ? chunkStatus2.getIndex() + 1 : 0; i <= chunkStatus.getIndex(); ++i) {
-                CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completableFuture = this.futures.get(i);
-                if (completableFuture == null) {
+            for (int i = flag1 ? chunkstatus1.getIndex() + 1 : 0; i <= chunkstatus.getIndex(); ++i) {
+                completablefuture = (CompletableFuture) this.futures.get(i);
+                if (completablefuture == null) {
                     this.futures.set(i, CompletableFuture.completedFuture(either));
                 }
             }
         }
 
-        boolean bl3 = fullChunkStatus.isOrAfter(ChunkHolder.FullChunkStatus.BORDER);
-        boolean bl4 = fullChunkStatus2.isOrAfter(ChunkHolder.FullChunkStatus.BORDER);
-        this.wasAccessibleSinceLastSave |= bl4;
-        if (!bl3 && bl4) {
+        boolean flag2 = playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.BORDER);
+        boolean flag3 = playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.BORDER);
+
+        boolean prevHasBeenLoaded = this.wasAccessibleSinceLastSave; // Paper
+        this.wasAccessibleSinceLastSave |= flag3;
+        // Paper start - incremental autosave
+        if (this.wasAccessibleSinceLastSave & !prevHasBeenLoaded) {
+            long timeSinceAutoSave = this.inactiveTimeStart - this.lastAutoSaveTime;
+            if (timeSinceAutoSave < 0) {
+                // safest bet is to assume autosave is needed here
+                timeSinceAutoSave = this.chunkMap.level.paperConfig.autoSavePeriod;
+            }
+            this.lastAutoSaveTime = this.chunkMap.level.getGameTime() - timeSinceAutoSave;
+            this.chunkMap.autoSaveQueue.add(this);
+        }
+        // Paper end
+        if (!flag2 && flag3) {
+            int expectCreateCount = ++this.fullChunkCreateCount; // Paper
             this.fullChunkFuture = chunkStorage.prepareAccessibleChunk(this);
             this.scheduleFullChunkPromotion(chunkStorage, this.fullChunkFuture, executor, ChunkHolder.FullChunkStatus.BORDER);
+            // Paper start - cache ticking ready status
+            ensureMain(this.fullChunkFuture).thenAccept(either -> { // Paper - ensure main
+                final Optional<LevelChunk> left = either.left();
+                if (left.isPresent() && ChunkHolder.this.fullChunkCreateCount == expectCreateCount) {
+                    // note: Here is a very good place to add callbacks to logic waiting on this.
+                    LevelChunk fullChunk = either.left().get();
+                    ChunkHolder.this.isFullChunkReady = true;
+                    fullChunk.playerChunk = ChunkHolder.this;
+                    this.chunkMap.distanceManager.clearPriorityTickets(pos);
+                }
+            });
             this.updateChunkToSave(this.fullChunkFuture, "full");
         }
 
-        if (bl3 && !bl4) {
-            CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completableFuture2 = this.fullChunkFuture;
-            this.fullChunkFuture = UNLOADED_LEVEL_CHUNK_FUTURE;
-            this.updateChunkToSave(completableFuture2.thenApply((either) -> {
-                return either.ifLeft(chunkStorage::packTicks);
+        if (flag2 && !flag3) {
+            completablefuture = this.fullChunkFuture;
+            this.fullChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
+            ++this.fullChunkCreateCount; // Paper - cache ticking ready status
+            this.isFullChunkReady = false; // Paper - cache ticking ready status
+            this.updateChunkToSave(((CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>>) completablefuture).thenApply((either1) -> { // CraftBukkit - decompile error
+                Objects.requireNonNull(chunkStorage);
+                return either1.ifLeft(chunkStorage::packTicks);
             }), "unfull");
         }
 
-        boolean bl5 = fullChunkStatus.isOrAfter(ChunkHolder.FullChunkStatus.TICKING);
-        boolean bl6 = fullChunkStatus2.isOrAfter(ChunkHolder.FullChunkStatus.TICKING);
-        if (!bl5 && bl6) {
+        boolean flag4 = playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.TICKING);
+        boolean flag5 = playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.TICKING);
+
+        if (!flag4 && flag5) {
             this.tickingChunkFuture = chunkStorage.prepareTickingChunk(this);
             this.scheduleFullChunkPromotion(chunkStorage, this.tickingChunkFuture, executor, ChunkHolder.FullChunkStatus.TICKING);
+            // Paper start - cache ticking ready status
+            ensureMain(this.tickingChunkFuture).thenAccept(either -> { // Paper - ensure main
+                either.ifLeft(chunk -> {
+                    // note: Here is a very good place to add callbacks to logic waiting on this.
+                    ChunkHolder.this.isTickingReady = true;
+
+                    // Paper start - rewrite ticklistserver
+                    if (ChunkHolder.this.chunkMap.level.entityManager.areEntitiesLoaded(this.pos.longKey)) {
+                        ChunkHolder.this.chunkMap.level.onChunkSetTicking(ChunkHolder.this.pos.x, ChunkHolder.this.pos.z);
+                    }
+                    // Paper end - rewrite ticklistserver
+                });
+            });
+            // Paper end
             this.updateChunkToSave(this.tickingChunkFuture, "ticking");
         }
 
-        if (bl5 && !bl6) {
-            this.tickingChunkFuture.complete(UNLOADED_LEVEL_CHUNK);
-            this.tickingChunkFuture = UNLOADED_LEVEL_CHUNK_FUTURE;
+        if (flag4 && !flag5) {
+            this.tickingChunkFuture.complete(ChunkHolder.UNLOADED_LEVEL_CHUNK); this.isTickingReady = false; // Paper - cache chunk ticking stage
+            this.tickingChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
         }
 
-        boolean bl7 = fullChunkStatus.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING);
-        boolean bl8 = fullChunkStatus2.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING);
-        if (!bl7 && bl8) {
-            if (this.entityTickingChunkFuture != UNLOADED_LEVEL_CHUNK_FUTURE) {
-                throw (IllegalStateException)Util.pauseInIde(new IllegalStateException());
+        boolean flag6 = playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING);
+        boolean flag7 = playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING);
+
+        if (!flag6 && flag7) {
+            if (this.entityTickingChunkFuture != ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE) {
+                throw (IllegalStateException) Util.pauseInIde((Throwable) (new IllegalStateException()));
             }
 
             this.entityTickingChunkFuture = chunkStorage.prepareEntityTickingChunk(this.pos);
             this.scheduleFullChunkPromotion(chunkStorage, this.entityTickingChunkFuture, executor, ChunkHolder.FullChunkStatus.ENTITY_TICKING);
+            // Paper start - cache ticking ready status
+            ensureMain(this.entityTickingChunkFuture).thenAccept(either -> { // Paper ensureMain
+                either.ifLeft(chunk -> {
+                    ChunkHolder.this.isEntityTickingReady = true;
+                });
+            });
+            // Paper end
             this.updateChunkToSave(this.entityTickingChunkFuture, "entity ticking");
         }
 
-        if (bl7 && !bl8) {
-            this.entityTickingChunkFuture.complete(UNLOADED_LEVEL_CHUNK);
-            this.entityTickingChunkFuture = UNLOADED_LEVEL_CHUNK_FUTURE;
+        if (flag6 && !flag7) {
+            this.entityTickingChunkFuture.complete(ChunkHolder.UNLOADED_LEVEL_CHUNK); this.isEntityTickingReady = false; // Paper - cache chunk ticking stage
+            this.entityTickingChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
         }
 
-        if (!fullChunkStatus2.isOrAfter(fullChunkStatus)) {
-            this.demoteFullChunk(chunkStorage, fullChunkStatus2);
+        if (!playerchunk_state1.isOrAfter(playerchunk_state)) {
+            this.demoteFullChunk(chunkStorage, playerchunk_state1);
         }
 
-        this.onLevelChange.onLevelChange(this.pos, this::getQueueLevel, this.ticketLevel, this::setQueueLevel);
+        //this.onLevelChange.onLevelChange(this.pos, this::getQueueLevel, this.ticketLevel, this::setQueueLevel);
+        // Paper start - raise IO/load priority if priority changes, use our preferred priority
+        priorityBoost = chunkMap.distanceManager.getChunkPriority(pos);
+        int priority = getDemandedPriority();
+        if (this.queueLevel > priority) {
+            int ioPriority = com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY;
+            if (priority <= 10) {
+                ioPriority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
+            } else if (priority <= 20) {
+                ioPriority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY;
+            }
+            chunkMap.level.asyncChunkTaskManager.raisePriority(pos.x, pos.z, ioPriority);
+            chunkMap.level.getChunkSource().getLightEngine().queue.changePriority(pos.toLong(), this.queueLevel, priority); // Paper
+        }
+        if (this.queueLevel != priority) {
+            this.onLevelChange.onLevelChange(this.pos, () -> this.queueLevel, priority, p -> this.queueLevel = p); // use preferred priority
+            int neighborsPriority = getNeighborsPriority();
+            this.neighbors.forEach((neighbor, neighborDesired) -> neighbor.setNeighborPriority(this, neighborsPriority));
+        }
+        // Paper end
         this.oldTicketLevel = this.ticketLevel;
+        // CraftBukkit start
+        // ChunkLoadEvent: Called after the chunk is loaded: isChunkLoaded returns true and chunk is ready to be modified by plugins.
+        if (!playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+            this.getStatusFutureUncheckedMain(ChunkStatus.FULL).thenAccept((either) -> { // Paper - ensure main
+                LevelChunk chunk = (LevelChunk)either.left().orElse(null);
+                if (chunk != null) {
+                    chunkStorage.callbackExecutor.execute(() -> {
+                        chunk.loadCallback();
+                    });
+                }
+            }).exceptionally((throwable) -> {
+                // ensure exceptions are printed, by default this is not the case
+                MinecraftServer.LOGGER.fatal("Failed to schedule load callback for chunk " + ChunkHolder.this.pos, throwable);
+                return null;
+            });
+
+            // Run callback right away if the future was already done
+            chunkStorage.callbackExecutor.run();
+        }
+        // CraftBukkit end
     }
 
     public static ChunkStatus getStatus(int level) {
@@ -400,7 +810,7 @@
     }
 
     public static ChunkHolder.FullChunkStatus getFullChunkStatus(int distance) {
-        return FULL_CHUNK_STATUSES[Mth.clamp(33 - distance + 1, 0, FULL_CHUNK_STATUSES.length - 1)];
+        return ChunkHolder.FULL_CHUNK_STATUSES[Mth.clamp(33 - distance + 1, 0, ChunkHolder.FULL_CHUNK_STATUSES.length - 1)];
     }
 
     public boolean wasAccessibleSinceLastSave() {
@@ -408,14 +818,40 @@
     }
 
     public void refreshAccessibility() {
+        boolean prev = this.wasAccessibleSinceLastSave; // Paper
+        this.wasAccessibleSinceLastSave = ChunkHolder.getFullChunkStatus(this.ticketLevel).isOrAfter(ChunkHolder.FullChunkStatus.BORDER);
+        // Paper start - incremental autosave
+        if (prev != this.wasAccessibleSinceLastSave) {
+            if (this.wasAccessibleSinceLastSave) {
+                long timeSinceAutoSave = this.inactiveTimeStart - this.lastAutoSaveTime;
+                if (timeSinceAutoSave < 0) {
+                    // safest bet is to assume autosave is needed here
+                    timeSinceAutoSave = this.chunkMap.level.paperConfig.autoSavePeriod;
+                }
+                this.lastAutoSaveTime = this.chunkMap.level.getGameTime() - timeSinceAutoSave;
+                this.chunkMap.autoSaveQueue.add(this);
+            } else {
+                this.inactiveTimeStart = this.chunkMap.level.getGameTime();
+                this.chunkMap.autoSaveQueue.remove(this);
+            }
+        }
+        // Paper end
+    }
+
+    // Paper start - incremental autosave
+    public boolean setHasBeenLoaded() {
         this.wasAccessibleSinceLastSave = getFullChunkStatus(this.ticketLevel).isOrAfter(ChunkHolder.FullChunkStatus.BORDER);
+        return this.wasAccessibleSinceLastSave;
     }
+    // Paper end
 
     public void replaceProtoChunk(ImposterProtoChunk chunk) {
-        for(int i = 0; i < this.futures.length(); ++i) {
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completableFuture = this.futures.get(i);
-            if (completableFuture != null) {
-                Optional<ChunkAccess> optional = completableFuture.getNow(UNLOADED_CHUNK).left();
+        for (int i = 0; i < this.futures.length(); ++i) {
+            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = (CompletableFuture) this.futures.get(i);
+
+            if (completablefuture != null) {
+                Optional<ChunkAccess> optional = ((Either) completablefuture.getNow(ChunkHolder.UNLOADED_CHUNK)).left();
+
                 if (optional.isPresent() && optional.get() instanceof ProtoChunk) {
                     this.futures.set(i, CompletableFuture.completedFuture(Either.left(chunk)));
                 }
@@ -425,15 +861,19 @@
         this.updateChunkToSave(CompletableFuture.completedFuture(Either.left(chunk.getWrapped())), "replaceProto");
     }
 
-    public interface ChunkLoadingFailure {
-        ChunkHolder.ChunkLoadingFailure UNLOADED = new ChunkHolder.ChunkLoadingFailure() {
-            public String toString() {
-                return "UNLOADED";
-            }
-        };
+    @FunctionalInterface
+    public interface LevelChangeListener {
+
+        void onLevelChange(ChunkPos pos, IntSupplier levelGetter, int targetLevel, IntConsumer levelSetter);
     }
 
-    static final class ChunkSaveDebug {
+    public interface PlayerProvider {
+
+        Stream<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge);
+    }
+
+    private static final class ChunkSaveDebug {
+
         private final Thread thread;
         private final CompletableFuture<? extends Either<? extends ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future;
         private final String source;
@@ -446,22 +886,22 @@
     }
 
     public static enum FullChunkStatus {
-        INACCESSIBLE,
-        BORDER,
-        TICKING,
-        ENTITY_TICKING;
+
+        INACCESSIBLE, BORDER, TICKING, ENTITY_TICKING;
+
+        private FullChunkStatus() {}
 
         public boolean isOrAfter(ChunkHolder.FullChunkStatus levelType) {
             return this.ordinal() >= levelType.ordinal();
         }
     }
 
-    @FunctionalInterface
-    public interface LevelChangeListener {
-        void onLevelChange(ChunkPos pos, IntSupplier levelGetter, int targetLevel, IntConsumer levelSetter);
-    }
+    public interface ChunkLoadingFailure {
 
-    public interface PlayerProvider {
-        Stream<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge);
+        ChunkHolder.ChunkLoadingFailure UNLOADED = new ChunkHolder.ChunkLoadingFailure() {
+            public String toString() {
+                return "UNLOADED";
+            }
+        };
     }
 }
