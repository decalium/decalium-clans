--- a/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java
+++ b/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java
@@ -14,7 +14,7 @@
     protected int nextStartTick;
     protected int tryTicks;
     private int maxStayTicks;
-    protected BlockPos blockPos = BlockPos.ZERO;
+    protected BlockPos blockPos = BlockPos.ZERO; @Deprecated public final BlockPos getTargetPosition() { return this.blockPos; } @Deprecated public void setTargetPosition(BlockPos pos) { this.blockPos = pos; mob.movingTarget = pos != BlockPos.ZERO ? pos : null; } // Paper - OBFHELPER
     private boolean reachedTarget;
     private final int searchRange;
     private final int verticalSearchRange;
@@ -23,6 +23,13 @@
     public MoveToBlockGoal(PathfinderMob mob, double speed, int range) {
         this(mob, speed, range, 1);
     }
+    // Paper start - activation range improvements
+    @Override
+    public void stop() {
+        super.stop();
+        setTargetPosition(BlockPos.ZERO);
+    }
+    // Paper end
 
     public MoveToBlockGoal(PathfinderMob mob, double speed, int range, int maxYDifference) {
         this.mob = mob;
@@ -33,6 +40,7 @@
         this.setFlags(EnumSet.of(Goal.Flag.MOVE, Goal.Flag.JUMP));
     }
 
+    @Override
     public boolean canUse() {
         if (this.nextStartTick > 0) {
             --this.nextStartTick;
@@ -47,10 +55,12 @@
         return 200 + mob.getRandom().nextInt(200);
     }
 
+    @Override
     public boolean canContinueToUse() {
         return this.tryTicks >= -this.maxStayTicks && this.tryTicks <= 1200 && this.isValidTarget(this.mob.level, this.blockPos);
     }
 
+    @Override
     public void start() {
         this.moveMobToBlock();
         this.tryTicks = 0;
@@ -69,6 +79,7 @@
         return this.blockPos.above();
     }
 
+    @Override
     public void tick() {
         BlockPos blockPos = this.getMoveToTarget();
         if (!blockPos.closerThan(this.mob.position(), this.acceptedDistance())) {
@@ -105,6 +116,7 @@
                         mutableBlockPos.setWithOffset(blockPos, m, k - 1, n);
                         if (this.mob.isWithinRestriction(mutableBlockPos) && this.isValidTarget(this.mob.level, mutableBlockPos)) {
                             this.blockPos = mutableBlockPos;
+                            setTargetPosition(mutableBlockPos.immutable()); // Paper
                             return true;
                         }
                     }
