--- a/net/minecraft/world/phys/shapes/Shapes.java
+++ b/net/minecraft/world/phys/shapes/Shapes.java
@@ -237,8 +237,9 @@
 
                             if (s < 3) {
                                 mutableBlockPos.set(axisCycle, q, r, p);
-                                BlockState blockState = world.getBlockState(mutableBlockPos);
-                                if ((s != 1 || blockState.hasLargeCollisionShape()) && (s != 2 || blockState.is(Blocks.MOVING_PISTON))) {
+                                BlockState blockState = world.getTypeIfLoaded(mutableBlockPos); // Paper
+                                if (blockState == null) return 0.0D; // Paper
+                                if (!blockState.isAir() && (s != 1 || blockState.hasLargeCollisionShape()) && (s != 2 || blockState.is(Blocks.MOVING_PISTON))) { // Paper
                                     initial = blockState.getCollisionShape(world, mutableBlockPos, context).collide(axis3, box.move((double)(-mutableBlockPos.getX()), (double)(-mutableBlockPos.getY()), (double)(-mutableBlockPos.getZ())), initial);
                                     if (Math.abs(initial) < 1.0E-7D) {
                                         return 0.0D;
@@ -335,9 +336,21 @@
     }
 
     @VisibleForTesting
-    protected static IndexMerger createIndexMerger(int size, DoubleList first, DoubleList second, boolean includeFirst, boolean includeSecond) {
+    private static IndexMerger createIndexMerger(int size, DoubleList first, DoubleList second, boolean includeFirst, boolean includeSecond) { // Paper - private
+        // Paper start - fast track the most common scenario
+        // doublelist is usually a DoubleArrayList with Infinite head/tails that falls to the final else clause
+        // This is actually the most common path, so jump to it straight away
+        if (first.getDouble(0) == Double.NEGATIVE_INFINITY && first.getDouble(first.size() - 1) == Double.POSITIVE_INFINITY) {
+            return new IndirectMerger(first, second, includeFirst, includeSecond);
+        }
+        // Split out rest to hopefully inline the above
+        return lessCommonMerge(size, first, second, includeFirst, includeSecond);
+    }
+
+    private static IndexMerger lessCommonMerge(int size, DoubleList first, DoubleList second, boolean includeFirst, boolean includeSecond) {
         int i = first.size() - 1;
         int j = second.size() - 1;
+        // Paper note - Rewrite below as optimized order if instead of nasty ternary
         if (first instanceof CubePointRange && second instanceof CubePointRange) {
             long l = lcm(i, j);
             if ((long)size * l <= 256L) {
@@ -345,13 +358,22 @@
             }
         }
 
-        if (first.getDouble(i) < second.getDouble(0) - 1.0E-7D) {
+        // Paper start - Identical happens more often than Disjoint
+        if (i == j && Objects.equals(first, second)) {
+            if (first instanceof IdenticalMerger) {
+                return (IndexMerger) first;
+            } else if (second instanceof IdenticalMerger) {
+                return (IndexMerger) second;
+            }
+            return new IdenticalMerger(first);
+        } else if (first.getDouble(i) < second.getDouble(0) - 1.0E-7D) {
             return new NonOverlappingMerger(first, second, false);
         } else if (second.getDouble(j) < first.getDouble(0) - 1.0E-7D) {
             return new NonOverlappingMerger(second, first, true);
         } else {
-            return (IndexMerger)(i == j && Objects.equals(first, second) ? new IdenticalMerger(first) : new IndirectMerger(first, second, includeFirst, includeSecond));
+            return new IndirectMerger(first, second, includeFirst, includeSecond);
         }
+        // Paper end
     }
 
     public interface DoubleLineConsumer {
