--- a/net/minecraft/core/BlockPos.java
+++ b/net/minecraft/core/BlockPos.java
@@ -15,7 +15,7 @@
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
-import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.libs.org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -30,15 +30,16 @@
     }).stable();
     private static final Logger LOGGER = LogManager.getLogger();
     public static final BlockPos ZERO = new BlockPos(0, 0, 0);
-    private static final int PACKED_X_LENGTH = 1 + Mth.log2(Mth.smallestEncompassingPowerOfTwo(30000000));
-    private static final int PACKED_Z_LENGTH = PACKED_X_LENGTH;
-    public static final int PACKED_Y_LENGTH = 64 - PACKED_X_LENGTH - PACKED_Z_LENGTH;
-    private static final long PACKED_X_MASK = (1L << PACKED_X_LENGTH) - 1L;
-    private static final long PACKED_Y_MASK = (1L << PACKED_Y_LENGTH) - 1L;
-    private static final long PACKED_Z_MASK = (1L << PACKED_Z_LENGTH) - 1L;
-    private static final int Y_OFFSET = 0;
-    private static final int Z_OFFSET = PACKED_Y_LENGTH;
-    private static final int X_OFFSET = PACKED_Y_LENGTH + PACKED_Z_LENGTH;
+    // Paper start - static constants
+    private static final int PACKED_X_LENGTH = 26;
+    private static final int PACKED_Z_LENGTH = 26;
+    public static final int PACKED_Y_LENGTH = 12;
+    private static final long PACKED_X_MASK = 67108863;
+    private static final long PACKED_Y_MASK = 4095;
+    private static final long PACKED_Z_MASK = 67108863;
+    private static final int Z_OFFSET = 12;
+    private static final int X_OFFSET = 38;
+    // Paper end
 
     public BlockPos(int x, int y, int z) {
         super(x, y, z);
@@ -60,28 +61,29 @@
         this(pos.getX(), pos.getY(), pos.getZ());
     }
 
+    public static long getAdjacent(int baseX, int baseY, int baseZ, Direction enumdirection) { return asLong(baseX + enumdirection.getStepX(), baseY + enumdirection.getStepY(), baseZ + enumdirection.getStepZ()); } // Paper
     public static long offset(long value, Direction direction) {
         return offset(value, direction.getStepX(), direction.getStepY(), direction.getStepZ());
     }
 
     public static long offset(long value, int x, int y, int z) {
-        return asLong(getX(value) + x, getY(value) + y, getZ(value) + z);
+        return asLong((int) (value >> 38) + x, (int) ((value << 52) >> 52) + y, (int) ((value << 26) >> 38) + z); // Paper - simplify/inline
     }
 
     public static int getX(long packedPos) {
-        return (int)(packedPos << 64 - X_OFFSET - PACKED_X_LENGTH >> 64 - PACKED_X_LENGTH);
+        return (int) (packedPos >> 38); // Paper - simplify/inline
     }
 
     public static int getY(long packedPos) {
-        return (int)(packedPos << 64 - PACKED_Y_LENGTH >> 64 - PACKED_Y_LENGTH);
+        return (int) ((packedPos << 52) >> 52); // Paper - simplify/inline
     }
 
     public static int getZ(long packedPos) {
-        return (int)(packedPos << 64 - Z_OFFSET - PACKED_Z_LENGTH >> 64 - PACKED_Z_LENGTH);
+        return (int) ((packedPos << 26) >> 38);  // Paper - simplify/inline
     }
 
     public static BlockPos of(long packedPos) {
-        return new BlockPos(getX(packedPos), getY(packedPos), getZ(packedPos));
+        return new BlockPos((int) (packedPos >> 38), (int) ((packedPos << 52) >> 52), (int) ((packedPos << 26) >> 38)); // Paper - simplify/inline
     }
 
     public long asLong() {
@@ -89,32 +91,34 @@
     }
 
     public static long asLong(int x, int y, int z) {
-        long l = 0L;
-        l = l | ((long)x & PACKED_X_MASK) << X_OFFSET;
-        l = l | ((long)y & PACKED_Y_MASK) << 0;
-        return l | ((long)z & PACKED_Z_MASK) << Z_OFFSET;
+        return (((long) x & (long) 67108863) << 38) | (((long) y & (long) 4095)) | (((long) z & (long) 67108863) << 12); // Paper - inline constants and simplify
     }
 
     public static long getFlatIndex(long y) {
         return y & -16L;
     }
 
+    @Override
     public BlockPos offset(double d, double e, double f) {
         return d == 0.0D && e == 0.0D && f == 0.0D ? this : new BlockPos((double)this.getX() + d, (double)this.getY() + e, (double)this.getZ() + f);
     }
 
+    @Override
     public BlockPos offset(int i, int j, int k) {
         return i == 0 && j == 0 && k == 0 ? this : new BlockPos(this.getX() + i, this.getY() + j, this.getZ() + k);
     }
 
+    @Override
     public BlockPos offset(Vec3i vec3i) {
         return this.offset(vec3i.getX(), vec3i.getY(), vec3i.getZ());
     }
 
+    @Override
     public BlockPos subtract(Vec3i vec3i) {
         return this.offset(-vec3i.getX(), -vec3i.getY(), -vec3i.getZ());
     }
 
+    @Override
     public BlockPos multiply(int i) {
         if (i == 1) {
             return this;
@@ -123,62 +127,94 @@
         }
     }
 
+    @Override
     public BlockPos above() {
-        return this.relative(Direction.UP);
+        return new BlockPos(this.getX(), this.getY() + 1, this.getZ()); // Paper - Optimize BlockPosition
     }
 
+    @Override
     public BlockPos above(int distance) {
-        return this.relative(Direction.UP, distance);
+        return distance == 0 ? this : new BlockPos(this.getX(), this.getY() + distance, this.getZ()); // Paper - Optimize BlockPosition
     }
 
+    @Override
     public BlockPos below() {
-        return this.relative(Direction.DOWN);
+        return new BlockPos(this.getX(), this.getY() - 1, this.getZ()); // Paper - Optimize BlockPosition
     }
 
+    @Override
     public BlockPos below(int i) {
-        return this.relative(Direction.DOWN, i);
+        return i == 0 ? this : new BlockPos(this.getX(), this.getY() - i, this.getZ()); // Paper - Optimize BlockPosition
     }
 
+    @Override
     public BlockPos north() {
-        return this.relative(Direction.NORTH);
+        return new BlockPos(this.getX(), this.getY(), this.getZ() - 1); // Paper - Optimize BlockPosition
     }
 
+    @Override
     public BlockPos north(int distance) {
-        return this.relative(Direction.NORTH, distance);
+        return distance == 0 ? this : new BlockPos(this.getX(), this.getY(), this.getZ() - distance); // Paper - Optimize BlockPosition
     }
 
+    @Override
     public BlockPos south() {
-        return this.relative(Direction.SOUTH);
+        return new BlockPos(this.getX(), this.getY(), this.getZ() + 1); // Paper - Optimize BlockPosition
     }
 
+    @Override
     public BlockPos south(int distance) {
-        return this.relative(Direction.SOUTH, distance);
+        return distance == 0 ? this : new BlockPos(this.getX(), this.getY(), this.getZ() + distance); // Paper - Optimize BlockPosition
     }
 
+    @Override
     public BlockPos west() {
-        return this.relative(Direction.WEST);
+        return new BlockPos(this.getX() - 1, this.getY(), this.getZ()); // Paper - Optimize BlockPosition
     }
 
+    @Override
     public BlockPos west(int distance) {
-        return this.relative(Direction.WEST, distance);
+        return distance == 0 ? this : new BlockPos(this.getX() - distance, this.getY(), this.getZ()); // Paper - Optimize BlockPosition
     }
 
+    @Override
     public BlockPos east() {
-        return this.relative(Direction.EAST);
+        return new BlockPos(this.getX() + 1, this.getY(), this.getZ()); // Paper - Optimize BlockPosition
     }
 
+    @Override
     public BlockPos east(int distance) {
-        return this.relative(Direction.EAST, distance);
+        return distance == 0 ? this : new BlockPos(this.getX() + distance, this.getY(), this.getZ()); // Paper - Optimize BlockPosition
     }
 
+    @Override
     public BlockPos relative(Direction direction) {
+        // Paper Start - Optimize BlockPosition
+        switch(direction) {
+            case UP:
+                return new BlockPos(this.getX(), this.getY() + 1, this.getZ());
+            case DOWN:
+                return new BlockPos(this.getX(), this.getY() - 1, this.getZ());
+            case NORTH:
+                return new BlockPos(this.getX(), this.getY(), this.getZ() - 1);
+            case SOUTH:
+                return new BlockPos(this.getX(), this.getY(), this.getZ() + 1);
+            case WEST:
+                return new BlockPos(this.getX() - 1, this.getY(), this.getZ());
+            case EAST:
+                return new BlockPos(this.getX() + 1, this.getY(), this.getZ());
+            default:
         return new BlockPos(this.getX() + direction.getStepX(), this.getY() + direction.getStepY(), this.getZ() + direction.getStepZ());
+        }
+        // Paper End
     }
 
+    @Override
     public BlockPos relative(Direction direction, int i) {
         return i == 0 ? this : new BlockPos(this.getX() + direction.getStepX() * i, this.getY() + direction.getStepY() * i, this.getZ() + direction.getStepZ() * i);
     }
 
+    @Override
     public BlockPos relative(Direction.Axis axis, int i) {
         if (i == 0) {
             return this;
@@ -204,6 +240,7 @@
         }
     }
 
+    @Override
     public BlockPos cross(Vec3i pos) {
         return new BlockPos(this.getY() * pos.getZ() - this.getZ() * pos.getY(), this.getZ() * pos.getX() - this.getX() * pos.getZ(), this.getX() * pos.getY() - this.getY() * pos.getX());
     }
@@ -233,6 +270,7 @@
                 final BlockPos.MutableBlockPos nextPos = new BlockPos.MutableBlockPos();
                 int counter = count;
 
+                @Override
                 protected BlockPos computeNext() {
                     if (this.counter <= 0) {
                         return this.endOfData();
@@ -248,9 +286,11 @@
 
     public static Iterable<BlockPos> withinManhattan(BlockPos center, int rangeX, int rangeY, int rangeZ) {
         int i = rangeX + rangeY + rangeZ;
-        int j = center.getX();
-        int k = center.getY();
-        int l = center.getZ();
+        // Paper start - rename variables to fix conflict with anonymous class (remap fix)
+        int centerX = center.getX();
+        int centerY = center.getY();
+        int centerZ = center.getZ();
+        // Paper end
         return () -> {
             return new AbstractIterator<BlockPos>() {
                 private final BlockPos.MutableBlockPos cursor = new BlockPos.MutableBlockPos();
@@ -261,10 +301,11 @@
                 private int y;
                 private boolean zMirror;
 
+                @Override
                 protected BlockPos computeNext() {
                     if (this.zMirror) {
                         this.zMirror = false;
-                        this.cursor.setZ(l - (this.cursor.getZ() - l));
+                        this.cursor.setZ(centerZ - (this.cursor.getZ() - centerZ)); // Paper - remap fix
                         return this.cursor;
                     } else {
                         BlockPos blockPos;
@@ -290,7 +331,7 @@
                             int k = this.currentDepth - Math.abs(i) - Math.abs(j);
                             if (k <= rangeZ) {
                                 this.zMirror = k != 0;
-                                blockPos = this.cursor.set(j + i, k + j, l + k);
+                                blockPos = this.cursor.set(centerX + i, centerY + j, centerZ + k); // Paper - remap fix
                             }
                         }
 
@@ -339,16 +380,17 @@
                 private final BlockPos.MutableBlockPos cursor = new BlockPos.MutableBlockPos();
                 private int index;
 
+                @Override
                 protected BlockPos computeNext() {
                     if (this.index == l) {
                         return this.endOfData();
                     } else {
-                        int i = this.index % i;
-                        int j = this.index / i;
-                        int k = j % j;
-                        int l = j / j;
+                        int offsetX = this.index % i; // Paper - decomp fix
+                        int u = this.index / i; // Paper - decomp fix
+                        int offsetY = u % j; // Paper - decomp fix
+                        int offsetZ = u / j; // Paper - decomp fix
                         ++this.index;
-                        return this.cursor.set(startX + i, startY + k, startZ + l);
+                        return this.cursor.set(startX + offsetX, startY + offsetY, startZ + offsetZ); // Paper - decomp fix
                     }
                 }
             };
@@ -369,6 +411,7 @@
                 private int lastY = this.cursor.getY();
                 private int lastZ = this.cursor.getZ();
 
+                @Override
                 protected BlockPos.MutableBlockPos computeNext() {
                     this.cursor.set(this.lastX, this.lastY, this.lastZ).move(this.directions[(this.leg + 4) % 4]);
                     this.lastX = this.cursor.getX();
@@ -404,26 +447,32 @@
             this(Mth.floor(x), Mth.floor(y), Mth.floor(z));
         }
 
+        @Override
         public BlockPos offset(double d, double e, double f) {
             return super.offset(d, e, f).immutable();
         }
 
+        @Override
         public BlockPos offset(int i, int j, int k) {
             return super.offset(i, j, k).immutable();
         }
 
+        @Override
         public BlockPos multiply(int i) {
             return super.multiply(i).immutable();
         }
 
+        @Override
         public BlockPos relative(Direction direction, int i) {
             return super.relative(direction, i).immutable();
         }
 
+        @Override
         public BlockPos relative(Direction.Axis axis, int i) {
             return super.relative(axis, i).immutable();
         }
 
+        @Override
         public BlockPos rotate(Rotation rotation) {
             return super.rotate(rotation).immutable();
         }
@@ -492,21 +541,27 @@
             }
         }
 
+        // Paper start - comment out useless overrides @Override - TODO figure out why this is suddenly important to keep
+        @Override
         public BlockPos.MutableBlockPos setX(int i) {
             super.setX(i);
             return this;
         }
 
+        @Override
         public BlockPos.MutableBlockPos setY(int i) {
             super.setY(i);
             return this;
         }
 
+        @Override
         public BlockPos.MutableBlockPos setZ(int i) {
             super.setZ(i);
             return this;
         }
+        // Paper end
 
+        @Override
         public BlockPos immutable() {
             return new BlockPos(this);
         }
