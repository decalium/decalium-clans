--- a/net/minecraft/world/level/chunk/storage/SectionStorage.java
+++ b/net/minecraft/world/level/chunk/storage/SectionStorage.java
@@ -30,12 +30,12 @@
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
-public class SectionStorage<R> implements AutoCloseable {
+public class SectionStorage<R> extends RegionFileStorage implements AutoCloseable { // Paper - nuke IOWorker
     private static final Logger LOGGER = LogManager.getLogger();
     private static final String SECTIONS_TAG = "Sections";
-    private final IOWorker worker;
+    // Paper - remove mojang I/O thread
     private final Long2ObjectMap<Optional<R>> storage = new Long2ObjectOpenHashMap<>();
-    private final LongLinkedOpenHashSet dirty = new LongLinkedOpenHashSet();
+    public final LongLinkedOpenHashSet dirty = new LongLinkedOpenHashSet();
     private final Function<Runnable, Codec<R>> codec;
     private final Function<Runnable, R> factory;
     private final DataFixer fixerUpper;
@@ -43,12 +43,13 @@
     protected final LevelHeightAccessor levelHeightAccessor;
 
     public SectionStorage(File directory, Function<Runnable, Codec<R>> codecFactory, Function<Runnable, R> factory, DataFixer dataFixer, DataFixTypes dataFixTypes, boolean dsync, LevelHeightAccessor world) {
+        super(directory, dsync); // Paper - nuke IOWorker
         this.codec = codecFactory;
         this.factory = factory;
         this.fixerUpper = dataFixer;
         this.type = dataFixTypes;
         this.levelHeightAccessor = world;
-        this.worker = new IOWorker(directory, dsync, directory.getName());
+        // Paper - remove mojang I/O thread
     }
 
     protected void tick(BooleanSupplier shouldKeepTicking) {
@@ -106,13 +107,18 @@
     }
 
     private void readColumn(ChunkPos chunkPos) {
-        this.readColumn(chunkPos, NbtOps.INSTANCE, this.tryRead(chunkPos));
+        // Paper start - expose function to load in data
+       this.loadInData(chunkPos, this.tryRead(chunkPos));
+    }
+    public void loadInData(ChunkPos chunkPos, CompoundTag compound) {
+        this.readColumn(chunkPos, NbtOps.INSTANCE, compound);
+        // Paper end - expose function to load in data
     }
 
     @Nullable
     private CompoundTag tryRead(ChunkPos pos) {
         try {
-            return this.worker.load(pos);
+            return this.read(pos); // Paper - nuke IOWorker
         } catch (IOException var3) {
             LOGGER.error("Error reading chunk {} data from disk", pos, var3);
             return null;
@@ -156,13 +162,26 @@
         Dynamic<Tag> dynamic = this.writeColumn(chunkPos, NbtOps.INSTANCE);
         Tag tag = dynamic.getValue();
         if (tag instanceof CompoundTag) {
-            this.worker.store(chunkPos, (CompoundTag)tag);
+            try { this.write(chunkPos, (CompoundTag)tag); } catch (IOException ioexception) { SectionStorage.LOGGER.error("Error writing data to disk", ioexception); } // Paper - nuke IOWorker
         } else {
             LOGGER.error("Expected compound tag, got {}", (Object)tag);
         }
 
     }
 
+    // Paper start - internal get data function, copied from above
+    private CompoundTag getDataInternal(ChunkPos chunkcoordintpair) {
+        Dynamic<Tag> dynamic = this.writeColumn(chunkcoordintpair, NbtOps.INSTANCE);
+        Tag nbtbase = (Tag) dynamic.getValue();
+
+        if (nbtbase instanceof CompoundTag) {
+            return (CompoundTag)nbtbase;
+        } else {
+            SectionStorage.LOGGER.error("Expected compound tag, got {}", nbtbase);
+        }
+        return null;
+    }
+    // Paper end
     private <T> Dynamic<T> writeColumn(ChunkPos chunkPos, DynamicOps<T> dynamicOps) {
         Map<T, T> map = Maps.newHashMap();
 
@@ -217,7 +236,25 @@
 
     }
 
+    @Override
     public void close() throws IOException {
-        this.worker.close();
+        //this.worker.close(); // Paper - nuke I/O worker
+    }
+
+    // Paper start - get data function
+    public CompoundTag getData(ChunkPos chunkcoordintpair) {
+        // Note: Copied from above
+        // This is checking if the data needs to be written, then it builds it later in getDataInternal(ChunkCoordIntPair)
+        if (!this.dirty.isEmpty()) {
+            for (int i = this.levelHeightAccessor.getMinSection(); i < this.levelHeightAccessor.getMaxSection(); ++i) {
+                long j = SectionPos.of(chunkcoordintpair, i).asLong();
+
+                if (this.dirty.contains(j)) {
+                    return this.getDataInternal(chunkcoordintpair);
+                }
+            }
+        }
+        return null;
     }
+    // Paper end
 }
