--- a/net/minecraft/Util.java
+++ b/net/minecraft/Util.java
@@ -56,17 +56,17 @@
 import javax.annotation.Nullable;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.Bootstrap;
-import net.minecraft.util.Mth;
+import net.minecraft.server.ServerWorkerThread;
 import net.minecraft.util.datafix.DataFixers;
 import net.minecraft.world.level.block.state.properties.Property;
-import org.apache.commons.io.IOUtils;
+import org.bukkit.craftbukkit.libs.org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class Util {
     private static final AtomicInteger WORKER_COUNT = new AtomicInteger(1);
-    private static final ExecutorService BOOTSTRAP_EXECUTOR = makeExecutor("Bootstrap");
-    private static final ExecutorService BACKGROUND_EXECUTOR = makeExecutor("Main");
+    private static final ExecutorService BOOTSTRAP_EXECUTOR = makeExecutor("Bootstrap", -2); // Paper - add -2 priority
+    private static final ExecutorService BACKGROUND_EXECUTOR = makeExecutor("Main", -1); // Paper - add -1 priority
     private static final ExecutorService IO_POOL = makeIoExecutor();
     public static LongSupplier timeSource = System::nanoTime;
     public static final UUID NIL_UUID = new UUID(0L, 0L);
@@ -94,21 +94,26 @@
     }
 
     public static long getNanos() {
-        return timeSource.getAsLong();
+        return System.nanoTime(); // Paper
     }
 
     public static long getEpochMillis() {
         return Instant.now().toEpochMilli();
     }
 
-    private static ExecutorService makeExecutor(String name) {
-        int i = Mth.clamp(Runtime.getRuntime().availableProcessors() - 1, 1, 7);
+    private static ExecutorService makeExecutor(String s, int priorityModifier) { // Paper - add priority
+        // Paper start - use simpler thread pool that allows 1 thread
+        int i = Math.min(8, Math.max(Runtime.getRuntime().availableProcessors() - 2, 1));
+        i = Integer.getInteger("Paper.WorkerThreadCount", i);
         ExecutorService executorService;
+
         if (i <= 0) {
             executorService = MoreExecutors.newDirectExecutorService();
         } else {
-            executorService = new ForkJoinPool(i, (forkJoinPool) -> {
-                ForkJoinWorkerThread forkJoinWorkerThread = new ForkJoinWorkerThread(forkJoinPool) {
+            executorService = new java.util.concurrent.ThreadPoolExecutor(i, i,0L, TimeUnit.MILLISECONDS, new java.util.concurrent.LinkedBlockingQueue<Runnable>(), target -> new ServerWorkerThread(target, s, priorityModifier));
+        }
+        /*
+                    @Override
                     protected void onTermination(Throwable throwable) {
                         if (throwable != null) {
                             Util.LOGGER.warn("{} died", this.getName(), throwable);
@@ -123,6 +128,7 @@
                 return forkJoinWorkerThread;
             }, Util::onThreadException, true);
         }
+        }*/ // Paper end
 
         return executorService;
     }
@@ -179,7 +185,7 @@
         throw t instanceof RuntimeException ? (RuntimeException)t : new RuntimeException(t);
     }
 
-    private static void onThreadException(Thread thread, Throwable t) {
+    public static void onThreadException(Thread thread, Throwable t) {
         pauseInIde(t);
         if (t instanceof CompletionException) {
             t = t.getCause();
@@ -305,7 +311,7 @@
     }
 
     public static <K> Strategy<K> identityStrategy() {
-        return Util.IdentityStrategy.INSTANCE;
+        return (Strategy<K>) Util.IdentityStrategy.INSTANCE; // Paper - decompile fix
     }
 
     public static <V> CompletableFuture<List<V>> sequence(List<? extends CompletableFuture<? extends V>> futures) {
@@ -415,6 +421,7 @@
 
     private static BooleanSupplier createRenamer(Path src, Path dest) {
         return new BooleanSupplier() {
+            @Override
             public boolean getAsBoolean() {
                 try {
                     Files.move(src, dest);
@@ -425,6 +432,7 @@
                 }
             }
 
+            @Override
             public String toString() {
                 return "rename " + src + " to " + dest;
             }
@@ -433,6 +441,7 @@
 
     private static BooleanSupplier createDeleter(Path path) {
         return new BooleanSupplier() {
+            @Override
             public boolean getAsBoolean() {
                 try {
                     Files.deleteIfExists(path);
@@ -443,6 +452,7 @@
                 }
             }
 
+            @Override
             public String toString() {
                 return "delete old " + path;
             }
@@ -451,10 +461,12 @@
 
     private static BooleanSupplier createFileDeletedCheck(Path path) {
         return new BooleanSupplier() {
+            @Override
             public boolean getAsBoolean() {
                 return !Files.exists(path);
             }
 
+            @Override
             public String toString() {
                 return "verify that " + path + " is deleted";
             }
@@ -463,10 +475,12 @@
 
     private static BooleanSupplier createFileCreatedCheck(Path path) {
         return new BooleanSupplier() {
+            @Override
             public boolean getAsBoolean() {
                 return Files.isRegularFile(path);
             }
 
+            @Override
             public String toString() {
                 return "verify that " + path + " is present";
             }
@@ -560,6 +574,7 @@
 
     public static void startTimerHackThread() {
         Thread thread = new Thread("Timer hack thread") {
+            @Override
             public void run() {
                 while(true) {
                     try {
@@ -592,10 +607,12 @@
         return new Function<T, R>() {
             private final Map<T, R> cache = Maps.newHashMap();
 
+            @Override
             public R apply(T object) {
                 return this.cache.computeIfAbsent(object, function);
             }
 
+            @Override
             public String toString() {
                 return "memoize/1[function=" + function + ", size=" + this.cache.size() + "]";
             }
@@ -606,12 +623,14 @@
         return new BiFunction<T, U, R>() {
             private final Map<Pair<T, U>, R> cache = Maps.newHashMap();
 
+            @Override
             public R apply(T object, U object2) {
                 return this.cache.computeIfAbsent(Pair.of(object, object2), (pair) -> {
                     return biFunction.apply(pair.getFirst(), pair.getSecond());
                 });
             }
 
+            @Override
             public String toString() {
                 return "memoize/2[function=" + biFunction + ", size=" + this.cache.size() + "]";
             }
@@ -621,10 +640,12 @@
     static enum IdentityStrategy implements Strategy<Object> {
         INSTANCE;
 
+        @Override
         public int hashCode(Object object) {
             return System.identityHashCode(object);
         }
 
+        @Override
         public boolean equals(Object object, Object object2) {
             return object == object2;
         }
@@ -634,11 +655,13 @@
         LINUX,
         SOLARIS,
         WINDOWS {
+            @Override
             protected String[] getOpenUrlArguments(URL url) {
                 return new String[]{"rundll32", "url.dll,FileProtocolHandler", url.toString()};
             }
         },
         OSX {
+            @Override
             protected String[] getOpenUrlArguments(URL url) {
                 return new String[]{"open", url.toString()};
             }
