--- a/net/minecraft/world/level/chunk/ChunkGenerator.java
+++ b/net/minecraft/world/level/chunk/ChunkGenerator.java
@@ -2,9 +2,12 @@
 
 import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
+import io.papermc.paper.event.world.StructureLocateEvent; // Paper - Add import due to naming conflict.
 import java.util.BitSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
+import java.util.Objects;
 import java.util.Random;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
@@ -56,12 +59,13 @@
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
 
 public abstract class ChunkGenerator {
-    public static final Codec<ChunkGenerator> CODEC = Registry.CHUNK_GENERATOR.dispatchStable(ChunkGenerator::codec, Function.identity());
+
+    public static final Codec<ChunkGenerator> CODEC;
     protected final BiomeSource biomeSource;
     protected final BiomeSource runtimeBiomeSource;
     private final StructureSettings settings;
     private final long strongholdSeed;
-    private final List<ChunkPos> strongholdPositions = Lists.newArrayList();
+    private final List<ChunkPos> strongholdPositions;
     private final BaseStoneSource defaultBaseStoneSource;
 
     public ChunkGenerator(BiomeSource biomeSource, StructureSettings structuresConfig) {
@@ -69,6 +73,7 @@
     }
 
     public ChunkGenerator(BiomeSource populationSource, BiomeSource biomeSource, StructureSettings structuresConfig, long worldSeed) {
+        this.strongholdPositions = Lists.newArrayList();
         this.biomeSource = populationSource;
         this.runtimeBiomeSource = biomeSource;
         this.settings = structuresConfig;
@@ -78,44 +83,55 @@
 
     private void generateStrongholds() {
         if (this.strongholdPositions.isEmpty()) {
-            StrongholdConfiguration strongholdConfiguration = this.settings.stronghold();
-            if (strongholdConfiguration != null && strongholdConfiguration.count() != 0) {
+            StrongholdConfiguration structuresettingsstronghold = this.settings.stronghold();
+
+            if (structuresettingsstronghold != null && structuresettingsstronghold.count() != 0) {
                 List<Biome> list = Lists.newArrayList();
+                Iterator iterator = this.biomeSource.possibleBiomes().iterator();
 
-                for(Biome biome : this.biomeSource.possibleBiomes()) {
-                    if (biome.getGenerationSettings().isValidStart(StructureFeature.STRONGHOLD)) {
-                        list.add(biome);
+                while (iterator.hasNext()) {
+                    Biome biomebase = (Biome) iterator.next();
+
+                    if (biomebase.getGenerationSettings().isValidStart(StructureFeature.STRONGHOLD)) {
+                        list.add(biomebase);
                     }
                 }
 
-                int i = strongholdConfiguration.distance();
-                int j = strongholdConfiguration.count();
-                int k = strongholdConfiguration.spread();
+                int i = structuresettingsstronghold.distance();
+                int j = structuresettingsstronghold.count();
+                int k = structuresettingsstronghold.spread();
                 Random random = new Random();
+
                 random.setSeed(this.strongholdSeed);
-                double d = random.nextDouble() * Math.PI * 2.0D;
+                double d0 = random.nextDouble() * 3.141592653589793D * 2.0D;
                 int l = 0;
-                int m = 0;
+                int i1 = 0;
 
-                for(int n = 0; n < j; ++n) {
-                    double e = (double)(4 * i + i * m * 6) + (random.nextDouble() - 0.5D) * (double)i * 2.5D;
-                    int o = (int)Math.round(Math.cos(d) * e);
-                    int p = (int)Math.round(Math.sin(d) * e);
-                    BlockPos blockPos = this.biomeSource.findBiomeHorizontal(SectionPos.sectionToBlockCoord(o, 8), 0, SectionPos.sectionToBlockCoord(p, 8), 112, list::contains, random);
-                    if (blockPos != null) {
-                        o = SectionPos.blockToSectionCoord(blockPos.getX());
-                        p = SectionPos.blockToSectionCoord(blockPos.getZ());
+                for (int j1 = 0; j1 < j; ++j1) {
+                    double d1 = (double) (4 * i + i * i1 * 6) + (random.nextDouble() - 0.5D) * (double) i * 2.5D;
+                    int k1 = (int) Math.round(Math.cos(d0) * d1);
+                    int l1 = (int) Math.round(Math.sin(d0) * d1);
+                    BiomeSource worldchunkmanager = this.biomeSource;
+                    int i2 = SectionPos.sectionToBlockCoord(k1, 8);
+                    int j2 = SectionPos.sectionToBlockCoord(l1, 8);
+
+                    Objects.requireNonNull(list);
+                    BlockPos blockposition = worldchunkmanager.findBiomeHorizontal(i2, 0, j2, 112, list::contains, random);
+
+                    if (blockposition != null) {
+                        k1 = SectionPos.blockToSectionCoord(blockposition.getX());
+                        l1 = SectionPos.blockToSectionCoord(blockposition.getZ());
                     }
 
-                    this.strongholdPositions.add(new ChunkPos(o, p));
-                    d += (Math.PI * 2D) / (double)k;
+                    this.strongholdPositions.add(new ChunkPos(k1, l1));
+                    d0 += 6.283185307179586D / (double) k;
                     ++l;
                     if (l == k) {
-                        ++m;
+                        ++i1;
                         l = 0;
-                        k = k + 2 * k / (m + 1);
-                        k = Math.min(k, j - n);
-                        d += random.nextDouble() * Math.PI * 2.0D;
+                        k += 2 * k / (i1 + 1);
+                        k = Math.min(k, j - j1);
+                        d0 += random.nextDouble() * 3.141592653589793D * 2.0D;
                     }
                 }
 
@@ -128,32 +144,35 @@
     public abstract ChunkGenerator withSeed(long seed);
 
     public void createBiomes(Registry<Biome> biomeRegistry, ChunkAccess chunk) {
-        ChunkPos chunkPos = chunk.getPos();
-        ((ProtoChunk)chunk).setBiomes(new ChunkBiomeContainer(biomeRegistry, chunk, chunkPos, this.runtimeBiomeSource));
+        ChunkPos chunkcoordintpair = chunk.getPos();
+
+        ((ProtoChunk) chunk).setBiomes(new ChunkBiomeContainer(biomeRegistry, chunk, chunkcoordintpair, this.runtimeBiomeSource));
     }
 
     public void applyCarvers(long seed, BiomeManager access, ChunkAccess chunk, GenerationStep.Carving carver) {
-        BiomeManager biomeManager = access.withDifferentSource(this.biomeSource);
-        WorldgenRandom worldgenRandom = new WorldgenRandom();
-        int i = 8;
-        ChunkPos chunkPos = chunk.getPos();
-        CarvingContext carvingContext = new CarvingContext(this, chunk);
+        BiomeManager biomemanager1 = access.withDifferentSource(this.biomeSource);
+        WorldgenRandom seededrandom = new WorldgenRandom();
+        boolean flag = true;
+        ChunkPos chunkcoordintpair = chunk.getPos();
+        CarvingContext carvingcontext = new CarvingContext(this, chunk);
         Aquifer aquifer = this.createAquifer(chunk);
-        BitSet bitSet = ((ProtoChunk)chunk).getOrCreateCarvingMask(carver);
+        BitSet bitset = ((ProtoChunk) chunk).getOrCreateCarvingMask(carver);
 
-        for(int j = -8; j <= 8; ++j) {
-            for(int k = -8; k <= 8; ++k) {
-                ChunkPos chunkPos2 = new ChunkPos(chunkPos.x + j, chunkPos.z + k);
-                BiomeGenerationSettings biomeGenerationSettings = this.biomeSource.getNoiseBiome(QuartPos.fromBlock(chunkPos2.getMinBlockX()), 0, QuartPos.fromBlock(chunkPos2.getMinBlockZ())).getGenerationSettings();
-                List<Supplier<ConfiguredWorldCarver<?>>> list = biomeGenerationSettings.getCarvers(carver);
-                ListIterator<Supplier<ConfiguredWorldCarver<?>>> listIterator = list.listIterator();
+        for (int j = -8; j <= 8; ++j) {
+            for (int k = -8; k <= 8; ++k) {
+                ChunkPos chunkcoordintpair1 = new ChunkPos(chunkcoordintpair.x + j, chunkcoordintpair.z + k);
+                BiomeGenerationSettings biomesettingsgeneration = this.biomeSource.getNoiseBiome(QuartPos.fromBlock(chunkcoordintpair1.getMinBlockX()), 0, QuartPos.fromBlock(chunkcoordintpair1.getMinBlockZ())).getGenerationSettings();
+                List<Supplier<ConfiguredWorldCarver<?>>> list = biomesettingsgeneration.getCarvers(carver);
+                ListIterator listiterator = list.listIterator();
 
-                while(listIterator.hasNext()) {
-                    int l = listIterator.nextIndex();
-                    ConfiguredWorldCarver<?> configuredWorldCarver = listIterator.next().get();
-                    worldgenRandom.setLargeFeatureSeed(seed + (long)l, chunkPos2.x, chunkPos2.z);
-                    if (configuredWorldCarver.isStartChunk(worldgenRandom)) {
-                        configuredWorldCarver.carve(carvingContext, chunk, biomeManager::getBiome, worldgenRandom, aquifer, chunkPos2, bitSet);
+                while (listiterator.hasNext()) {
+                    int l = listiterator.nextIndex();
+                    ConfiguredWorldCarver<?> worldgencarverwrapper = (ConfiguredWorldCarver) ((Supplier) listiterator.next()).get();
+
+                    seededrandom.setLargeFeatureSeed(seed + (long) l, chunkcoordintpair1.x, chunkcoordintpair1.z);
+                    if (worldgencarverwrapper.isStartChunk((Random) seededrandom)) {
+                        Objects.requireNonNull(biomemanager1);
+                        worldgencarverwrapper.carve(carvingcontext, chunk, biomemanager1::getBiome, seededrandom, aquifer, chunkcoordintpair1, bitset);
                     }
                 }
             }
@@ -167,55 +186,77 @@
 
     @Nullable
     public BlockPos findNearestMapFeature(ServerLevel world, StructureFeature<?> feature, BlockPos center, int radius, boolean skipExistingChunks) {
+        // Paper start
+        org.bukkit.World world1 = world.getWorld();
+        org.bukkit.Location originLocation = new org.bukkit.Location(world1, center.getX(), center.getY(), center.getZ());
+        StructureLocateEvent event = new StructureLocateEvent(world1, originLocation, org.bukkit.StructureType.getStructureTypes().get(feature.getFeatureName()), radius, skipExistingChunks);
+        if(!event.callEvent()) return null;
+        // If event call set a final location, skip structure finding and just return set result.
+        if(event.getResult() != null) return new BlockPos(event.getResult().getBlockX(), event.getResult().getBlockY(), event.getResult().getBlockZ());
+        // Get origin location (re)defined by event call.
+        center = new BlockPos(event.getOrigin().getBlockX(), event.getOrigin().getBlockY(), event.getOrigin().getBlockZ());
+        // Get world (re)defined by event call.
+        world = ((org.bukkit.craftbukkit.v1_17_R1.CraftWorld) event.getOrigin().getWorld()).getHandle();
+        // Get radius and whether to find unexplored structures (re)defined by event call.
+        radius = event.getRadius();
+        skipExistingChunks = event.shouldFindUnexplored();
+        feature = StructureFeature.STRUCTURES_REGISTRY.get(event.getType().getName());
+        // Paper end
         if (!this.biomeSource.canGenerateStructure(feature)) {
             return null;
         } else if (feature == StructureFeature.STRONGHOLD) {
             this.generateStrongholds();
-            BlockPos blockPos = null;
-            double d = Double.MAX_VALUE;
-            BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
+            BlockPos blockposition1 = null;
+            double d0 = Double.MAX_VALUE;
+            BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
+            Iterator iterator = this.strongholdPositions.iterator();
 
-            for(ChunkPos chunkPos : this.strongholdPositions) {
-                mutableBlockPos.set(SectionPos.sectionToBlockCoord(chunkPos.x, 8), 32, SectionPos.sectionToBlockCoord(chunkPos.z, 8));
-                double e = mutableBlockPos.distSqr(center);
-                if (blockPos == null) {
-                    blockPos = new BlockPos(mutableBlockPos);
-                    d = e;
-                } else if (e < d) {
-                    blockPos = new BlockPos(mutableBlockPos);
-                    d = e;
+            while (iterator.hasNext()) {
+                ChunkPos chunkcoordintpair = (ChunkPos) iterator.next();
+
+                blockposition_mutableblockposition.set(SectionPos.sectionToBlockCoord(chunkcoordintpair.x, 8), 32, SectionPos.sectionToBlockCoord(chunkcoordintpair.z, 8));
+                double d1 = blockposition_mutableblockposition.distSqr(center);
+
+                if (blockposition1 == null) {
+                    blockposition1 = new BlockPos(blockposition_mutableblockposition);
+                    d0 = d1;
+                } else if (d1 < d0) {
+                    blockposition1 = new BlockPos(blockposition_mutableblockposition);
+                    d0 = d1;
                 }
             }
 
-            return blockPos;
+            return blockposition1;
         } else {
-            StructureFeatureConfiguration structureFeatureConfiguration = this.settings.getConfig(feature);
-            return structureFeatureConfiguration == null ? null : feature.getNearestGeneratedFeature(world, world.structureFeatureManager(), center, radius, skipExistingChunks, world.getSeed(), structureFeatureConfiguration);
+            this.updateStructureSettings(world, this.settings); // Spigot
+            StructureFeatureConfiguration structuresettingsfeature = this.settings.getConfig(feature);
+
+            return structuresettingsfeature == null ? null : feature.getNearestGeneratedFeature(world, world.structureFeatureManager(), center, radius, skipExistingChunks, world.getSeed(), structuresettingsfeature);
         }
     }
 
     public void applyBiomeDecoration(WorldGenRegion region, StructureFeatureManager accessor) {
-        ChunkPos chunkPos = region.getCenter();
-        int i = chunkPos.getMinBlockX();
-        int j = chunkPos.getMinBlockZ();
-        BlockPos blockPos = new BlockPos(i, region.getMinBuildHeight(), j);
-        Biome biome = this.biomeSource.getPrimaryBiome(chunkPos);
-        WorldgenRandom worldgenRandom = new WorldgenRandom();
-        long l = worldgenRandom.setDecorationSeed(region.getSeed(), i, j);
+        ChunkPos chunkcoordintpair = region.getCenter();
+        int i = chunkcoordintpair.getMinBlockX();
+        int j = chunkcoordintpair.getMinBlockZ();
+        BlockPos blockposition = new BlockPos(i, region.getMinBuildHeight(), j);
+        Biome biomebase = this.biomeSource.getPrimaryBiome(chunkcoordintpair);
+        WorldgenRandom seededrandom = new WorldgenRandom();
+        long k = seededrandom.setDecorationSeed(region.getSeed(), i, j);
 
         try {
-            biome.generate(accessor, this, region, l, worldgenRandom, blockPos);
-        } catch (Exception var13) {
-            CrashReport crashReport = CrashReport.forThrowable(var13, "Biome decoration");
-            crashReport.addCategory("Generation").setDetail("CenterX", chunkPos.x).setDetail("CenterZ", chunkPos.z).setDetail("Seed", l).setDetail("Biome", biome);
-            throw new ReportedException(crashReport);
+            biomebase.generate(accessor, this, region, k, seededrandom, blockposition);
+        } catch (Exception exception) {
+            CrashReport crashreport = CrashReport.forThrowable(exception, "Biome decoration");
+
+            crashreport.addCategory("Generation").setDetail("CenterX", (Object) chunkcoordintpair.x).setDetail("CenterZ", (Object) chunkcoordintpair.z).setDetail("Seed", (Object) k).setDetail("Biome", (Object) biomebase);
+            throw new ReportedException(crashreport);
         }
     }
 
     public abstract void buildSurfaceAndBedrock(WorldGenRegion region, ChunkAccess chunk);
 
-    public void spawnOriginalMobs(WorldGenRegion region) {
-    }
+    public void spawnOriginalMobs(WorldGenRegion region) {}
 
     public StructureSettings getSettings() {
         return this.settings;
@@ -238,60 +279,157 @@
     }
 
     public void createStructures(RegistryAccess registryManager, StructureFeatureManager accessor, ChunkAccess chunk, StructureManager structureManager, long worldSeed) {
-        Biome biome = this.biomeSource.getPrimaryBiome(chunk.getPos());
-        this.createStructure(StructureFeatures.STRONGHOLD, registryManager, accessor, chunk, structureManager, worldSeed, biome);
+        Biome biomebase = this.biomeSource.getPrimaryBiome(chunk.getPos());
 
-        for(Supplier<ConfiguredStructureFeature<?, ?>> supplier : biome.getGenerationSettings().structures()) {
-            this.createStructure(supplier.get(), registryManager, accessor, chunk, structureManager, worldSeed, biome);
+        this.createStructure(StructureFeatures.STRONGHOLD, registryManager, accessor, chunk, structureManager, worldSeed, biomebase);
+        Iterator iterator = biomebase.getGenerationSettings().structures().iterator();
+
+        while (iterator.hasNext()) {
+            Supplier<ConfiguredStructureFeature<?, ?>> supplier = (Supplier) iterator.next();
+
+            // CraftBukkit start
+            ConfiguredStructureFeature<?, ?> structurefeature = (ConfiguredStructureFeature) supplier.get();
+            if (structurefeature.LIST_CODEC == StructureFeature.STRONGHOLD) {
+                synchronized (structurefeature) {
+                    this.createStructure((ConfiguredStructureFeature) supplier.get(), registryManager, accessor, chunk, structureManager, worldSeed, biomebase);
+                }
+            } else {
+                this.createStructure((ConfiguredStructureFeature) supplier.get(), registryManager, accessor, chunk, structureManager, worldSeed, biomebase);
+            }
+            // CraftBukkit end
         }
 
     }
 
     private void createStructure(ConfiguredStructureFeature<?, ?> feature, RegistryAccess registryManager, StructureFeatureManager accessor, ChunkAccess chunk, StructureManager structureManager, long worldSeed, Biome biome) {
-        ChunkPos chunkPos = chunk.getPos();
-        SectionPos sectionPos = SectionPos.bottomOf(chunk);
-        StructureStart<?> structureStart = accessor.getStartForFeature(sectionPos, feature.feature, chunk);
-        int i = structureStart != null ? structureStart.getReferences() : 0;
-        StructureFeatureConfiguration structureFeatureConfiguration = this.settings.getConfig(feature.feature);
-        if (structureFeatureConfiguration != null) {
-            StructureStart<?> structureStart2 = feature.generate(registryManager, this, this.biomeSource, structureManager, worldSeed, chunkPos, biome, i, structureFeatureConfiguration, chunk);
-            accessor.setStartForFeature(sectionPos, feature.feature, structureStart2, chunk);
+        ChunkPos chunkcoordintpair = chunk.getPos();
+        SectionPos sectionposition = SectionPos.bottomOf(chunk);
+        StructureStart<?> structurestart = accessor.getStartForFeature(sectionposition, feature.feature, chunk);
+        int j = structurestart != null ? structurestart.getReferences() : 0;
+        this.updateStructureSettings(accessor.getWorld(), this.settings); // Spigot
+        StructureFeatureConfiguration structuresettingsfeature = this.settings.getConfig(feature.feature);
+
+        if (structuresettingsfeature != null) {
+            StructureStart<?> structurestart1 = feature.generate(registryManager, this, this.biomeSource, structureManager, worldSeed, chunkcoordintpair, biome, j, structuresettingsfeature, chunk);
+
+            accessor.setStartForFeature(sectionposition, feature.feature, structurestart1, chunk);
         }
 
     }
 
+    // Spigot start
+    private volatile boolean injected;
+    private void updateStructureSettings(net.minecraft.world.level.Level world, StructureSettings settings) {
+        if (this.injected) {
+            return;
+        }
+        synchronized (settings) {
+            if (this.injected) {
+                return;
+            }
+            java.util.Map<StructureFeature<?>, StructureFeatureConfiguration> original = settings.structureConfig();
+            java.util.Map<StructureFeature<?>, StructureFeatureConfiguration> updated = new java.util.HashMap<>();
+            org.spigotmc.SpigotWorldConfig conf = world.spigotConfig;
+
+            for (java.util.Map.Entry<StructureFeature<?>, StructureFeatureConfiguration> entry : original.entrySet()) {
+                String name = Registry.STRUCTURE_FEATURE.getKey(entry.getKey()).getPath();
+                StructureFeatureConfiguration feature = entry.getValue();
+                int seed = feature.salt();
+
+                switch (name) {
+                    case "bastion_remnant":
+                        seed = conf.bastionSeed;
+                        break;
+                    case "desert_pyramid":
+                        seed = conf.desertSeed;
+                        break;
+                    case "endcity":
+                        seed = conf.endCitySeed;
+                        break;
+                    case "fortress":
+                        seed = conf.fortressSeed;
+                        break;
+                    case "igloo":
+                        seed = conf.iglooSeed;
+                        break;
+                    case "jungle_pyramid":
+                        seed = conf.jungleSeed;
+                        break;
+                    case "mansion":
+                        seed = conf.mansionSeed;
+                        break;
+                    case "monument":
+                        seed = conf.monumentSeed;
+                        break;
+                    case "nether_fossil":
+                        seed = conf.fossilSeed;
+                        break;
+                    case "ocean_ruin":
+                        seed = conf.oceanSeed;
+                        break;
+                    case "pillager_outpost":
+                        seed = conf.outpostSeed;
+                        break;
+                    case "ruined_portal":
+                        seed = conf.portalSeed;
+                        break;
+                    case "shipwreck":
+                        seed = conf.shipwreckSeed;
+                        break;
+                    case "swamp_hut":
+                        seed = conf.swampSeed;
+                        break;
+                    case "village":
+                        seed = conf.villageSeed;
+                        break;
+                }
+
+                updated.put(entry.getKey(), new StructureFeatureConfiguration(feature.spacing(), feature.separation(), seed));
+            }
+
+            original.clear();
+            original.putAll(updated);
+            this.injected = true;
+        }
+    }
+    // Spigot end
+
     public void createReferences(WorldGenLevel world, StructureFeatureManager accessor, ChunkAccess chunk) {
-        int i = 8;
-        ChunkPos chunkPos = chunk.getPos();
-        int j = chunkPos.x;
-        int k = chunkPos.z;
-        int l = chunkPos.getMinBlockX();
-        int m = chunkPos.getMinBlockZ();
-        SectionPos sectionPos = SectionPos.bottomOf(chunk);
+        boolean flag = true;
+        ChunkPos chunkcoordintpair = chunk.getPos();
+        int i = chunkcoordintpair.x;
+        int j = chunkcoordintpair.z;
+        int k = chunkcoordintpair.getMinBlockX();
+        int l = chunkcoordintpair.getMinBlockZ();
+        SectionPos sectionposition = SectionPos.bottomOf(chunk);
 
-        for(int n = j - 8; n <= j + 8; ++n) {
-            for(int o = k - 8; o <= k + 8; ++o) {
-                long p = ChunkPos.asLong(n, o);
+        for (int i1 = i - 8; i1 <= i + 8; ++i1) {
+            for (int j1 = j - 8; j1 <= j + 8; ++j1) {
+                long k1 = ChunkPos.asLong(i1, j1);
+                Iterator iterator = world.getChunk(i1, j1).getAllStarts().values().iterator();
+
+                while (iterator.hasNext()) {
+                    StructureStart structurestart = (StructureStart) iterator.next();
 
-                for(StructureStart<?> structureStart : world.getChunk(n, o).getAllStarts().values()) {
                     try {
-                        if (structureStart.isValid() && structureStart.getBoundingBox().intersects(l, m, l + 15, m + 15)) {
-                            accessor.addReferenceForFeature(sectionPos, structureStart.getFeature(), p, chunk);
-                            DebugPackets.sendStructurePacket(world, structureStart);
+                        if (structurestart.isValid() && structurestart.getBoundingBox().intersects(k, l, k + 15, l + 15)) {
+                            accessor.addReferenceForFeature(sectionposition, structurestart.getFeature(), k1, chunk);
+                            DebugPackets.sendStructurePacket(world, structurestart);
                         }
-                    } catch (Exception var20) {
-                        CrashReport crashReport = CrashReport.forThrowable(var20, "Generating structure reference");
-                        CrashReportCategory crashReportCategory = crashReport.addCategory("Structure");
-                        crashReportCategory.setDetail("Id", () -> {
-                            return Registry.STRUCTURE_FEATURE.getKey(structureStart.getFeature()).toString();
+                    } catch (Exception exception) {
+                        CrashReport crashreport = CrashReport.forThrowable(exception, "Generating structure reference");
+                        CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Structure");
+
+                        crashreportsystemdetails.setDetail("Id", () -> {
+                            return Registry.STRUCTURE_FEATURE.getKey(structurestart.getFeature()).toString();
                         });
-                        crashReportCategory.setDetail("Name", () -> {
-                            return structureStart.getFeature().getFeatureName();
+                        crashreportsystemdetails.setDetail("Name", () -> {
+                            return structurestart.getFeature().getFeatureName();
                         });
-                        crashReportCategory.setDetail("Class", () -> {
-                            return structureStart.getFeature().getClass().getCanonicalName();
+                        crashreportsystemdetails.setDetail("Class", () -> {
+                            return structurestart.getFeature().getClass().getCanonicalName();
                         });
-                        throw new ReportedException(crashReport);
+                        throw new ReportedException(crashreport);
                     }
                 }
             }
@@ -331,8 +469,11 @@
     }
 
     static {
+        // CraftBukkit start - decompile errors
         Registry.register(Registry.CHUNK_GENERATOR, "noise", NoiseBasedChunkGenerator.CODEC);
         Registry.register(Registry.CHUNK_GENERATOR, "flat", FlatLevelSource.CODEC);
         Registry.register(Registry.CHUNK_GENERATOR, "debug", DebugLevelSource.CODEC);
+        // CraftBukkit end
+        CODEC = Registry.CHUNK_GENERATOR.dispatchStable(ChunkGenerator::codec, Function.identity());
     }
 }
