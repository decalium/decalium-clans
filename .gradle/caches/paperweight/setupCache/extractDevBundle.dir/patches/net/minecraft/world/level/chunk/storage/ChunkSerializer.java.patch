--- a/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
+++ b/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
@@ -1,30 +1,41 @@
 package net.minecraft.world.level.chunk.storage;
 
+
+import co.aikar.timings.Timings;
 import com.google.common.collect.Maps;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.shorts.ShortList;
+import it.unimi.dsi.fastutil.shorts.ShortListIterator;
 import java.util.Arrays;
 import java.util.BitSet;
 import java.util.EnumSet;
+import java.util.Iterator;
+import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.function.Function;
 import javax.annotation.Nullable;
 import net.minecraft.SharedConstants;
 import net.minecraft.core.BlockPos;
+import net.minecraft.core.DefaultedRegistry;
 import net.minecraft.core.Registry;
 import net.minecraft.core.SectionPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.ListTag;
 import net.minecraft.nbt.LongArrayTag;
 import net.minecraft.nbt.ShortTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.server.level.ServerChunkCache;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ThreadedLevelLightEngine;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.ai.village.poi.PoiManager;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.ChunkTickList;
+import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LightLayer;
 import net.minecraft.world.level.TickList;
 import net.minecraft.world.level.biome.BiomeSource;
@@ -33,7 +44,6 @@
 import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.ChunkBiomeContainer;
 import net.minecraft.world.level.chunk.ChunkGenerator;
-import net.minecraft.world.level.chunk.ChunkSource;
 import net.minecraft.world.level.chunk.ChunkStatus;
 import net.minecraft.world.level.chunk.DataLayer;
 import net.minecraft.world.level.chunk.ImposterProtoChunk;
@@ -54,293 +64,583 @@
 import org.apache.logging.log4j.Logger;
 
 public class ChunkSerializer {
+
     private static final Logger LOGGER = LogManager.getLogger();
     public static final String TAG_UPGRADE_DATA = "UpgradeData";
 
+    public ChunkSerializer() {}
+
+    // Paper start - guard against serializing mismatching coordinates
+    // TODO Note: This needs to be re-checked each update
+    public static ChunkPos getChunkCoordinate(CompoundTag chunkData) {
+        CompoundTag levelData = chunkData.getCompound("Level");
+        return new ChunkPos(levelData.getInt("xPos"), levelData.getInt("zPos"));
+    }
+    // Paper end
+    // Paper start
+    public static final class InProgressChunkHolder {
+
+        public final ProtoChunk protoChunk;
+        public final java.util.ArrayDeque<Runnable> tasks;
+
+        public CompoundTag poiData;
+
+        public InProgressChunkHolder(final ProtoChunk protoChunk, final java.util.ArrayDeque<Runnable> tasks) {
+            this.protoChunk = protoChunk;
+            this.tasks = tasks;
+        }
+    }
+    // Paper end
+
     public static ProtoChunk read(ServerLevel world, StructureManager structureManager, PoiManager poiStorage, ChunkPos pos, CompoundTag nbt) {
-        ChunkGenerator chunkGenerator = world.getChunkSource().getGenerator();
-        BiomeSource biomeSource = chunkGenerator.getBiomeSource();
-        CompoundTag compoundTag = nbt.getCompound("Level");
-        ChunkPos chunkPos = new ChunkPos(compoundTag.getInt("xPos"), compoundTag.getInt("zPos"));
-        if (!Objects.equals(pos, chunkPos)) {
-            LOGGER.error("Chunk file at {} is in the wrong location; relocating. (Expected {}, got {})", pos, pos, chunkPos);
+        // Paper start - add variant for async calls
+        InProgressChunkHolder holder = loadChunk(world, structureManager, poiStorage, pos, nbt, true);
+        holder.tasks.forEach(Runnable::run);
+        return holder.protoChunk;
+    }
+
+    // Paper start
+    private static final int CURRENT_DATA_VERSION = SharedConstants.getCurrentVersion().getWorldVersion();
+    private static final boolean JUST_CORRUPT_IT = Boolean.getBoolean("Paper.ignoreWorldDataVersion");
+    // Paper end
+
+    public static InProgressChunkHolder loadChunk(ServerLevel world, StructureManager structureManager, PoiManager poiStorage, ChunkPos pos, CompoundTag nbt, boolean distinguish) {
+        java.util.ArrayDeque<Runnable> tasksToExecuteOnMain = new java.util.ArrayDeque<>();
+        // Paper end
+        ChunkGenerator chunkgenerator = world.getChunkSource().getGenerator();
+        // Paper start - Do NOT attempt to load chunks saved with newer versions
+        if (nbt.contains("DataVersion", 99)) {
+            int dataVersion = nbt.getInt("DataVersion");
+            if (!JUST_CORRUPT_IT && dataVersion > CURRENT_DATA_VERSION) {
+                new RuntimeException("Server attempted to load chunk saved with newer version of minecraft! " + dataVersion + " > " + CURRENT_DATA_VERSION).printStackTrace();
+                System.exit(1);
+            }
         }
+        // Paper end
+        BiomeSource worldchunkmanager = chunkgenerator.getBiomeSource();
+        CompoundTag nbttagcompound1 = nbt.getCompound("Level"); // Paper - diff on change, see ChunkSerializer#getChunkCoordinate
+        ChunkPos chunkcoordintpair1 = new ChunkPos(nbttagcompound1.getInt("xPos"), nbttagcompound1.getInt("zPos")); // Paper - diff on change, see ChunkSerializer#getChunkCoordinate
 
-        ChunkBiomeContainer chunkBiomeContainer = new ChunkBiomeContainer(world.registryAccess().registryOrThrow(Registry.BIOME_REGISTRY), world, pos, biomeSource, compoundTag.contains("Biomes", 11) ? compoundTag.getIntArray("Biomes") : null);
-        UpgradeData upgradeData = compoundTag.contains("UpgradeData", 10) ? new UpgradeData(compoundTag.getCompound("UpgradeData"), world) : UpgradeData.EMPTY;
-        ProtoTickList<Block> protoTickList = new ProtoTickList<>((block) -> {
+        if (!Objects.equals(pos, chunkcoordintpair1)) {
+            ChunkSerializer.LOGGER.error("Chunk file at {} is in the wrong location; relocating. (Expected {}, got {})", pos, pos, chunkcoordintpair1);
+        }
+
+        ChunkBiomeContainer biomestorage = new ChunkBiomeContainer(world.registryAccess().registryOrThrow(Registry.BIOME_REGISTRY), world, pos, worldchunkmanager, nbttagcompound1.contains("Biomes", 11) ? nbttagcompound1.getIntArray("Biomes") : null);
+        UpgradeData chunkconverter = nbttagcompound1.contains("UpgradeData", 10) ? new UpgradeData(nbttagcompound1.getCompound("UpgradeData"), world) : UpgradeData.EMPTY;
+        ProtoTickList<Block> protochunkticklist = new ProtoTickList<>((block) -> {
             return block == null || block.defaultBlockState().isAir();
-        }, pos, compoundTag.getList("ToBeTicked", 9), world);
-        ProtoTickList<Fluid> protoTickList2 = new ProtoTickList<>((fluid) -> {
-            return fluid == null || fluid == Fluids.EMPTY;
-        }, pos, compoundTag.getList("LiquidsToBeTicked", 9), world);
-        boolean bl = compoundTag.getBoolean("isLightOn");
-        ListTag listTag = compoundTag.getList("Sections", 10);
+        }, pos, nbttagcompound1.getList("ToBeTicked", 9), world);
+        ProtoTickList<Fluid> protochunkticklist1 = new ProtoTickList<>((fluidtype) -> {
+            return fluidtype == null || fluidtype == Fluids.EMPTY;
+        }, pos, nbttagcompound1.getList("LiquidsToBeTicked", 9), world);
+        boolean flag = nbttagcompound1.getBoolean("isLightOn");
+        ListTag nbttaglist = nbttagcompound1.getList("Sections", 10);
         int i = world.getSectionsCount();
-        LevelChunkSection[] levelChunkSections = new LevelChunkSection[i];
-        boolean bl2 = world.dimensionType().hasSkyLight();
-        ChunkSource chunkSource = world.getChunkSource();
-        LevelLightEngine levelLightEngine = chunkSource.getLightEngine();
-        if (bl) {
-            levelLightEngine.retainData(pos, true);
+        LevelChunkSection[] achunksection = new LevelChunkSection[i];
+        boolean flag1 = world.dimensionType().hasSkyLight();
+        ServerChunkCache chunkproviderserver = world.getChunkSource();
+        LevelLightEngine lightengine = chunkproviderserver.getLightEngine();
+
+        if (flag) {
+            tasksToExecuteOnMain.add(() -> { // Paper - delay this task since we're executing off-main
+            lightengine.retainData(pos, true);
+            }); // Paper - delay this task since we're executing off-main
         }
 
-        for(int j = 0; j < listTag.size(); ++j) {
-            CompoundTag compoundTag2 = listTag.getCompound(j);
-            int k = compoundTag2.getByte("Y");
-            if (compoundTag2.contains("Palette", 9) && compoundTag2.contains("BlockStates", 12)) {
-                LevelChunkSection levelChunkSection = new LevelChunkSection(k);
-                levelChunkSection.getStates().read(compoundTag2.getList("Palette", 10), compoundTag2.getLongArray("BlockStates"));
-                levelChunkSection.recalcBlockCounts();
-                if (!levelChunkSection.isEmpty()) {
-                    levelChunkSections[world.getSectionIndexFromSectionY(k)] = levelChunkSection;
+        for (int j = 0; j < nbttaglist.size(); ++j) {
+            CompoundTag nbttagcompound2 = nbttaglist.getCompound(j);
+            byte b0 = nbttagcompound2.getByte("Y");
+
+            if (nbttagcompound2.contains("Palette", 9) && nbttagcompound2.contains("BlockStates", 12)) {
+                LevelChunkSection chunksection = new LevelChunkSection(b0, null, world, false); // Paper - Anti-Xray - Add parameters and don't initialize because it's done in the line below internally
+
+                chunksection.getStates().read(nbttagcompound2.getList("Palette", 10), nbttagcompound2.getLongArray("BlockStates"));
+                chunksection.recalcBlockCounts();
+                if (!chunksection.isEmpty()) {
+                    achunksection[world.getSectionIndexFromSectionY(b0)] = chunksection;
                 }
 
-                poiStorage.checkConsistencyWithBlocks(pos, levelChunkSection);
+                tasksToExecuteOnMain.add(() -> { // Paper - delay this task since we're executing off-main
+                poiStorage.checkConsistencyWithBlocks(pos, chunksection);
+                }); // Paper - delay this task since we're executing off-main
             }
 
-            if (bl) {
-                if (compoundTag2.contains("BlockLight", 7)) {
-                    levelLightEngine.queueSectionData(LightLayer.BLOCK, SectionPos.of(pos, k), new DataLayer(compoundTag2.getByteArray("BlockLight")), true);
+            if (flag) {
+                if (nbttagcompound2.contains("BlockLight", 7)) {
+                    // Paper start - delay this task since we're executing off-main
+                    DataLayer blockLight = new DataLayer(nbttagcompound2.getByteArray("BlockLight"));
+                    tasksToExecuteOnMain.add(() -> {
+                        lightengine.queueSectionData(LightLayer.BLOCK, SectionPos.of(chunkcoordintpair1, b0), blockLight, true);
+                    });
+                    // Paper end - delay this task since we're executing off-main
                 }
 
-                if (bl2 && compoundTag2.contains("SkyLight", 7)) {
-                    levelLightEngine.queueSectionData(LightLayer.SKY, SectionPos.of(pos, k), new DataLayer(compoundTag2.getByteArray("SkyLight")), true);
+                if (flag1 && nbttagcompound2.contains("SkyLight", 7)) {
+                    // Paper start - delay this task since we're executing off-main
+                    DataLayer skyLight = new DataLayer(nbttagcompound2.getByteArray("SkyLight"));
+                    tasksToExecuteOnMain.add(() -> {
+                        lightengine.queueSectionData(LightLayer.SKY, SectionPos.of(chunkcoordintpair1, b0), skyLight, true);
+                    });
+                    // Paper end - delay this task since we're executing off-main
                 }
             }
         }
 
-        long l = compoundTag.getLong("InhabitedTime");
-        ChunkStatus.ChunkType chunkType = getChunkTypeFromTag(nbt);
-        ChunkAccess chunkAccess;
-        if (chunkType == ChunkStatus.ChunkType.LEVELCHUNK) {
-            TickList<Block> tickList;
-            if (compoundTag.contains("TileTicks", 9)) {
-                tickList = ChunkTickList.create(compoundTag.getList("TileTicks", 10), Registry.BLOCK::getKey, Registry.BLOCK::get);
+        long k = nbttagcompound1.getLong("InhabitedTime");
+        ChunkStatus.ChunkType chunkstatus_type = ChunkSerializer.getChunkTypeFromTag(nbt);
+        Object object;
+
+        if (chunkstatus_type == ChunkStatus.ChunkType.LEVELCHUNK) {
+            ListTag nbttaglist1;
+            DefaultedRegistry registryblocks;
+            Function function;
+            DefaultedRegistry registryblocks1;
+            Object object1;
+
+            if (nbttagcompound1.contains("TileTicks", 9)) {
+                nbttaglist1 = nbttagcompound1.getList("TileTicks", 10);
+                registryblocks = Registry.BLOCK;
+                Objects.requireNonNull(registryblocks);
+                function = registryblocks::getKey;
+                registryblocks1 = Registry.BLOCK;
+                Objects.requireNonNull(registryblocks1);
+                object1 = ChunkTickList.create(nbttaglist1, function, registryblocks1::get);
             } else {
-                tickList = protoTickList;
+                object1 = protochunkticklist;
             }
 
-            TickList<Fluid> tickList3;
-            if (compoundTag.contains("LiquidTicks", 9)) {
-                tickList3 = ChunkTickList.create(compoundTag.getList("LiquidTicks", 10), Registry.FLUID::getKey, Registry.FLUID::get);
+            Object object2;
+
+            if (nbttagcompound1.contains("LiquidTicks", 9)) {
+                nbttaglist1 = nbttagcompound1.getList("LiquidTicks", 10);
+                registryblocks = Registry.FLUID;
+                Objects.requireNonNull(registryblocks);
+                function = registryblocks::getKey;
+                registryblocks1 = Registry.FLUID;
+                Objects.requireNonNull(registryblocks1);
+                object2 = ChunkTickList.create(nbttaglist1, function, registryblocks1::get);
             } else {
-                tickList3 = protoTickList2;
+                object2 = protochunkticklist1;
             }
 
-            chunkAccess = new LevelChunk(world.getLevel(), pos, chunkBiomeContainer, upgradeData, tickList, tickList3, l, levelChunkSections, (levelChunk) -> {
-                postLoadChunk(world, compoundTag, levelChunk);
-            });
+            object = new LevelChunk(world.getLevel(), pos, biomestorage, chunkconverter, (TickList) object1, (TickList) object2, k, achunksection, // Paper start - fix massive nbt memory leak due to lambda. move lambda into a container method to not leak scope. Only clone needed NBT keys.
+                createLoadEntitiesConsumer(new SafeNBTCopy(nbttagcompound1, "TileEntities", "Entities", "ChunkBukkitValues")) // Paper - move CB Chunk PDC into here
+            );// Paper end
         } else {
-            ProtoChunk protoChunk = new ProtoChunk(pos, upgradeData, levelChunkSections, protoTickList, protoTickList2, world);
-            protoChunk.setBiomes(chunkBiomeContainer);
-            chunkAccess = protoChunk;
-            protoChunk.setInhabitedTime(l);
-            protoChunk.setStatus(ChunkStatus.byName(compoundTag.getString("Status")));
-            if (protoChunk.getStatus().isOrAfter(ChunkStatus.FEATURES)) {
-                protoChunk.setLightEngine(levelLightEngine);
+            ProtoChunk protochunk = new ProtoChunk(pos, chunkconverter, achunksection, protochunkticklist, protochunkticklist1, world, world); // Paper - add level
+
+            protochunk.setBiomes(biomestorage);
+            object = protochunk;
+            protochunk.setInhabitedTime(k);
+            protochunk.setStatus(ChunkStatus.byName(nbttagcompound1.getString("Status")));
+            if (protochunk.getStatus().isOrAfter(ChunkStatus.FEATURES)) {
+                protochunk.setLightEngine(lightengine);
             }
 
-            if (!bl && protoChunk.getStatus().isOrAfter(ChunkStatus.LIGHT)) {
-                for(BlockPos blockPos : BlockPos.betweenClosed(pos.getMinBlockX(), world.getMinBuildHeight(), pos.getMinBlockZ(), pos.getMaxBlockX(), world.getMaxBuildHeight() - 1, pos.getMaxBlockZ())) {
-                    if (chunkAccess.getBlockState(blockPos).getLightEmission() != 0) {
-                        protoChunk.addLight(blockPos);
+            if (!flag && protochunk.getStatus().isOrAfter(ChunkStatus.LIGHT)) {
+                Iterator iterator = BlockPos.betweenClosed(pos.getMinBlockX(), world.getMinBuildHeight(), pos.getMinBlockZ(), pos.getMaxBlockX(), world.getMaxBuildHeight() - 1, pos.getMaxBlockZ()).iterator();
+
+                while (iterator.hasNext()) {
+                    BlockPos blockposition = (BlockPos) iterator.next();
+
+                    if (((ChunkAccess) object).getBlockState(blockposition).getLightEmission() != 0) {
+                        protochunk.addLight(blockposition);
                     }
                 }
             }
         }
 
-        chunkAccess.setLightCorrect(bl);
-        CompoundTag compoundTag3 = compoundTag.getCompound("Heightmaps");
-        EnumSet<Heightmap.Types> enumSet = EnumSet.noneOf(Heightmap.Types.class);
+        ((ChunkAccess) object).setLightCorrect(flag);
+        CompoundTag nbttagcompound3 = nbttagcompound1.getCompound("Heightmaps");
+        EnumSet<Heightmap.Types> enumset = EnumSet.noneOf(Heightmap.Types.class);
+        Iterator iterator1 = ((ChunkAccess) object).getStatus().heightmapsAfter().iterator();
 
-        for(Heightmap.Types types : chunkAccess.getStatus().heightmapsAfter()) {
-            String string = types.getSerializationKey();
-            if (compoundTag3.contains(string, 12)) {
-                chunkAccess.setHeightmap(types, compoundTag3.getLongArray(string));
+        while (iterator1.hasNext()) {
+            Heightmap.Types heightmap_type = (Heightmap.Types) iterator1.next();
+            String s = heightmap_type.getSerializationKey();
+
+            if (nbttagcompound3.contains(s, 12)) {
+                ((ChunkAccess) object).setHeightmap(heightmap_type, nbttagcompound3.getLongArray(s));
             } else {
-                enumSet.add(types);
+                enumset.add(heightmap_type);
             }
         }
 
-        Heightmap.primeHeightmaps(chunkAccess, enumSet);
-        CompoundTag compoundTag4 = compoundTag.getCompound("Structures");
-        chunkAccess.setAllStarts(unpackStructureStart(world, compoundTag4, world.getSeed()));
-        chunkAccess.setAllReferences(unpackStructureReferences(pos, compoundTag4));
-        if (compoundTag.getBoolean("shouldSave")) {
-            chunkAccess.setUnsaved(true);
+        Heightmap.primeHeightmaps((ChunkAccess) object, enumset);
+        CompoundTag nbttagcompound4 = nbttagcompound1.getCompound("Structures");
+
+        ((ChunkAccess) object).setAllStarts(ChunkSerializer.unpackStructureStart(world, nbttagcompound4, world.getSeed()));
+        ((ChunkAccess) object).setAllReferences(ChunkSerializer.unpackStructureReferences(pos, nbttagcompound4));
+        if (nbttagcompound1.getBoolean("shouldSave")) {
+            ((ChunkAccess) object).setUnsaved(true);
         }
 
-        ListTag listTag2 = compoundTag.getList("PostProcessing", 9);
+        ListTag nbttaglist2 = nbttagcompound1.getList("PostProcessing", 9);
 
-        for(int m = 0; m < listTag2.size(); ++m) {
-            ListTag listTag3 = listTag2.getList(m);
+        ListTag nbttaglist3;
+        int l;
 
-            for(int n = 0; n < listTag3.size(); ++n) {
-                chunkAccess.addPackedPostProcess(listTag3.getShort(n), m);
+        for (int i1 = 0; i1 < nbttaglist2.size(); ++i1) {
+            nbttaglist3 = nbttaglist2.getList(i1);
+
+            for (l = 0; l < nbttaglist3.size(); ++l) {
+                ((ChunkAccess) object).addPackedPostProcess(nbttaglist3.getShort(l), i1);
             }
         }
 
-        if (chunkType == ChunkStatus.ChunkType.LEVELCHUNK) {
-            return new ImposterProtoChunk((LevelChunk)chunkAccess);
+        if (chunkstatus_type == ChunkStatus.ChunkType.LEVELCHUNK) {
+            return new InProgressChunkHolder(new ImposterProtoChunk((LevelChunk) object), tasksToExecuteOnMain); // Paper - Async chunk loading
         } else {
-            ProtoChunk protoChunk2 = (ProtoChunk)chunkAccess;
-            ListTag listTag4 = compoundTag.getList("Entities", 10);
+            ProtoChunk protochunk1 = (ProtoChunk) object;
 
-            for(int o = 0; o < listTag4.size(); ++o) {
-                protoChunk2.addEntity(listTag4.getCompound(o));
+            nbttaglist3 = nbttagcompound1.getList("Entities", 10);
+
+            for (l = 0; l < nbttaglist3.size(); ++l) {
+                protochunk1.addEntity(nbttaglist3.getCompound(l));
             }
 
-            ListTag listTag5 = compoundTag.getList("TileEntities", 10);
+            ListTag nbttaglist4 = nbttagcompound1.getList("TileEntities", 10);
 
-            for(int p = 0; p < listTag5.size(); ++p) {
-                CompoundTag compoundTag5 = listTag5.getCompound(p);
-                chunkAccess.setBlockEntityNbt(compoundTag5);
+            CompoundTag nbttagcompound5;
+
+            for (int j1 = 0; j1 < nbttaglist4.size(); ++j1) {
+                nbttagcompound5 = nbttaglist4.getCompound(j1);
+                ((ChunkAccess) object).setBlockEntityNbt(nbttagcompound5);
             }
 
-            ListTag listTag6 = compoundTag.getList("Lights", 9);
+            ListTag nbttaglist5 = nbttagcompound1.getList("Lights", 9);
 
-            for(int q = 0; q < listTag6.size(); ++q) {
-                ListTag listTag7 = listTag6.getList(q);
+            for (int k1 = 0; k1 < nbttaglist5.size(); ++k1) {
+                ListTag nbttaglist6 = nbttaglist5.getList(k1);
 
-                for(int r = 0; r < listTag7.size(); ++r) {
-                    protoChunk2.addLight(listTag7.getShort(r), q);
+                for (int l1 = 0; l1 < nbttaglist6.size(); ++l1) {
+                    protochunk1.addLight(nbttaglist6.getShort(l1), k1);
                 }
             }
 
-            CompoundTag compoundTag6 = compoundTag.getCompound("CarvingMasks");
+            nbttagcompound5 = nbttagcompound1.getCompound("CarvingMasks");
+            Iterator iterator2 = nbttagcompound5.getAllKeys().iterator();
 
-            for(String string2 : compoundTag6.getAllKeys()) {
-                GenerationStep.Carving carving = GenerationStep.Carving.valueOf(string2);
-                protoChunk2.setCarvingMask(carving, BitSet.valueOf(compoundTag6.getByteArray(string2)));
+            while (iterator2.hasNext()) {
+                String s1 = (String) iterator2.next();
+                GenerationStep.Carving worldgenstage_features = GenerationStep.Carving.valueOf(s1);
+
+                protochunk1.setCarvingMask(worldgenstage_features, BitSet.valueOf(nbttagcompound5.getByteArray(s1)));
             }
 
-            return protoChunk2;
+            return new InProgressChunkHolder(protochunk1, tasksToExecuteOnMain); // Paper - Async chunk loading
         }
     }
+    // Paper start
 
-    public static CompoundTag write(ServerLevel world, ChunkAccess chunk) {
+    /**
+     * This wrapper will error out if any key is accessed that wasn't copied so we can catch it easy on an update
+     */
+    private static class SafeNBTCopy extends CompoundTag {
+        private final java.util.Set<String> keys = new java.util.HashSet<String>();
+        public SafeNBTCopy(CompoundTag base, String... keys) {
+            for (String key : keys) {
+                this.keys.add(key);
+                final Tag nbtBase = base.get(key);
+                if (nbtBase != null) {
+                    this.put(key, nbtBase);
+                }
+            }
+        }
+
+        @Override
+        public boolean contains(String key) {
+            if (super.contains(key)) {
+                return true;
+            } else if (keys.contains(key)) {
+                return false;
+            }
+            throw new IllegalStateException("Missing Key " + key + " in SafeNBTCopy");
+        }
+
+        @Override
+        public boolean contains(String key, int type) {
+            return contains(key) && super.contains(key, type);
+        }
+    }
+    private static java.util.function.Consumer<LevelChunk> createLoadEntitiesConsumer(CompoundTag nbt) {
+        return (chunk) -> {
+            postLoadChunk(chunk.level, nbt, chunk);
+            // CraftBukkit start - load chunk persistent data from nbt
+            Tag persistentBase = nbt.get("ChunkBukkitValues");
+            if (persistentBase instanceof CompoundTag) {
+                chunk.persistentDataContainer.putAll((CompoundTag) persistentBase);
+            }
+            // CraftBukkit end
+        };
+    }
+    // Paper end
+
+    // Paper start - async chunk save for unload
+    public static final class AsyncSaveData {
+        public final DataLayer[] blockLight;
+        public final DataLayer[] skyLight;
+
+        public final ListTag blockTickList; // non-null if we had to go to the server's tick list
+        public final ListTag fluidTickList; // non-null if we had to go to the server's tick list
+        public final ListTag blockEntities;
+
+        public final long worldTime;
+
+        public AsyncSaveData(DataLayer[] blockLight, DataLayer[] skyLight,
+                             ListTag blockTickList, ListTag fluidTickList, ListTag blockEntities, long worldTime) {
+            this.blockLight = blockLight;
+            this.skyLight = skyLight;
+            this.blockTickList = blockTickList;
+            this.fluidTickList = fluidTickList;
+            this.blockEntities = blockEntities;
+            this.worldTime = worldTime;
+        }
+    }
+
+    // must be called sync
+    public static AsyncSaveData getAsyncSaveData(ServerLevel world, ChunkAccess chunk) {
+        org.spigotmc.AsyncCatcher.catchOp("preparation of chunk data for async save");
         ChunkPos chunkPos = chunk.getPos();
-        CompoundTag compoundTag = new CompoundTag();
-        CompoundTag compoundTag2 = new CompoundTag();
-        compoundTag.putInt("DataVersion", SharedConstants.getCurrentVersion().getWorldVersion());
-        compoundTag.put("Level", compoundTag2);
-        compoundTag2.putInt("xPos", chunkPos.x);
-        compoundTag2.putInt("zPos", chunkPos.z);
-        compoundTag2.putLong("LastUpdate", world.getGameTime());
-        compoundTag2.putLong("InhabitedTime", chunk.getInhabitedTime());
-        compoundTag2.putString("Status", chunk.getStatus().getName());
-        UpgradeData upgradeData = chunk.getUpgradeData();
-        if (!upgradeData.isEmpty()) {
-            compoundTag2.put("UpgradeData", upgradeData.write());
+
+        ThreadedLevelLightEngine lightenginethreaded = world.getChunkSource().getLightEngine();
+
+        DataLayer[] blockLight = new DataLayer[lightenginethreaded.getMaxLightSection() - lightenginethreaded.getMinLightSection()];
+        DataLayer[] skyLight = new DataLayer[lightenginethreaded.getMaxLightSection() - lightenginethreaded.getMinLightSection()];
+
+        for (int i = lightenginethreaded.getMinLightSection(); i < lightenginethreaded.getMaxLightSection(); ++i) {
+            DataLayer blockArray = lightenginethreaded.getLayerListener(LightLayer.BLOCK).getDataLayerData(SectionPos.of(chunkPos, i));
+            DataLayer skyArray = lightenginethreaded.getLayerListener(LightLayer.SKY).getDataLayerData(SectionPos.of(chunkPos, i));
+
+            // copy data for safety
+            if (blockArray != null) {
+                blockArray = blockArray.copy();
+            }
+            if (skyArray != null) {
+                skyArray = skyArray.copy();
+            }
+
+            blockLight[i - lightenginethreaded.getMinLightSection()] = blockArray;
+            skyLight[i - lightenginethreaded.getMinLightSection()] = skyArray;
         }
 
-        LevelChunkSection[] levelChunkSections = chunk.getSections();
-        ListTag listTag = new ListTag();
-        LevelLightEngine levelLightEngine = world.getChunkSource().getLightEngine();
-        boolean bl = chunk.isLightCorrect();
+        TickList<Block> blockTickList = chunk.getBlockTicks();
 
-        for(int i = levelLightEngine.getMinLightSection(); i < levelLightEngine.getMaxLightSection(); ++i) {
-            int j = i;
-            LevelChunkSection levelChunkSection = Arrays.stream(levelChunkSections).filter((chunkSection) -> {
-                return chunkSection != null && SectionPos.blockToSectionCoord(chunkSection.bottomBlockY()) == j;
+        ListTag blockTickListSerialized;
+        if (blockTickList instanceof ProtoTickList || blockTickList instanceof ChunkTickList) {
+            blockTickListSerialized = null;
+        } else {
+            blockTickListSerialized = world.getBlockTicks().save(chunkPos);
+        }
+
+        TickList<Fluid> fluidTickList = chunk.getLiquidTicks();
+
+        ListTag fluidTickListSerialized;
+        if (fluidTickList instanceof ProtoTickList || fluidTickList instanceof ChunkTickList) {
+            fluidTickListSerialized = null;
+        } else {
+            fluidTickListSerialized = world.getLiquidTicks().save(chunkPos);
+        }
+
+        ListTag blockEntitiesSerialized = new ListTag();
+        for (final BlockPos blockPos : chunk.getBlockEntitiesPos()) {
+            final CompoundTag blockEntityNbt = chunk.getBlockEntityNbtForSaving(blockPos);
+            if (blockEntityNbt != null) {
+                blockEntitiesSerialized.add(blockEntityNbt);
+            }
+        }
+
+        return new AsyncSaveData(blockLight, skyLight, blockTickListSerialized, fluidTickListSerialized, blockEntitiesSerialized, world.getGameTime());
+    }
+
+    public static CompoundTag write(ServerLevel world, ChunkAccess chunk) {
+        return saveChunk(world, chunk, null);
+    }
+    public static CompoundTag saveChunk(ServerLevel world, ChunkAccess chunk, AsyncSaveData asyncsavedata) {
+        // Paper end
+        ChunkPos chunkcoordintpair = chunk.getPos();
+        CompoundTag nbttagcompound = new CompoundTag();
+        CompoundTag nbttagcompound1 = new CompoundTag();
+
+        nbttagcompound.putInt("DataVersion", SharedConstants.getCurrentVersion().getWorldVersion());
+        nbttagcompound.put("Level", nbttagcompound1);
+        nbttagcompound1.putInt("xPos", chunkcoordintpair.x);
+        nbttagcompound1.putInt("zPos", chunkcoordintpair.z);
+        nbttagcompound1.putLong("LastUpdate", asyncsavedata != null ? asyncsavedata.worldTime : world.getGameTime()); // Paper - async chunk unloading
+        nbttagcompound1.putLong("InhabitedTime", chunk.getInhabitedTime());
+        nbttagcompound1.putString("Status", chunk.getStatus().getName());
+        UpgradeData chunkconverter = chunk.getUpgradeData();
+
+        if (!chunkconverter.isEmpty()) {
+            nbttagcompound1.put("UpgradeData", chunkconverter.write());
+        }
+
+        LevelChunkSection[] achunksection = chunk.getSections();
+        ListTag nbttaglist = new ListTag();
+        ThreadedLevelLightEngine lightenginethreaded = world.getChunkSource().getLightEngine();
+        boolean flag = chunk.isLightCorrect();
+
+        for (int i = lightenginethreaded.getMinLightSection(); i < lightenginethreaded.getMaxLightSection(); ++i) {
+            int finalI = i; // CraftBukkit - decompile errors
+            LevelChunkSection chunksection = (LevelChunkSection) Arrays.stream(achunksection).filter((chunksection1) -> {
+                return chunksection1 != null && SectionPos.blockToSectionCoord(chunksection1.bottomBlockY()) == finalI; // CraftBukkit - decompile errors
             }).findFirst().orElse(LevelChunk.EMPTY_SECTION);
-            DataLayer dataLayer = levelLightEngine.getLayerListener(LightLayer.BLOCK).getDataLayerData(SectionPos.of(chunkPos, j));
-            DataLayer dataLayer2 = levelLightEngine.getLayerListener(LightLayer.SKY).getDataLayerData(SectionPos.of(chunkPos, j));
-            if (levelChunkSection != LevelChunk.EMPTY_SECTION || dataLayer != null || dataLayer2 != null) {
-                CompoundTag compoundTag3 = new CompoundTag();
-                compoundTag3.putByte("Y", (byte)(j & 255));
-                if (levelChunkSection != LevelChunk.EMPTY_SECTION) {
-                    levelChunkSection.getStates().write(compoundTag3, "Palette", "BlockStates");
+            // Paper start - async chunk save for unload
+            DataLayer nibblearray; // block light
+            DataLayer nibblearray1; // sky light
+            if (asyncsavedata == null) {
+                nibblearray = lightenginethreaded.getLayerListener(LightLayer.BLOCK).getDataLayerData(SectionPos.of(chunkcoordintpair, i)); /// Paper - diff on method change (see getAsyncSaveData)
+                nibblearray1 = lightenginethreaded.getLayerListener(LightLayer.SKY).getDataLayerData(SectionPos.of(chunkcoordintpair, i)); // Paper - diff on method change (see getAsyncSaveData)
+            } else {
+                nibblearray = asyncsavedata.blockLight[i - lightenginethreaded.getMinLightSection()];
+                nibblearray1 = asyncsavedata.skyLight[i - lightenginethreaded.getMinLightSection()];
+            }
+            // Paper end
+            if (chunksection != LevelChunk.EMPTY_SECTION || nibblearray != null || nibblearray1 != null) {
+                CompoundTag nbttagcompound2 = new CompoundTag();
+
+                nbttagcompound2.putByte("Y", (byte) (i & 255));
+                if (chunksection != LevelChunk.EMPTY_SECTION) {
+                    chunksection.getStates().write(nbttagcompound2, "Palette", "BlockStates");
                 }
 
-                if (dataLayer != null && !dataLayer.isEmpty()) {
-                    compoundTag3.putByteArray("BlockLight", dataLayer.getData());
+                if (nibblearray != null && !nibblearray.isEmpty()) {
+                    nbttagcompound2.putByteArray("BlockLight", nibblearray.asBytesPoolSafe().clone()); // Paper
                 }
 
-                if (dataLayer2 != null && !dataLayer2.isEmpty()) {
-                    compoundTag3.putByteArray("SkyLight", dataLayer2.getData());
+                if (nibblearray1 != null && !nibblearray1.isEmpty()) {
+                    nbttagcompound2.putByteArray("SkyLight", nibblearray1.asBytesPoolSafe().clone()); // Paper
                 }
 
-                listTag.add(compoundTag3);
+                nbttaglist.add(nbttagcompound2);
             }
         }
 
-        compoundTag2.put("Sections", listTag);
-        if (bl) {
-            compoundTag2.putBoolean("isLightOn", true);
+        nbttagcompound1.put("Sections", nbttaglist);
+        if (flag) {
+            nbttagcompound1.putBoolean("isLightOn", true);
         }
 
-        ChunkBiomeContainer chunkBiomeContainer = chunk.getBiomes();
-        if (chunkBiomeContainer != null) {
-            compoundTag2.putIntArray("Biomes", chunkBiomeContainer.writeBiomes());
+        ChunkBiomeContainer biomestorage = chunk.getBiomes();
+
+        if (biomestorage != null) {
+            nbttagcompound1.putIntArray("Biomes", biomestorage.writeBiomes());
         }
 
-        ListTag listTag2 = new ListTag();
+        // Paper start
+        ListTag nbttaglist1;
+        Iterator<BlockPos> iterator;
+        if (asyncsavedata != null) {
+            nbttaglist1 = asyncsavedata.blockEntities;
+            iterator = java.util.Collections.emptyIterator();
+        } else {
+            nbttaglist1 = new ListTag();
+            iterator = chunk.getBlockEntitiesPos().iterator();
+        }
+        // Paper end
 
-        for(BlockPos blockPos : chunk.getBlockEntitiesPos()) {
-            CompoundTag compoundTag4 = chunk.getBlockEntityNbtForSaving(blockPos);
-            if (compoundTag4 != null) {
-                listTag2.add(compoundTag4);
+        CompoundTag nbttagcompound3;
+
+        while (iterator.hasNext()) {
+            BlockPos blockposition = (BlockPos) iterator.next();
+
+            nbttagcompound3 = chunk.getBlockEntityNbtForSaving(blockposition);
+            if (nbttagcompound3 != null) {
+                nbttaglist1.add(nbttagcompound3);
             }
         }
 
-        compoundTag2.put("TileEntities", listTag2);
+        nbttagcompound1.put("TileEntities", nbttaglist1);
         if (chunk.getStatus().getChunkType() == ChunkStatus.ChunkType.PROTOCHUNK) {
-            ProtoChunk protoChunk = (ProtoChunk)chunk;
-            ListTag listTag3 = new ListTag();
-            listTag3.addAll(protoChunk.getEntities());
-            compoundTag2.put("Entities", listTag3);
-            compoundTag2.put("Lights", packOffsets(protoChunk.getPackedLights()));
-            CompoundTag compoundTag5 = new CompoundTag();
+            ProtoChunk protochunk = (ProtoChunk) chunk;
+            ListTag nbttaglist2 = new ListTag();
 
-            for(GenerationStep.Carving carving : GenerationStep.Carving.values()) {
-                BitSet bitSet = protoChunk.getCarvingMask(carving);
-                if (bitSet != null) {
-                    compoundTag5.putByteArray(carving.toString(), bitSet.toByteArray());
+            nbttaglist2.addAll(protochunk.getEntities());
+            nbttagcompound1.put("Entities", nbttaglist2);
+            nbttagcompound1.put("Lights", ChunkSerializer.packOffsets(protochunk.getPackedLights()));
+            nbttagcompound3 = new CompoundTag();
+            GenerationStep.Carving[] aworldgenstage_features = GenerationStep.Carving.values();
+            int j = aworldgenstage_features.length;
+
+            for (int k = 0; k < j; ++k) {
+                GenerationStep.Carving worldgenstage_features = aworldgenstage_features[k];
+                BitSet bitset = protochunk.getCarvingMask(worldgenstage_features);
+
+                if (bitset != null) {
+                    nbttagcompound3.putByteArray(worldgenstage_features.toString(), bitset.toByteArray());
                 }
             }
 
-            compoundTag2.put("CarvingMasks", compoundTag5);
+            nbttagcompound1.put("CarvingMasks", nbttagcompound3);
         }
 
-        TickList<Block> tickList = chunk.getBlockTicks();
-        if (tickList instanceof ProtoTickList) {
-            compoundTag2.put("ToBeTicked", ((ProtoTickList)tickList).save());
-        } else if (tickList instanceof ChunkTickList) {
-            compoundTag2.put("TileTicks", ((ChunkTickList)tickList).save());
+        TickList<Block> ticklist = chunk.getBlockTicks();
+
+        if (ticklist instanceof ProtoTickList) {
+            nbttagcompound1.put("ToBeTicked", ((ProtoTickList) ticklist).save());
+        } else if (ticklist instanceof ChunkTickList) {
+            nbttagcompound1.put("TileTicks", ((ChunkTickList) ticklist).save());
+            // Paper start - async chunk save for unload
+        } else if (asyncsavedata != null) {
+            nbttagcompound1.put("TileTicks", asyncsavedata.blockTickList);
+            // Paper end
         } else {
-            compoundTag2.put("TileTicks", world.getBlockTicks().save(chunkPos));
+            nbttagcompound1.put("TileTicks", world.getBlockTicks().save(chunkcoordintpair));
         }
 
-        TickList<Fluid> tickList2 = chunk.getLiquidTicks();
-        if (tickList2 instanceof ProtoTickList) {
-            compoundTag2.put("LiquidsToBeTicked", ((ProtoTickList)tickList2).save());
-        } else if (tickList2 instanceof ChunkTickList) {
-            compoundTag2.put("LiquidTicks", ((ChunkTickList)tickList2).save());
+        TickList<Fluid> ticklist1 = chunk.getLiquidTicks();
+
+        if (ticklist1 instanceof ProtoTickList) {
+            nbttagcompound1.put("LiquidsToBeTicked", ((ProtoTickList) ticklist1).save());
+        } else if (ticklist1 instanceof ChunkTickList) {
+            nbttagcompound1.put("LiquidTicks", ((ChunkTickList) ticklist1).save());
+            // Paper start - async chunk save for unload
+        } else if (asyncsavedata != null) {
+            nbttagcompound1.put("LiquidTicks", asyncsavedata.fluidTickList);
+            // Paper end
         } else {
-            compoundTag2.put("LiquidTicks", world.getLiquidTicks().save(chunkPos));
+            nbttagcompound1.put("LiquidTicks", world.getLiquidTicks().save(chunkcoordintpair));
         }
 
-        compoundTag2.put("PostProcessing", packOffsets(chunk.getPostProcessing()));
-        CompoundTag compoundTag6 = new CompoundTag();
+        nbttagcompound1.put("PostProcessing", ChunkSerializer.packOffsets(chunk.getPostProcessing()));
+        nbttagcompound3 = new CompoundTag();
+        Iterator iterator1 = chunk.getHeightmaps().iterator();
+
+        while (iterator1.hasNext()) {
+            Entry<Heightmap.Types, Heightmap> entry = (Entry) iterator1.next();
 
-        for(Entry<Heightmap.Types, Heightmap> entry : chunk.getHeightmaps()) {
             if (chunk.getStatus().heightmapsAfter().contains(entry.getKey())) {
-                compoundTag6.put(entry.getKey().getSerializationKey(), new LongArrayTag(entry.getValue().getRawData()));
+                nbttagcompound3.put(((Heightmap.Types) entry.getKey()).getSerializationKey(), new LongArrayTag(((Heightmap) entry.getValue()).getRawData()));
             }
         }
 
-        compoundTag2.put("Heightmaps", compoundTag6);
-        compoundTag2.put("Structures", packStructureData(world, chunkPos, chunk.getAllStarts(), chunk.getAllReferences()));
-        return compoundTag;
+        nbttagcompound1.put("Heightmaps", nbttagcompound3);
+        nbttagcompound1.put("Structures", ChunkSerializer.packStructureData(world, chunkcoordintpair, chunk.getAllStarts(), chunk.getAllReferences()));
+        // CraftBukkit start - store chunk persistent data in nbt
+        if (chunk instanceof LevelChunk && !((LevelChunk) chunk).persistentDataContainer.isEmpty()) {
+            nbttagcompound1.put("ChunkBukkitValues", ((LevelChunk) chunk).persistentDataContainer.toTagCompound());
+        }
+        // CraftBukkit end
+        return nbttagcompound;
     }
 
+    // Paper start
+    public static ChunkStatus getStatus(CompoundTag compound) {
+        if (compound == null) {
+            return null;
+        }
+
+        // Note: Copied from below
+        return ChunkStatus.getStatus(compound.getCompound("Level").getString("Status"));
+    }
+    // Paper end
+
     public static ChunkStatus.ChunkType getChunkTypeFromTag(@Nullable CompoundTag nbt) {
         if (nbt != null) {
-            ChunkStatus chunkStatus = ChunkStatus.byName(nbt.getCompound("Level").getString("Status"));
-            if (chunkStatus != null) {
-                return chunkStatus.getChunkType();
+            ChunkStatus chunkstatus = ChunkStatus.byName(nbt.getCompound("Level").getString("Status"));
+
+            if (chunkstatus != null) {
+                return chunkstatus.getChunkType();
             }
         }
 
@@ -348,63 +648,76 @@
     }
 
     private static void postLoadChunk(ServerLevel world, CompoundTag nbt, LevelChunk chunk) {
+        ListTag nbttaglist;
+
         if (nbt.contains("Entities", 9)) {
-            ListTag listTag = nbt.getList("Entities", 10);
-            if (!listTag.isEmpty()) {
-                world.addLegacyChunkEntities(EntityType.loadEntitiesRecursive(listTag, world));
+            nbttaglist = nbt.getList("Entities", 10);
+            if (!nbttaglist.isEmpty()) {
+                world.addLegacyChunkEntities(EntityType.loadEntitiesRecursive((List) nbttaglist, (Level) world));
             }
         }
 
-        ListTag listTag2 = nbt.getList("TileEntities", 10);
+        nbttaglist = nbt.getList("TileEntities", 10);
 
-        for(int i = 0; i < listTag2.size(); ++i) {
-            CompoundTag compoundTag = listTag2.getCompound(i);
-            boolean bl = compoundTag.getBoolean("keepPacked");
-            if (bl) {
-                chunk.setBlockEntityNbt(compoundTag);
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            CompoundTag nbttagcompound1 = nbttaglist.getCompound(i);
+            boolean flag = nbttagcompound1.getBoolean("keepPacked");
+
+            if (flag) {
+                chunk.setBlockEntityNbt(nbttagcompound1);
             } else {
-                BlockPos blockPos = new BlockPos(compoundTag.getInt("x"), compoundTag.getInt("y"), compoundTag.getInt("z"));
-                BlockEntity blockEntity = BlockEntity.loadStatic(blockPos, chunk.getBlockState(blockPos), compoundTag);
-                if (blockEntity != null) {
-                    chunk.setBlockEntity(blockEntity);
+                BlockPos blockposition = new BlockPos(nbttagcompound1.getInt("x"), nbttagcompound1.getInt("y"), nbttagcompound1.getInt("z"));
+                BlockEntity tileentity = BlockEntity.loadStatic(blockposition, chunk.getBlockState(blockposition), nbttagcompound1);
+
+                if (tileentity != null) {
+                    chunk.setBlockEntity(tileentity);
                 }
             }
         }
-
     }
 
-    private static CompoundTag packStructureData(ServerLevel world, ChunkPos chunkPos, Map<StructureFeature<?>, StructureStart<?>> map, Map<StructureFeature<?>, LongSet> map2) {
-        CompoundTag compoundTag = new CompoundTag();
-        CompoundTag compoundTag2 = new CompoundTag();
+    private static CompoundTag packStructureData(ServerLevel world, ChunkPos chunkcoordintpair, Map<StructureFeature<?>, StructureStart<?>> map, Map<StructureFeature<?>, LongSet> map1) {
+        CompoundTag nbttagcompound = new CompoundTag();
+        CompoundTag nbttagcompound1 = new CompoundTag();
+        Iterator iterator = map.entrySet().iterator();
 
-        for(Entry<StructureFeature<?>, StructureStart<?>> entry : map.entrySet()) {
-            compoundTag2.put(entry.getKey().getFeatureName(), entry.getValue().createTag(world, chunkPos));
+        while (iterator.hasNext()) {
+            Entry<StructureFeature<?>, StructureStart<?>> entry = (Entry) iterator.next();
+
+            nbttagcompound1.put(((StructureFeature) entry.getKey()).getFeatureName(), ((StructureStart) entry.getValue()).createTag(world, chunkcoordintpair));
         }
 
-        compoundTag.put("Starts", compoundTag2);
-        CompoundTag compoundTag3 = new CompoundTag();
+        nbttagcompound.put("Starts", nbttagcompound1);
+        CompoundTag nbttagcompound2 = new CompoundTag();
+        Iterator iterator1 = map1.entrySet().iterator();
 
-        for(Entry<StructureFeature<?>, LongSet> entry2 : map2.entrySet()) {
-            compoundTag3.put(entry2.getKey().getFeatureName(), new LongArrayTag(entry2.getValue()));
+        while (iterator1.hasNext()) {
+            Entry<StructureFeature<?>, LongSet> entry1 = (Entry) iterator1.next();
+
+            nbttagcompound2.put(((StructureFeature) entry1.getKey()).getFeatureName(), new LongArrayTag((LongSet) entry1.getValue()));
         }
 
-        compoundTag.put("References", compoundTag3);
-        return compoundTag;
+        nbttagcompound.put("References", nbttagcompound2);
+        return nbttagcompound;
     }
 
-    private static Map<StructureFeature<?>, StructureStart<?>> unpackStructureStart(ServerLevel serverLevel, CompoundTag nbt, long worldSeed) {
+    private static Map<StructureFeature<?>, StructureStart<?>> unpackStructureStart(ServerLevel worldserver, CompoundTag nbt, long worldSeed) {
         Map<StructureFeature<?>, StructureStart<?>> map = Maps.newHashMap();
-        CompoundTag compoundTag = nbt.getCompound("Starts");
+        CompoundTag nbttagcompound1 = nbt.getCompound("Starts");
+        Iterator iterator = nbttagcompound1.getAllKeys().iterator();
 
-        for(String string : compoundTag.getAllKeys()) {
-            String string2 = string.toLowerCase(Locale.ROOT);
-            StructureFeature<?> structureFeature = StructureFeature.STRUCTURES_REGISTRY.get(string2);
-            if (structureFeature == null) {
-                LOGGER.error("Unknown structure start: {}", (Object)string2);
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+            String s1 = s.toLowerCase(Locale.ROOT);
+            StructureFeature<?> structuregenerator = (StructureFeature) StructureFeature.STRUCTURES_REGISTRY.get(s1);
+
+            if (structuregenerator == null) {
+                ChunkSerializer.LOGGER.error("Unknown structure start: {}", s1);
             } else {
-                StructureStart<?> structureStart = StructureFeature.loadStaticStart(serverLevel, compoundTag.getCompound(string), worldSeed);
-                if (structureStart != null) {
-                    map.put(structureFeature, structureStart);
+                StructureStart<?> structurestart = StructureFeature.loadStaticStart(worldserver, nbttagcompound1.getCompound(s), worldSeed);
+
+                if (structurestart != null) {
+                    map.put(structuregenerator, structurestart);
                 }
             }
         }
@@ -414,18 +727,22 @@
 
     private static Map<StructureFeature<?>, LongSet> unpackStructureReferences(ChunkPos pos, CompoundTag nbt) {
         Map<StructureFeature<?>, LongSet> map = Maps.newHashMap();
-        CompoundTag compoundTag = nbt.getCompound("References");
+        CompoundTag nbttagcompound1 = nbt.getCompound("References");
+        Iterator iterator = nbttagcompound1.getAllKeys().iterator();
 
-        for(String string : compoundTag.getAllKeys()) {
-            String string2 = string.toLowerCase(Locale.ROOT);
-            StructureFeature<?> structureFeature = StructureFeature.STRUCTURES_REGISTRY.get(string2);
-            if (structureFeature == null) {
-                LOGGER.warn("Found reference to unknown structure '{}' in chunk {}, discarding", string2, pos);
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+            String s1 = s.toLowerCase(Locale.ROOT);
+            StructureFeature<?> structuregenerator = (StructureFeature) StructureFeature.STRUCTURES_REGISTRY.get(s1);
+
+            if (structuregenerator == null) {
+                ChunkSerializer.LOGGER.warn("Found reference to unknown structure '{}' in chunk {}, discarding", s1, pos);
             } else {
-                map.put(structureFeature, new LongOpenHashSet(Arrays.stream(compoundTag.getLongArray(string)).filter((packedPos) -> {
-                    ChunkPos chunkPos2 = new ChunkPos(packedPos);
-                    if (chunkPos2.getChessboardDistance(pos) > 8) {
-                        LOGGER.warn("Found invalid structure reference [ {} @ {} ] for chunk {}.", string2, chunkPos2, pos);
+                map.put(structuregenerator, new LongOpenHashSet(Arrays.stream(nbttagcompound1.getLongArray(s)).filter((i) -> {
+                    ChunkPos chunkcoordintpair1 = new ChunkPos(i);
+
+                    if (chunkcoordintpair1.getChessboardDistance(pos) > 8) {
+                        ChunkSerializer.LOGGER.warn("Found invalid structure reference [ {} @ {} ] for chunk {}.", s1, chunkcoordintpair1, pos);
                         return false;
                     } else {
                         return true;
@@ -438,19 +755,27 @@
     }
 
     public static ListTag packOffsets(ShortList[] lists) {
-        ListTag listTag = new ListTag();
+        ListTag nbttaglist = new ListTag();
+        ShortList[] ashortlist1 = lists;
+        int i = lists.length;
 
-        for(ShortList shortList : lists) {
-            ListTag listTag2 = new ListTag();
-            if (shortList != null) {
-                for(Short short_ : shortList) {
-                    listTag2.add(ShortTag.valueOf(short_));
+        for (int j = 0; j < i; ++j) {
+            ShortList shortlist = ashortlist1[j];
+            ListTag nbttaglist1 = new ListTag();
+
+            if (shortlist != null) {
+                ShortListIterator shortlistiterator = shortlist.iterator();
+
+                while (shortlistiterator.hasNext()) {
+                    Short oshort = (Short) shortlistiterator.next();
+
+                    nbttaglist1.add(ShortTag.valueOf(oshort));
                 }
             }
 
-            listTag.add(listTag2);
+            nbttaglist.add(nbttaglist1);
         }
 
-        return listTag;
+        return nbttaglist;
     }
 }
