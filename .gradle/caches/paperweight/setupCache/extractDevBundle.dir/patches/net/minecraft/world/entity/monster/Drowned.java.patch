--- a/net/minecraft/world/entity/monster/Drowned.java
+++ b/net/minecraft/world/entity/monster/Drowned.java
@@ -57,8 +57,8 @@
 public class Drowned extends Zombie implements RangedAttackMob {
     public static final float NAUTILUS_SHELL_CHANCE = 0.03F;
     boolean searchingForLand;
-    protected final WaterBoundPathNavigation waterNavigation;
-    protected final GroundPathNavigation groundNavigation;
+    public final WaterBoundPathNavigation waterNavigation;
+    public final GroundPathNavigation groundNavigation;
 
     public Drowned(EntityType<? extends Drowned> type, Level world) {
         super(type, world);
@@ -69,6 +69,7 @@
         this.groundNavigation = new GroundPathNavigation(this, world);
     }
 
+    @Override
     protected void addBehaviourGoals() {
         this.goalSelector.addGoal(1, new Drowned.DrownedGoToWaterGoal(this, 1.0D));
         this.goalSelector.addGoal(2, new Drowned.DrownedTridentAttackGoal(this, 1.0D, 40, 10.0F));
@@ -78,12 +79,13 @@
         this.goalSelector.addGoal(7, new RandomStrollGoal(this, 1.0D));
         this.targetSelector.addGoal(1, (new HurtByTargetGoal(this, Drowned.class)).setAlertOthers(ZombifiedPiglin.class));
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, this::okTarget));
-        this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false));
+        if (this.level.spigotConfig.zombieAggressiveTowardsVillager) this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false)); // Paper
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, IronGolem.class, true));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, Axolotl.class, true, false));
         this.targetSelector.addGoal(5, new NearestAttackableTargetGoal<>(this, Turtle.class, 10, true, false, Turtle.BABY_ON_LAND_SELECTOR));
     }
 
+    @Override
     public SpawnGroupData finalizeSpawn(ServerLevelAccessor world, DifficultyInstance difficulty, MobSpawnType spawnReason, @Nullable SpawnGroupData entityData, @Nullable CompoundTag entityNbt) {
         entityData = super.finalizeSpawn(world, difficulty, spawnReason, entityData, entityNbt);
         if (this.getItemBySlot(EquipmentSlot.OFFHAND).isEmpty() && this.random.nextFloat() < 0.03F) {
@@ -108,34 +110,42 @@
         return pos.getY() < world.getSeaLevel() - 5;
     }
 
+    @Override
     protected boolean supportsBreakDoorGoal() {
         return false;
     }
 
+    @Override
     protected SoundEvent getAmbientSound() {
         return this.isInWater() ? SoundEvents.DROWNED_AMBIENT_WATER : SoundEvents.DROWNED_AMBIENT;
     }
 
+    @Override
     protected SoundEvent getHurtSound(DamageSource source) {
         return this.isInWater() ? SoundEvents.DROWNED_HURT_WATER : SoundEvents.DROWNED_HURT;
     }
 
+    @Override
     protected SoundEvent getDeathSound() {
         return this.isInWater() ? SoundEvents.DROWNED_DEATH_WATER : SoundEvents.DROWNED_DEATH;
     }
 
+    @Override
     protected SoundEvent getStepSound() {
         return SoundEvents.DROWNED_STEP;
     }
 
+    @Override
     protected SoundEvent getSwimSound() {
         return SoundEvents.DROWNED_SWIM;
     }
 
+    @Override
     protected ItemStack getSkull() {
         return ItemStack.EMPTY;
     }
 
+    @Override
     protected void populateDefaultEquipmentSlots(DifficultyInstance difficulty) {
         if ((double)this.random.nextFloat() > 0.9D) {
             int i = this.random.nextInt(16);
@@ -148,6 +158,7 @@
 
     }
 
+    @Override
     protected boolean canReplaceCurrentItem(ItemStack newStack, ItemStack oldStack) {
         if (oldStack.is(Items.NAUTILUS_SHELL)) {
             return false;
@@ -162,10 +173,12 @@
         }
     }
 
+    @Override
     protected boolean convertsInWater() {
         return false;
     }
 
+    @Override
     public boolean checkSpawnObstruction(LevelReader world) {
         return world.isUnobstructed(this);
     }
@@ -178,6 +191,7 @@
         }
     }
 
+    @Override
     public boolean isPushedByFluid() {
         return !this.isSwimming();
     }
@@ -191,6 +205,7 @@
         }
     }
 
+    @Override
     public void travel(Vec3 movementInput) {
         if (this.isEffectiveAi() && this.isInWater() && this.wantsToSwim()) {
             this.moveRelative(0.01F, movementInput);
@@ -202,6 +217,7 @@
 
     }
 
+    @Override
     public void updateSwimming() {
         if (!this.level.isClientSide) {
             if (this.isEffectiveAi() && this.isInWater() && this.wantsToSwim()) {
@@ -230,6 +246,7 @@
         return false;
     }
 
+    @Override
     public void performRangedAttack(LivingEntity target, float pullProgress) {
         ThrownTrident thrownTrident = new ThrownTrident(this.level, this, new ItemStack(Items.TRIDENT));
         double d = target.getX() - this.getX();
@@ -253,10 +270,12 @@
             this.drowned = drowned;
         }
 
+        @Override
         public boolean canUse() {
             return super.canUse() && this.drowned.okTarget(this.drowned.getTarget());
         }
 
+        @Override
         public boolean canContinueToUse() {
             return super.canContinueToUse() && this.drowned.okTarget(this.drowned.getTarget());
         }
@@ -270,25 +289,30 @@
             this.drowned = drowned;
         }
 
+        @Override
         public boolean canUse() {
             return super.canUse() && !this.drowned.level.isDay() && this.drowned.isInWater() && this.drowned.getY() >= (double)(this.drowned.level.getSeaLevel() - 3);
         }
 
+        @Override
         public boolean canContinueToUse() {
             return super.canContinueToUse();
         }
 
+        @Override
         protected boolean isValidTarget(LevelReader world, BlockPos pos) {
             BlockPos blockPos = pos.above();
             return world.isEmptyBlock(blockPos) && world.isEmptyBlock(blockPos.above()) ? world.getBlockState(pos).entityCanStandOn(world, pos, this.drowned) : false;
         }
 
+        @Override
         public void start() {
             this.drowned.setSearchingForLand(false);
             this.drowned.navigation = this.drowned.groundNavigation;
             super.start();
         }
 
+        @Override
         public void stop() {
             super.stop();
         }
@@ -309,6 +333,7 @@
             this.setFlags(EnumSet.of(Goal.Flag.MOVE));
         }
 
+        @Override
         public boolean canUse() {
             if (!this.level.isDay()) {
                 return false;
@@ -327,10 +352,12 @@
             }
         }
 
+        @Override
         public boolean canContinueToUse() {
             return !this.mob.getNavigation().isDone();
         }
 
+        @Override
         public void start() {
             this.mob.getNavigation().moveTo(this.wantedX, this.wantedY, this.wantedZ, this.speedModifier);
         }
@@ -359,6 +386,7 @@
             this.drowned = drowned;
         }
 
+        @Override
         public void tick() {
             LivingEntity livingEntity = this.drowned.getTarget();
             if (this.drowned.wantsToSwim() && this.drowned.isInWater()) {
@@ -406,14 +434,17 @@
             this.seaLevel = minY;
         }
 
+        @Override
         public boolean canUse() {
             return !this.drowned.level.isDay() && this.drowned.isInWater() && this.drowned.getY() < (double)(this.seaLevel - 2);
         }
 
+        @Override
         public boolean canContinueToUse() {
             return this.canUse() && !this.stuck;
         }
 
+        @Override
         public void tick() {
             if (this.drowned.getY() < (double)(this.seaLevel - 1) && (this.drowned.getNavigation().isDone() || this.drowned.closeToNextPos())) {
                 Vec3 vec3 = DefaultRandomPos.getPosTowards(this.drowned, 4, 8, new Vec3(this.drowned.getX(), (double)(this.seaLevel - 1), this.drowned.getZ()), (double)((float)Math.PI / 2F));
@@ -427,11 +458,13 @@
 
         }
 
+        @Override
         public void start() {
             this.drowned.setSearchingForLand(true);
             this.stuck = false;
         }
 
+        @Override
         public void stop() {
             this.drowned.setSearchingForLand(false);
         }
@@ -445,16 +478,19 @@
             this.drowned = (Drowned)mob;
         }
 
+        @Override
         public boolean canUse() {
             return super.canUse() && this.drowned.getMainHandItem().is(Items.TRIDENT);
         }
 
+        @Override
         public void start() {
             super.start();
             this.drowned.setAggressive(true);
             this.drowned.startUsingItem(InteractionHand.MAIN_HAND);
         }
 
+        @Override
         public void stop() {
             super.stop();
             this.drowned.stopUsingItem();
