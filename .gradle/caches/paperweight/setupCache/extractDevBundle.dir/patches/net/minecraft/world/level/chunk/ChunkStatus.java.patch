--- a/net/minecraft/world/level/chunk/ChunkStatus.java
+++ b/net/minecraft/world/level/chunk/ChunkStatus.java
@@ -22,99 +22,105 @@
 import net.minecraft.world.level.levelgen.GenerationStep;
 import net.minecraft.world.level.levelgen.Heightmap;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
+import net.minecraft.world.level.lighting.LevelLightEngine;
 
 public class ChunkStatus {
+
     private static final EnumSet<Heightmap.Types> PRE_FEATURES = EnumSet.of(Heightmap.Types.OCEAN_FLOOR_WG, Heightmap.Types.WORLD_SURFACE_WG);
     private static final EnumSet<Heightmap.Types> POST_FEATURES = EnumSet.of(Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE, Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES);
-    private static final ChunkStatus.LoadingTask PASSTHROUGH_LOAD_TASK = (targetStatus, world, structureManager, lightingProvider, function, chunk) -> {
-        if (chunk instanceof ProtoChunk && !chunk.getStatus().isOrAfter(targetStatus)) {
-            ((ProtoChunk)chunk).setStatus(targetStatus);
+    private static final ChunkStatus.LoadingTask PASSTHROUGH_LOAD_TASK = (chunkstatus, worldserver, definedstructuremanager, lightenginethreaded, function, ichunkaccess) -> {
+        if (ichunkaccess instanceof ProtoChunk && !ichunkaccess.getStatus().isOrAfter(chunkstatus)) {
+            ((ProtoChunk) ichunkaccess).setStatus(chunkstatus);
         }
 
-        return CompletableFuture.completedFuture(Either.left(chunk));
+        return CompletableFuture.completedFuture(Either.left(ichunkaccess));
     };
-    public static final ChunkStatus EMPTY = registerSimple("empty", (ChunkStatus)null, -1, PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkStatus, serverLevel, chunkGenerator, list, chunkAccess) -> {
+    public static final ChunkStatus EMPTY = ChunkStatus.registerSimple("empty", (ChunkStatus) null, -1, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
     });
-    public static final ChunkStatus STRUCTURE_STARTS = register("structure_starts", EMPTY, 0, PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (targetStatus, executor, world, chunkGenerator, structureManager, threadedLevelLightEngine, function, list, chunkAccess) -> {
-        if (!chunkAccess.getStatus().isOrAfter(targetStatus)) {
-            if (world.getServer().getWorldData().worldGenSettings().generateFeatures()) {
-                chunkGenerator.createStructures(world.registryAccess(), world.structureFeatureManager(), chunkAccess, structureManager, world.getSeed());
+    public static final ChunkStatus STRUCTURE_STARTS = ChunkStatus.register("structure_starts", ChunkStatus.EMPTY, 0, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, definedstructuremanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        if (!ichunkaccess.getStatus().isOrAfter(chunkstatus)) {
+            if (worldserver.serverLevelData.worldGenSettings().generateFeatures()) { // CraftBukkit
+                chunkgenerator.createStructures(worldserver.registryAccess(), worldserver.structureFeatureManager(), ichunkaccess, definedstructuremanager, worldserver.getSeed());
             }
 
-            if (chunkAccess instanceof ProtoChunk) {
-                ((ProtoChunk)chunkAccess).setStatus(targetStatus);
+            if (ichunkaccess instanceof ProtoChunk) {
+                ((ProtoChunk) ichunkaccess).setStatus(chunkstatus);
             }
         }
 
-        return CompletableFuture.completedFuture(Either.left(chunkAccess));
+        return CompletableFuture.completedFuture(Either.left(ichunkaccess));
     });
-    public static final ChunkStatus STRUCTURE_REFERENCES = registerSimple("structure_references", STRUCTURE_STARTS, 8, PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkStatus, serverLevel, chunkGenerator, list, chunkAccess) -> {
-        WorldGenRegion worldGenRegion = new WorldGenRegion(serverLevel, list, chunkStatus, -1);
-        chunkGenerator.createReferences(worldGenRegion, serverLevel.structureFeatureManager().forWorldGenRegion(worldGenRegion), chunkAccess);
+    public static final ChunkStatus STRUCTURE_REFERENCES = ChunkStatus.registerSimple("structure_references", ChunkStatus.STRUCTURE_STARTS, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, -1);
+
+        chunkgenerator.createReferences(regionlimitedworldaccess, worldserver.structureFeatureManager().forWorldGenRegion(regionlimitedworldaccess), ichunkaccess);
     });
-    public static final ChunkStatus BIOMES = registerSimple("biomes", STRUCTURE_REFERENCES, 0, PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkStatus, serverLevel, chunkGenerator, list, chunkAccess) -> {
-        chunkGenerator.createBiomes(serverLevel.registryAccess().registryOrThrow(Registry.BIOME_REGISTRY), chunkAccess);
+    public static final ChunkStatus BIOMES = ChunkStatus.registerSimple("biomes", ChunkStatus.STRUCTURE_REFERENCES, 0, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        chunkgenerator.createBiomes(worldserver.registryAccess().registryOrThrow(Registry.BIOME_REGISTRY), ichunkaccess);
     });
-    public static final ChunkStatus NOISE = register("noise", BIOMES, 8, PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkStatus, executor, world, chunkGenerator, structureManager, threadedLevelLightEngine, function, list, chunkAccess) -> {
-        if (!chunkAccess.getStatus().isOrAfter(chunkStatus)) {
-            WorldGenRegion worldGenRegion = new WorldGenRegion(world, list, chunkStatus, 0);
-            return chunkGenerator.fillFromNoise(executor, world.structureFeatureManager().forWorldGenRegion(worldGenRegion), chunkAccess).thenApply((chunkAccessx) -> {
-                if (chunkAccessx instanceof ProtoChunk) {
-                    ((ProtoChunk)chunkAccessx).setStatus(chunkStatus);
+    public static final ChunkStatus NOISE = ChunkStatus.register("noise", ChunkStatus.BIOMES, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, definedstructuremanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        if (!ichunkaccess.getStatus().isOrAfter(chunkstatus)) {
+            WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 0);
+
+            return chunkgenerator.fillFromNoise(executor, worldserver.structureFeatureManager().forWorldGenRegion(regionlimitedworldaccess), ichunkaccess).thenApply((ichunkaccess1) -> {
+                if (ichunkaccess1 instanceof ProtoChunk) {
+                    ((ProtoChunk) ichunkaccess1).setStatus(chunkstatus);
                 }
 
-                return Either.left(chunkAccessx);
+                return Either.left(ichunkaccess1);
             });
         } else {
-            return CompletableFuture.completedFuture(Either.left(chunkAccess));
+            return CompletableFuture.completedFuture(Either.left(ichunkaccess));
         }
     });
-    public static final ChunkStatus SURFACE = registerSimple("surface", NOISE, 0, PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkStatus, serverLevel, chunkGenerator, list, chunkAccess) -> {
-        chunkGenerator.buildSurfaceAndBedrock(new WorldGenRegion(serverLevel, list, chunkStatus, 0), chunkAccess);
+    public static final ChunkStatus SURFACE = ChunkStatus.registerSimple("surface", ChunkStatus.NOISE, 0, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        chunkgenerator.buildSurfaceAndBedrock(new WorldGenRegion(worldserver, list, chunkstatus, 0), ichunkaccess);
     });
-    public static final ChunkStatus CARVERS = registerSimple("carvers", SURFACE, 0, PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkStatus, serverLevel, chunkGenerator, list, chunkAccess) -> {
-        chunkGenerator.applyCarvers(serverLevel.getSeed(), serverLevel.getBiomeManager(), chunkAccess, GenerationStep.Carving.AIR);
+    public static final ChunkStatus CARVERS = ChunkStatus.registerSimple("carvers", ChunkStatus.SURFACE, 0, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        chunkgenerator.applyCarvers(worldserver.getSeed(), worldserver.getBiomeManager(), ichunkaccess, GenerationStep.Carving.AIR);
     });
-    public static final ChunkStatus LIQUID_CARVERS = registerSimple("liquid_carvers", CARVERS, 0, POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkStatus, serverLevel, chunkGenerator, list, chunkAccess) -> {
-        chunkGenerator.applyCarvers(serverLevel.getSeed(), serverLevel.getBiomeManager(), chunkAccess, GenerationStep.Carving.LIQUID);
+    public static final ChunkStatus LIQUID_CARVERS = ChunkStatus.registerSimple("liquid_carvers", ChunkStatus.CARVERS, 0, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        chunkgenerator.applyCarvers(worldserver.getSeed(), worldserver.getBiomeManager(), ichunkaccess, GenerationStep.Carving.LIQUID);
     });
-    public static final ChunkStatus FEATURES = register("features", LIQUID_CARVERS, 8, POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (status, executor, serverLevel, chunkGenerator, structureManager, threadedLevelLightEngine, function, list, chunkAccess) -> {
-        ProtoChunk protoChunk = (ProtoChunk)chunkAccess;
-        protoChunk.setLightEngine(threadedLevelLightEngine);
-        if (!chunkAccess.getStatus().isOrAfter(status)) {
-            Heightmap.primeHeightmaps(chunkAccess, EnumSet.of(Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES, Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE));
-            WorldGenRegion worldGenRegion = new WorldGenRegion(serverLevel, list, status, 1);
-            chunkGenerator.applyBiomeDecoration(worldGenRegion, serverLevel.structureFeatureManager().forWorldGenRegion(worldGenRegion));
-            protoChunk.setStatus(status);
+    public static final ChunkStatus FEATURES = ChunkStatus.register("features", ChunkStatus.LIQUID_CARVERS, 8, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, definedstructuremanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        ProtoChunk protochunk = (ProtoChunk) ichunkaccess;
+
+        protochunk.setLightEngine((LevelLightEngine) lightenginethreaded);
+        if (!ichunkaccess.getStatus().isOrAfter(chunkstatus)) {
+            Heightmap.primeHeightmaps(ichunkaccess, EnumSet.of(Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES, Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE));
+            WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 1);
+
+            chunkgenerator.applyBiomeDecoration(regionlimitedworldaccess, worldserver.structureFeatureManager().forWorldGenRegion(regionlimitedworldaccess));
+            protochunk.setStatus(chunkstatus);
         }
 
-        return CompletableFuture.completedFuture(Either.left(chunkAccess));
+        return CompletableFuture.completedFuture(Either.left(ichunkaccess));
     });
-    public static final ChunkStatus LIGHT = register("light", FEATURES, 1, POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (targetStatus, executor, serverLevel, chunkGenerator, structureManager, threadedLevelLightEngine, function, list, chunkAccess) -> {
-        return lightChunk(targetStatus, threadedLevelLightEngine, chunkAccess);
-    }, (status, world, structureManager, lightingProvider, function, chunk) -> {
-        return lightChunk(status, lightingProvider, chunk);
+    public static final ChunkStatus LIGHT = ChunkStatus.register("light", ChunkStatus.FEATURES, 1, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, definedstructuremanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        return ChunkStatus.lightChunk(chunkstatus, lightenginethreaded, ichunkaccess);
+    }, (chunkstatus, worldserver, definedstructuremanager, lightenginethreaded, function, ichunkaccess) -> {
+        return ChunkStatus.lightChunk(chunkstatus, lightenginethreaded, ichunkaccess);
     });
-    public static final ChunkStatus SPAWN = registerSimple("spawn", LIGHT, 0, POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkStatus, serverLevel, chunkGenerator, list, chunkAccess) -> {
-        chunkGenerator.spawnOriginalMobs(new WorldGenRegion(serverLevel, list, chunkStatus, -1));
+    public static final ChunkStatus SPAWN = ChunkStatus.registerSimple("spawn", ChunkStatus.LIGHT, 0, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        chunkgenerator.spawnOriginalMobs(new WorldGenRegion(worldserver, list, chunkstatus, -1));
     });
-    public static final ChunkStatus HEIGHTMAPS = registerSimple("heightmaps", SPAWN, 0, POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkStatus, serverLevel, chunkGenerator, list, chunkAccess) -> {
+    public static final ChunkStatus HEIGHTMAPS = ChunkStatus.registerSimple("heightmaps", ChunkStatus.SPAWN, 0, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
     });
-    public static final ChunkStatus FULL = register("full", HEIGHTMAPS, 0, POST_FEATURES, ChunkStatus.ChunkType.LEVELCHUNK, (targetStatus, executor, serverLevel, chunkGenerator, structureManager, threadedLevelLightEngine, function, list, chunkAccess) -> {
-        return function.apply(chunkAccess);
-    }, (status, world, structureManager, lightingProvider, function, chunk) -> {
-        return function.apply(chunk);
+    public static final ChunkStatus FULL = ChunkStatus.register("full", ChunkStatus.HEIGHTMAPS, 0, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.LEVELCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, definedstructuremanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        return (CompletableFuture) function.apply(ichunkaccess);
+    }, (chunkstatus, worldserver, definedstructuremanager, lightenginethreaded, function, ichunkaccess) -> {
+        return (CompletableFuture) function.apply(ichunkaccess);
     });
-    private static final List<ChunkStatus> STATUS_BY_RANGE = ImmutableList.of(FULL, FEATURES, LIQUID_CARVERS, STRUCTURE_STARTS, STRUCTURE_STARTS, STRUCTURE_STARTS, STRUCTURE_STARTS, STRUCTURE_STARTS, STRUCTURE_STARTS, STRUCTURE_STARTS, STRUCTURE_STARTS);
-    private static final IntList RANGE_BY_STATUS = Util.make(new IntArrayList(getStatusList().size()), (intArrayList) -> {
+    private static final List<ChunkStatus> STATUS_BY_RANGE = ImmutableList.of(ChunkStatus.FULL, ChunkStatus.FEATURES, ChunkStatus.LIQUID_CARVERS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS);
+    private static final IntList RANGE_BY_STATUS = (IntList) Util.make((new IntArrayList(ChunkStatus.getStatusList().size())), (java.util.function.Consumer<IntArrayList>) (intarraylist) -> { // CraftBukkit - decompile error
         int i = 0;
 
-        for(int j = getStatusList().size() - 1; j >= 0; --j) {
-            while(i + 1 < STATUS_BY_RANGE.size() && j <= STATUS_BY_RANGE.get(i + 1).getIndex()) {
+        for (int j = ChunkStatus.getStatusList().size() - 1; j >= 0; --j) {
+            while (i + 1 < ChunkStatus.STATUS_BY_RANGE.size() && j <= ((ChunkStatus) ChunkStatus.STATUS_BY_RANGE.get(i + 1)).getIndex()) {
                 ++i;
             }
 
-            intArrayList.add(0, i);
+            intarraylist.add(0, i);
         }
 
     });
@@ -128,35 +134,37 @@
     private final EnumSet<Heightmap.Types> heightmapsAfter;
 
     private static CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> lightChunk(ChunkStatus status, ThreadedLevelLightEngine lightingProvider, ChunkAccess chunk) {
-        boolean bl = isLighted(status, chunk);
+        boolean flag = ChunkStatus.isLighted(status, chunk);
+
         if (!chunk.getStatus().isOrAfter(status)) {
-            ((ProtoChunk)chunk).setStatus(status);
+            ((ProtoChunk) chunk).setStatus(status);
         }
 
-        return lightingProvider.lightChunk(chunk, bl).thenApply(Either::left);
+        return lightingProvider.lightChunk(chunk, flag).thenApply(Either::left);
     }
 
     private static ChunkStatus registerSimple(String id, @Nullable ChunkStatus previous, int taskMargin, EnumSet<Heightmap.Types> heightMapTypes, ChunkStatus.ChunkType chunkType, ChunkStatus.SimpleGenerationTask task) {
-        return register(id, previous, taskMargin, heightMapTypes, chunkType, task);
+        return ChunkStatus.register(id, previous, taskMargin, heightMapTypes, chunkType, (ChunkStatus.GenerationTask) task);
     }
 
     private static ChunkStatus register(String id, @Nullable ChunkStatus previous, int taskMargin, EnumSet<Heightmap.Types> heightMapTypes, ChunkStatus.ChunkType chunkType, ChunkStatus.GenerationTask task) {
-        return register(id, previous, taskMargin, heightMapTypes, chunkType, task, PASSTHROUGH_LOAD_TASK);
+        return ChunkStatus.register(id, previous, taskMargin, heightMapTypes, chunkType, task, ChunkStatus.PASSTHROUGH_LOAD_TASK);
     }
 
     private static ChunkStatus register(String id, @Nullable ChunkStatus previous, int taskMargin, EnumSet<Heightmap.Types> heightMapTypes, ChunkStatus.ChunkType chunkType, ChunkStatus.GenerationTask task, ChunkStatus.LoadingTask loadTask) {
-        return Registry.register(Registry.CHUNK_STATUS, id, new ChunkStatus(id, previous, taskMargin, heightMapTypes, chunkType, task, loadTask));
+        return (ChunkStatus) Registry.register((Registry) Registry.CHUNK_STATUS, id, (Object) (new ChunkStatus(id, previous, taskMargin, heightMapTypes, chunkType, task, loadTask)));
     }
 
     public static List<ChunkStatus> getStatusList() {
         List<ChunkStatus> list = Lists.newArrayList();
 
-        ChunkStatus chunkStatus;
-        for(chunkStatus = FULL; chunkStatus.getParent() != chunkStatus; chunkStatus = chunkStatus.getParent()) {
-            list.add(chunkStatus);
+        ChunkStatus chunkstatus;
+
+        for (chunkstatus = ChunkStatus.FULL; chunkstatus.getParent() != chunkstatus; chunkstatus = chunkstatus.getParent()) {
+            list.add(chunkstatus);
         }
 
-        list.add(chunkStatus);
+        list.add(chunkstatus);
         Collections.reverse(list);
         return list;
     }
@@ -166,19 +174,15 @@
     }
 
     public static ChunkStatus getStatusAroundFullChunk(int level) {
-        if (level >= STATUS_BY_RANGE.size()) {
-            return EMPTY;
-        } else {
-            return level < 0 ? FULL : STATUS_BY_RANGE.get(level);
-        }
+        return level >= ChunkStatus.STATUS_BY_RANGE.size() ? ChunkStatus.EMPTY : (level < 0 ? ChunkStatus.FULL : (ChunkStatus) ChunkStatus.STATUS_BY_RANGE.get(level));
     }
 
     public static int maxDistance() {
-        return STATUS_BY_RANGE.size();
+        return ChunkStatus.STATUS_BY_RANGE.size();
     }
 
     public static int getDistance(ChunkStatus status) {
-        return RANGE_BY_STATUS.getInt(status.getIndex());
+        return ChunkStatus.RANGE_BY_STATUS.getInt(status.getIndex());
     }
 
     ChunkStatus(String id, @Nullable ChunkStatus previous, int taskMargin, EnumSet<Heightmap.Types> heightMapTypes, ChunkStatus.ChunkType chunkType, ChunkStatus.GenerationTask generationTask, ChunkStatus.LoadingTask loadTask) {
@@ -204,8 +208,8 @@
         return this.parent;
     }
 
-    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> generate(Executor executor, ServerLevel world, ChunkGenerator chunkGenerator, StructureManager structureManager, ThreadedLevelLightEngine lightingProvider, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> function, List<ChunkAccess> list) {
-        return this.generationTask.doWork(this, executor, world, chunkGenerator, structureManager, lightingProvider, function, list, list.get(list.size() / 2));
+    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> generate(Executor executor, ServerLevel world, ChunkGenerator chunkgenerator, StructureManager structureManager, ThreadedLevelLightEngine lightingProvider, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> function, List<ChunkAccess> list) {
+        return this.generationTask.doWork(this, executor, world, chunkgenerator, structureManager, lightingProvider, function, list, (ChunkAccess) list.get(list.size() / 2));
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> load(ServerLevel world, StructureManager structureManager, ThreadedLevelLightEngine lightingProvider, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> function, ChunkAccess chunk) {
@@ -220,8 +224,19 @@
         return this.chunkType;
     }
 
+    // Paper start
+    public static ChunkStatus getStatus(String name) {
+        try {
+            // We need this otherwise we return EMPTY for invalid names
+            ResourceLocation key = new ResourceLocation(name);
+            return Registry.CHUNK_STATUS.getOptional(key).orElse(null);
+        } catch (Exception ex) {
+            return null; // invalid name
+        }
+    }
+    // Paper end
     public static ChunkStatus byName(String id) {
-        return Registry.CHUNK_STATUS.get(ResourceLocation.tryParse(id));
+        return (ChunkStatus) Registry.CHUNK_STATUS.get(ResourceLocation.tryParse(id));
     }
 
     public EnumSet<Heightmap.Types> heightmapsAfter() {
@@ -237,30 +252,36 @@
     }
 
     public static enum ChunkType {
-        PROTOCHUNK,
-        LEVELCHUNK;
+
+        PROTOCHUNK, LEVELCHUNK;
+
+        private ChunkType() {}
     }
 
-    interface GenerationTask {
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> doWork(ChunkStatus targetStatus, Executor executor, ServerLevel world, ChunkGenerator chunkGenerator, StructureManager structureManager, ThreadedLevelLightEngine lightingProvider, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> function, List<ChunkAccess> list, ChunkAccess chunkAccess);
+    private interface GenerationTask {
+
+        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> doWork(ChunkStatus targetStatus, Executor executor, ServerLevel world, ChunkGenerator chunkgenerator, StructureManager structureManager, ThreadedLevelLightEngine lightingProvider, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> function, List<ChunkAccess> list, ChunkAccess ichunkaccess);
     }
 
-    interface LoadingTask {
+    private interface LoadingTask {
+
         CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> doWork(ChunkStatus targetStatus, ServerLevel world, StructureManager structureManager, ThreadedLevelLightEngine lightingProvider, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> function, ChunkAccess chunk);
     }
 
-    interface SimpleGenerationTask extends ChunkStatus.GenerationTask {
-        default CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> doWork(ChunkStatus targetStatus, Executor executor, ServerLevel world, ChunkGenerator chunkGenerator, StructureManager structureManager, ThreadedLevelLightEngine lightingProvider, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> function, List<ChunkAccess> list, ChunkAccess chunkAccess) {
-            if (!chunkAccess.getStatus().isOrAfter(targetStatus)) {
-                this.doWork(targetStatus, world, chunkGenerator, list, chunkAccess);
-                if (chunkAccess instanceof ProtoChunk) {
-                    ((ProtoChunk)chunkAccess).setStatus(targetStatus);
+    private interface SimpleGenerationTask extends ChunkStatus.GenerationTask {
+
+        @Override
+        default CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> doWork(ChunkStatus targetStatus, Executor executor, ServerLevel world, ChunkGenerator chunkgenerator, StructureManager structureManager, ThreadedLevelLightEngine lightingProvider, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> function, List<ChunkAccess> list, ChunkAccess ichunkaccess) {
+            if (!ichunkaccess.getStatus().isOrAfter(targetStatus)) {
+                this.doWork(targetStatus, world, chunkgenerator, list, ichunkaccess);
+                if (ichunkaccess instanceof ProtoChunk) {
+                    ((ProtoChunk) ichunkaccess).setStatus(targetStatus);
                 }
             }
 
-            return CompletableFuture.completedFuture(Either.left(chunkAccess));
+            return CompletableFuture.completedFuture(Either.left(ichunkaccess));
         }
 
-        void doWork(ChunkStatus targetStatus, ServerLevel world, ChunkGenerator chunkGenerator, List<ChunkAccess> list, ChunkAccess chunkAccess);
+        void doWork(ChunkStatus targetStatus, ServerLevel world, ChunkGenerator chunkgenerator, List<ChunkAccess> list, ChunkAccess ichunkaccess);
     }
 }
