--- a/net/minecraft/network/Connection.java
+++ b/net/minecraft/network/Connection.java
@@ -37,22 +37,24 @@
 import net.minecraft.network.protocol.PacketFlow;
 import net.minecraft.network.protocol.game.ClientboundDisconnectPacket;
 import net.minecraft.network.protocol.login.ClientboundLoginDisconnectPacket;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.RunningOnDifferentThreadException;
 import net.minecraft.server.network.ServerGamePacketListenerImpl;
 import net.minecraft.server.network.ServerLoginPacketListenerImpl;
 import net.minecraft.util.LazyLoadedValue;
 import net.minecraft.util.Mth;
-import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.libs.org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.apache.logging.log4j.Marker;
 import org.apache.logging.log4j.MarkerManager;
 
 public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
+
     private static final float AVERAGE_PACKETS_SMOOTHING = 0.75F;
     private static final Logger LOGGER = LogManager.getLogger();
     public static final Marker ROOT_MARKER = MarkerManager.getMarker("NETWORK");
-    public static final Marker PACKET_MARKER = MarkerManager.getMarker("NETWORK_PACKETS", ROOT_MARKER);
+    public static final Marker PACKET_MARKER = MarkerManager.getMarker("NETWORK_PACKETS", Connection.ROOT_MARKER);
     public static final AttributeKey<ConnectionProtocol> ATTRIBUTE_PROTOCOL = AttributeKey.valueOf("protocol");
     public static final LazyLoadedValue<NioEventLoopGroup> NETWORK_WORKER_GROUP = new LazyLoadedValue<>(() -> {
         return new NioEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Client IO #%d").setDaemon(true).build());
@@ -65,8 +67,13 @@
     });
     private final PacketFlow receiving;
     private final Queue<Connection.PacketHolder> queue = Queues.newConcurrentLinkedQueue();
-    private Channel channel;
-    private SocketAddress address;
+    public Channel channel;
+    public SocketAddress address;
+    // Spigot Start
+    public java.util.UUID spoofedUUID;
+    public com.mojang.authlib.properties.Property[] spoofedProfile;
+    public boolean preparing = true;
+    // Spigot End
     private PacketListener packetListener;
     private Component disconnectedReason;
     private boolean encrypted;
@@ -77,71 +84,101 @@
     private float averageSentPackets;
     private int tickCount;
     private boolean handlingFault;
+    // Paper start - NetworkClient implementation
+    public int protocolVersion;
+    public java.net.InetSocketAddress virtualHost;
+    private static boolean enableExplicitFlush = Boolean.getBoolean("paper.explicit-flush");
+    // Optimize network
+    public boolean isPending = true;
+    public boolean queueImmunity = false;
+    public ConnectionProtocol protocol;
+    // Paper end
 
     public Connection(PacketFlow side) {
         this.receiving = side;
     }
 
-    public void channelActive(ChannelHandlerContext channelHandlerContext) throws Exception {
-        super.channelActive(channelHandlerContext);
-        this.channel = channelHandlerContext.channel();
+    public void channelActive(ChannelHandlerContext channelhandlercontext) throws Exception {
+        super.channelActive(channelhandlercontext);
+        this.channel = channelhandlercontext.channel();
         this.address = this.channel.remoteAddress();
+        // Spigot Start
+        this.preparing = false;
+        // Spigot End
 
         try {
             this.setProtocol(ConnectionProtocol.HANDSHAKING);
-        } catch (Throwable var3) {
-            LOGGER.fatal(var3);
+        } catch (Throwable throwable) {
+            Connection.LOGGER.fatal(throwable);
         }
 
     }
 
     public void setProtocol(ConnectionProtocol state) {
-        this.channel.attr(ATTRIBUTE_PROTOCOL).set(state);
+        protocol = state; // Paper
+        this.channel.attr(Connection.ATTRIBUTE_PROTOCOL).set(state);
         this.channel.config().setAutoRead(true);
-        LOGGER.debug("Enabled auto read");
+        Connection.LOGGER.debug("Enabled auto read");
     }
 
-    public void channelInactive(ChannelHandlerContext channelHandlerContext) {
+    public void channelInactive(ChannelHandlerContext channelhandlercontext) {
         this.disconnect(new TranslatableComponent("disconnect.endOfStream"));
     }
 
-    public void exceptionCaught(ChannelHandlerContext channelHandlerContext, Throwable throwable) {
+    public void exceptionCaught(ChannelHandlerContext channelhandlercontext, Throwable throwable) {
+        // Paper start
+        if (throwable instanceof io.netty.handler.codec.EncoderException && throwable.getCause() instanceof PacketEncoder.PacketTooLargeException) {
+            if (((PacketEncoder.PacketTooLargeException) throwable.getCause()).getPacket().packetTooLarge(this)) {
+                return;
+            } else {
+                throwable = throwable.getCause();
+            }
+        }
+        // Paper end
         if (throwable instanceof SkipPacketException) {
-            LOGGER.debug("Skipping packet due to errors", throwable.getCause());
+            Connection.LOGGER.debug("Skipping packet due to errors", throwable.getCause());
         } else {
-            boolean bl = !this.handlingFault;
+            boolean flag = !this.handlingFault;
+
             this.handlingFault = true;
             if (this.channel.isOpen()) {
+                net.minecraft.server.level.ServerPlayer player = this.getPlayer(); // Paper
                 if (throwable instanceof TimeoutException) {
-                    LOGGER.debug("Timeout", throwable);
+                    Connection.LOGGER.debug("Timeout", throwable);
+                    if (player != null) player.quitReason = org.bukkit.event.player.PlayerQuitEvent.QuitReason.TIMED_OUT; // Paper
                     this.disconnect(new TranslatableComponent("disconnect.timeout"));
                 } else {
-                    Component component = new TranslatableComponent("disconnect.genericReason", "Internal Exception: " + throwable);
-                    if (bl) {
-                        LOGGER.debug("Failed to sent packet", throwable);
-                        ConnectionProtocol connectionProtocol = this.getCurrentProtocol();
-                        Packet<?> packet = (Packet<?>)(connectionProtocol == ConnectionProtocol.LOGIN ? new ClientboundLoginDisconnectPacket(component) : new ClientboundDisconnectPacket(component));
-                        this.send(packet, (future) -> {
-                            this.disconnect(component);
+                    TranslatableComponent chatmessage = new TranslatableComponent("disconnect.genericReason", new Object[]{"Internal Exception: " + throwable});
+
+                    if (player != null) player.quitReason = org.bukkit.event.player.PlayerQuitEvent.QuitReason.ERRONEOUS_STATE; // Paper
+                    if (flag) {
+                        Connection.LOGGER.debug("Failed to sent packet", throwable);
+                        ConnectionProtocol enumprotocol = this.getCurrentProtocol();
+                        Packet<?> packet = enumprotocol == ConnectionProtocol.LOGIN ? new ClientboundLoginDisconnectPacket(chatmessage) : new ClientboundDisconnectPacket(chatmessage);
+
+                        this.send((Packet) packet, (future) -> {
+                            this.disconnect(chatmessage);
                         });
                         this.setReadOnly();
                     } else {
-                        LOGGER.debug("Double fault", throwable);
-                        this.disconnect(component);
+                        Connection.LOGGER.debug("Double fault", throwable);
+                        this.disconnect(chatmessage);
                     }
                 }
 
             }
         }
+        if (net.minecraft.server.MinecraftServer.getServer().isDebugging()) throwable.printStackTrace(); // Spigot
     }
 
-    protected void channelRead0(ChannelHandlerContext channelHandlerContext, Packet<?> packet) {
+    protected void channelRead0(ChannelHandlerContext channelhandlercontext, Packet<?> packet) {
         if (this.channel.isOpen()) {
             try {
-                genericsFtw(packet, this.packetListener);
-            } catch (RunningOnDifferentThreadException var4) {
-            } catch (ClassCastException var5) {
-                LOGGER.error("Received {} that couldn't be processed", packet.getClass(), var5);
+                Connection.genericsFtw(packet, this.packetListener);
+            } catch (RunningOnDifferentThreadException cancelledpackethandleexception) {
+                ;
+            } catch (ClassCastException classcastexception) {
+                Connection.LOGGER.error("Received {} that couldn't be processed", packet.getClass(), classcastexception);
                 this.disconnect(new TranslatableComponent("multiplayer.disconnect.invalid_packet"));
             }
 
@@ -151,84 +188,215 @@
     }
 
     private static <T extends PacketListener> void genericsFtw(Packet<T> packet, PacketListener listener) {
-        packet.handle((T)listener);
+        packet.handle((T) listener); // CraftBukkit - decompile error
     }
 
     public void setListener(PacketListener listener) {
-        Validate.notNull(listener, "packetListener");
+        Validate.notNull(listener, "packetListener", new Object[0]);
         this.packetListener = listener;
     }
+    // Paper start
+    public net.minecraft.server.level.ServerPlayer getPlayer() {
+        if (packetListener instanceof ServerGamePacketListenerImpl) {
+            return ((ServerGamePacketListenerImpl) packetListener).player;
+        } else {
+            return null;
+        }
+    }
+    private static class InnerUtil { // Attempt to hide these methods from ProtocolLib so it doesn't accidently pick them up.
+        private static java.util.List<Packet> buildExtraPackets(Packet packet) {
+            java.util.List<Packet> extra = packet.getExtraPackets();
+            if (extra == null || extra.isEmpty()) {
+                return null;
+            }
+            java.util.List<Packet> ret = new java.util.ArrayList<>(1 + extra.size());
+            buildExtraPackets0(extra, ret);
+            return ret;
+        }
+
+        private static void buildExtraPackets0(java.util.List<Packet> extraPackets, java.util.List<Packet> into) {
+            for (Packet extra : extraPackets) {
+                into.add(extra);
+                java.util.List<Packet> extraExtra = extra.getExtraPackets();
+                if (extraExtra != null && !extraExtra.isEmpty()) {
+                    buildExtraPackets0(extraExtra, into);
+                }
+            }
+        }
+        // Paper start
+        private static boolean canSendImmediate(Connection networkManager, Packet<?> packet) {
+            return networkManager.isPending || networkManager.protocol != ConnectionProtocol.PLAY ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundKeepAlivePacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundChatPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundCommandSuggestionsPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundSetTitleTextPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundSetSubtitleTextPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundSetActionBarTextPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundSetTitlesAnimationPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundClearTitlesPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundBossEventPacket;
+        }
+        // Paper end
+    }
+    // Paper end
 
     public void send(Packet<?> packet) {
-        this.send(packet, (GenericFutureListener<? extends Future<? super Void>>)null);
+        this.send(packet, (GenericFutureListener) null);
     }
 
     public void send(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback) {
-        if (this.isConnected()) {
-            this.flushQueue();
+        // Paper start - handle oversized packets better
+        boolean connected = this.isConnected();
+        if (!connected && !preparing) {
+            return; // Do nothing
+        }
+        packet.onPacketDispatch(getPlayer());
+        if (connected && (InnerUtil.canSendImmediate(this, packet) || (
+            net.minecraft.server.MCUtil.isMainThread() && packet.isReady() && this.queue.isEmpty() &&
+            (packet.getExtraPackets() == null || packet.getExtraPackets().isEmpty())
+        ))) {
             this.sendPacket(packet, callback);
-        } else {
-            this.queue.add(new Connection.PacketHolder(packet, callback));
+            return;
         }
+        // write the packets to the queue, then flush - antixray hooks there already
+        java.util.List<Packet> extraPackets = InnerUtil.buildExtraPackets(packet);
+        boolean hasExtraPackets = extraPackets != null && !extraPackets.isEmpty();
+        if (!hasExtraPackets) {
+            this.queue.add(new Connection.PacketHolder(packet, callback));
+        } else {
+            java.util.List<Connection.PacketHolder> packets = new java.util.ArrayList<>(1 + extraPackets.size());
+            packets.add(new Connection.PacketHolder(packet, null)); // delay the future listener until the end of the extra packets
 
+            for (int i = 0, len = extraPackets.size(); i < len;) {
+                Packet extra = extraPackets.get(i);
+                boolean end = ++i == len;
+                packets.add(new Connection.PacketHolder(extra, end ? callback : null)); // append listener to the end
+            }
+            this.queue.addAll(packets); // atomic
+        }
+        this.flushQueue();
+        // Paper end
     }
 
     private void sendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback) {
-        ConnectionProtocol connectionProtocol = ConnectionProtocol.getProtocolForPacket(packet);
-        ConnectionProtocol connectionProtocol2 = this.getCurrentProtocol();
+        ConnectionProtocol enumprotocol = ConnectionProtocol.getProtocolForPacket(packet);
+        ConnectionProtocol enumprotocol1 = this.getCurrentProtocol();
+
         ++this.sentPackets;
-        if (connectionProtocol2 != connectionProtocol) {
-            LOGGER.debug("Disabled auto read");
+        if (enumprotocol1 != enumprotocol) {
+            Connection.LOGGER.debug("Disabled auto read");
             this.channel.config().setAutoRead(false);
         }
 
         if (this.channel.eventLoop().inEventLoop()) {
-            this.doSendPacket(packet, callback, connectionProtocol, connectionProtocol2);
+            this.a(packet, callback, enumprotocol, enumprotocol1);
         } else {
             this.channel.eventLoop().execute(() -> {
-                this.doSendPacket(packet, callback, connectionProtocol, connectionProtocol2);
+                this.a(packet, callback, enumprotocol, enumprotocol1);
             });
         }
 
     }
 
-    private void doSendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback, ConnectionProtocol connectionProtocol, ConnectionProtocol connectionProtocol2) {
-        if (connectionProtocol != connectionProtocol2) {
-            this.setProtocol(connectionProtocol);
+    private void a(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> genericfuturelistener, ConnectionProtocol enumprotocol, ConnectionProtocol enumprotocol1) {
+        if (enumprotocol != enumprotocol1) {
+            this.setProtocol(enumprotocol);
         }
 
-        ChannelFuture channelFuture = this.channel.writeAndFlush(packet);
-        if (callback != null) {
-            channelFuture.addListener(callback);
+        // Paper start
+        net.minecraft.server.level.ServerPlayer player = getPlayer();
+        if (!isConnected()) {
+            packet.onPacketDispatchFinish(player, null);
+            return;
         }
 
-        channelFuture.addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+        try {
+            // Paper end
+        ChannelFuture channelfuture = this.channel.writeAndFlush(packet);
+
+        if (genericfuturelistener != null) {
+            channelfuture.addListener(genericfuturelistener);
+        }
+        // Paper start
+        if (packet.hasFinishListener()) {
+            channelfuture.addListener((ChannelFutureListener) channelFuture -> packet.onPacketDispatchFinish(player, channelFuture));
+        }
+        // Paper end
+
+        channelfuture.addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+        // Paper start
+        } catch (Exception e) {
+            LOGGER.error("NetworkException: " + player, e);
+            disconnect(new net.minecraft.network.chat.TranslatableComponent("disconnect.genericReason", "Internal Exception: " + e.getMessage()));
+            packet.onPacketDispatchFinish(player, null);
+        }
+        // Paper end
     }
 
     private ConnectionProtocol getCurrentProtocol() {
-        return this.channel.attr(ATTRIBUTE_PROTOCOL).get();
+        return (ConnectionProtocol) this.channel.attr(Connection.ATTRIBUTE_PROTOCOL).get();
     }
 
-    private void flushQueue() {
-        if (this.channel != null && this.channel.isOpen()) {
-            synchronized(this.queue) {
-                Connection.PacketHolder packetHolder;
-                while((packetHolder = this.queue.poll()) != null) {
-                    this.sendPacket(packetHolder.packet, packetHolder.listener);
-                }
+    // Paper start - rewrite this to be safer if ran off main thread
+    private boolean flushQueue() { // void -> boolean
+        if (!isConnected()) {
+            return true;
+        }
+        if (net.minecraft.server.MCUtil.isMainThread()) {
+            return processQueue();
+        } else if (isPending) {
+            // Should only happen during login/status stages
+            synchronized (this.queue) {
+                return this.processQueue();
+            }
+        }
+        return false;
+    }
+    private boolean processQueue() {
+        if (this.queue.isEmpty()) return true;
+        // If we are on main, we are safe here in that nothing else should be processing queue off main anymore
+        // But if we are not on main due to login/status, the parent is synchronized on packetQueue
+        java.util.Iterator<PacketHolder> iterator = this.queue.iterator();
+        while (iterator.hasNext()) {
+            PacketHolder queued = iterator.next(); // poll -> peek
 
+            // Fix NPE (Spigot bug caused by handleDisconnection())
+            if (queued == null) {
+                return true;
+            }
+
+            Packet<?> packet = queued.packet;
+            if (!packet.isReady()) {
+                return false;
+            } else {
+                iterator.remove();
+                this.sendPacket(packet, queued.listener);
             }
         }
+        return true;
     }
+    // Paper end
 
+    private static final int MAX_PER_TICK = com.destroystokyo.paper.PaperConfig.maxJoinsPerTick; // Paper
+    private static int joinAttemptsThisTick; // Paper
+    private static int currTick; // Paper
     public void tick() {
         this.flushQueue();
+        // Paper start
+        if (currTick != MinecraftServer.currentTick) {
+            currTick = MinecraftServer.currentTick;
+            joinAttemptsThisTick = 0;
+        }
+        // Paper end
         if (this.packetListener instanceof ServerLoginPacketListenerImpl) {
-            ((ServerLoginPacketListenerImpl)this.packetListener).tick();
+            if ( ((ServerLoginPacketListenerImpl) this.packetListener).state != ServerLoginPacketListenerImpl.State.READY_TO_ACCEPT // Paper
+                     || (joinAttemptsThisTick++ < MAX_PER_TICK)) { // Paper - limit the number of joins which can be processed each tick
+            ((ServerLoginPacketListenerImpl) this.packetListener).tick();
+            } // Paper
         }
 
         if (this.packetListener instanceof ServerGamePacketListenerImpl) {
-            ((ServerGamePacketListenerImpl)this.packetListener).tick();
+            ((ServerGamePacketListenerImpl) this.packetListener).tick();
         }
 
         if (!this.isConnected() && !this.disconnectionHandled) {
@@ -236,7 +404,7 @@
         }
 
         if (this.channel != null) {
-            this.channel.flush();
+            if (enableExplicitFlush) this.channel.eventLoop().execute(() -> this.channel.flush()); // Paper - we don't need to explicit flush here, but allow opt in incase issues are found to a better version
         }
 
         if (this.tickCount++ % 20 == 0) {
@@ -246,8 +414,8 @@
     }
 
     protected void tickSecond() {
-        this.averageSentPackets = Mth.lerp(0.75F, (float)this.sentPackets, this.averageSentPackets);
-        this.averageReceivedPackets = Mth.lerp(0.75F, (float)this.receivedPackets, this.averageReceivedPackets);
+        this.averageSentPackets = Mth.lerp(0.75F, (float) this.sentPackets, this.averageSentPackets);
+        this.averageReceivedPackets = Mth.lerp(0.75F, (float) this.receivedPackets, this.averageReceivedPackets);
         this.sentPackets = 0;
         this.receivedPackets = 0;
     }
@@ -256,9 +424,25 @@
         return this.address;
     }
 
+    // Paper start
+    public void clearPacketQueue() {
+        net.minecraft.server.level.ServerPlayer player = getPlayer();
+        queue.forEach(queuedPacket -> {
+            Packet<?> packet = queuedPacket.packet;
+            if (packet.hasFinishListener()) {
+                packet.onPacketDispatchFinish(player, null);
+            }
+        });
+        queue.clear();
+    }
+    // Paper end
     public void disconnect(Component disconnectReason) {
+        // Spigot Start
+        this.preparing = false;
+        clearPacketQueue(); // Paper
+        // Spigot End
         if (this.channel.isOpen()) {
-            this.channel.close().awaitUninterruptibly();
+            this.channel.close(); // We can't wait as this may be called from an event loop.
             this.disconnectedReason = disconnectReason;
         }
 
@@ -277,38 +461,41 @@
     }
 
     public static Connection connectToServer(InetSocketAddress address, boolean useEpoll) {
-        final Connection connection = new Connection(PacketFlow.CLIENTBOUND);
-        Class<? extends SocketChannel> class_;
-        LazyLoadedValue<? extends EventLoopGroup> lazyLoadedValue;
+        final Connection networkmanager = new Connection(PacketFlow.CLIENTBOUND);
+        Class oclass;
+        LazyLoadedValue lazyinitvar;
+
         if (Epoll.isAvailable() && useEpoll) {
-            class_ = EpollSocketChannel.class;
-            lazyLoadedValue = NETWORK_EPOLL_WORKER_GROUP;
+            oclass = EpollSocketChannel.class;
+            lazyinitvar = Connection.NETWORK_EPOLL_WORKER_GROUP;
         } else {
-            class_ = NioSocketChannel.class;
-            lazyLoadedValue = NETWORK_WORKER_GROUP;
+            oclass = NioSocketChannel.class;
+            lazyinitvar = Connection.NETWORK_WORKER_GROUP;
         }
 
-        (new Bootstrap()).group(lazyLoadedValue.get()).handler(new ChannelInitializer<Channel>() {
+        ((Bootstrap) ((Bootstrap) ((Bootstrap) (new Bootstrap()).group((EventLoopGroup) lazyinitvar.get())).handler(new ChannelInitializer<Channel>() {
             protected void initChannel(Channel channel) {
                 try {
                     channel.config().setOption(ChannelOption.TCP_NODELAY, true);
-                } catch (ChannelException var3) {
+                } catch (ChannelException channelexception) {
+                    ;
                 }
 
-                channel.pipeline().addLast("timeout", new ReadTimeoutHandler(30)).addLast("splitter", new Varint21FrameDecoder()).addLast("decoder", new PacketDecoder(PacketFlow.CLIENTBOUND)).addLast("prepender", new Varint21LengthFieldPrepender()).addLast("encoder", new PacketEncoder(PacketFlow.SERVERBOUND)).addLast("packet_handler", connection);
+                channel.pipeline().addLast("timeout", new ReadTimeoutHandler(30)).addLast("splitter", new Varint21FrameDecoder()).addLast("decoder", new PacketDecoder(PacketFlow.CLIENTBOUND)).addLast("prepender", new Varint21LengthFieldPrepender()).addLast("encoder", new PacketEncoder(PacketFlow.SERVERBOUND)).addLast("packet_handler", networkmanager);
             }
-        }).channel(class_).connect(address.getAddress(), address.getPort()).syncUninterruptibly();
-        return connection;
+        })).channel(oclass)).connect(address.getAddress(), address.getPort()).syncUninterruptibly();
+        return networkmanager;
     }
 
     public static Connection connectToLocalServer(SocketAddress address) {
-        final Connection connection = new Connection(PacketFlow.CLIENTBOUND);
-        (new Bootstrap()).group(LOCAL_WORKER_GROUP.get()).handler(new ChannelInitializer<Channel>() {
+        final Connection networkmanager = new Connection(PacketFlow.CLIENTBOUND);
+
+        ((Bootstrap) ((Bootstrap) ((Bootstrap) (new Bootstrap()).group((EventLoopGroup) Connection.LOCAL_WORKER_GROUP.get())).handler(new ChannelInitializer<Channel>() {
             protected void initChannel(Channel channel) {
-                channel.pipeline().addLast("packet_handler", connection);
+                channel.pipeline().addLast("packet_handler", networkmanager);
             }
-        }).channel(LocalChannel.class).connect(address).syncUninterruptibly();
-        return connection;
+        })).channel(LocalChannel.class)).connect(address).syncUninterruptibly();
+        return networkmanager;
     }
 
     public void setEncryptionKey(Cipher decryptionCipher, Cipher encryptionCipher) {
@@ -342,16 +529,16 @@
         this.channel.config().setAutoRead(false);
     }
 
-    public void setupCompression(int compressionThreshold, boolean bl) {
+    public void setupCompression(int compressionThreshold, boolean flag) {
         if (compressionThreshold >= 0) {
             if (this.channel.pipeline().get("decompress") instanceof CompressionDecoder) {
-                ((CompressionDecoder)this.channel.pipeline().get("decompress")).setThreshold(compressionThreshold, bl);
+                ((CompressionDecoder) this.channel.pipeline().get("decompress")).setThreshold(compressionThreshold, flag);
             } else {
-                this.channel.pipeline().addBefore("decoder", "decompress", new CompressionDecoder(compressionThreshold, bl));
+                this.channel.pipeline().addBefore("decoder", "decompress", new CompressionDecoder(compressionThreshold, flag));
             }
 
             if (this.channel.pipeline().get("compress") instanceof CompressionEncoder) {
-                ((CompressionEncoder)this.channel.pipeline().get("compress")).setThreshold(compressionThreshold);
+                ((CompressionEncoder) this.channel.pipeline().get("compress")).setThreshold(compressionThreshold);
             } else {
                 this.channel.pipeline().addBefore("encoder", "compress", new CompressionEncoder(compressionThreshold));
             }
@@ -370,7 +557,7 @@
     public void handleDisconnection() {
         if (this.channel != null && !this.channel.isOpen()) {
             if (this.disconnectionHandled) {
-                LOGGER.warn("handleDisconnection() called twice");
+                //Connection.LOGGER.warn("handleDisconnection() called twice"); // Paper - Do not log useless message
             } else {
                 this.disconnectionHandled = true;
                 if (this.getDisconnectedReason() != null) {
@@ -378,6 +565,27 @@
                 } else if (this.getPacketListener() != null) {
                     this.getPacketListener().onDisconnect(new TranslatableComponent("multiplayer.disconnect.generic"));
                 }
+                clearPacketQueue(); // Paper
+                // Paper start - Add PlayerConnectionCloseEvent
+                final PacketListener packetListener = this.getPacketListener();
+                if (packetListener instanceof ServerGamePacketListenerImpl) {
+                    /* Player was logged in */
+                    final ServerGamePacketListenerImpl playerConnection = (ServerGamePacketListenerImpl) packetListener;
+                    new com.destroystokyo.paper.event.player.PlayerConnectionCloseEvent(playerConnection.player.getUUID(),
+                        playerConnection.player.getScoreboardName(), ((java.net.InetSocketAddress)address).getAddress(), false).callEvent();
+                } else if (packetListener instanceof ServerLoginPacketListenerImpl) {
+                    /* Player is login stage */
+                    final ServerLoginPacketListenerImpl loginListener = (ServerLoginPacketListenerImpl) packetListener;
+                    switch (loginListener.state) {
+                        case READY_TO_ACCEPT:
+                        case DELAY_ACCEPT:
+                        case ACCEPTED:
+                            final com.mojang.authlib.GameProfile profile = loginListener.getGameProfile(); /* Should be non-null at this stage */
+                            new com.destroystokyo.paper.event.player.PlayerConnectionCloseEvent(profile.getId(), profile.getName(),
+                                ((java.net.InetSocketAddress)address).getAddress(), false).callEvent();
+                    }
+                }
+                // Paper end
             }
 
         }
@@ -391,7 +599,8 @@
         return this.averageSentPackets;
     }
 
-    static class PacketHolder {
+    private static class PacketHolder {
+
         final Packet<?> packet;
         @Nullable
         final GenericFutureListener<? extends Future<? super Void>> listener;
@@ -401,4 +610,16 @@
             this.listener = callback;
         }
     }
+
+    // Spigot Start
+    public SocketAddress getRawAddress()
+    {
+        // Paper start - this can be nullable in the case of a Unix domain socket, so if it is, fake something
+        if (this.channel.remoteAddress() == null) {
+            return new java.net.InetSocketAddress(java.net.InetAddress.getLoopbackAddress(), 0);
+        }
+        // Paper end
+        return this.channel.remoteAddress();
+    }
+    // Spigot End
 }
