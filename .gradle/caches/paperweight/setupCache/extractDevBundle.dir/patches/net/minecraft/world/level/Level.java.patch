--- a/net/minecraft/world/level/Level.java
+++ b/net/minecraft/world/level/Level.java
@@ -1,10 +1,16 @@
 package net.minecraft.world.level;
 
+import co.aikar.timings.Timing;
+import co.aikar.timings.Timings;
+import com.destroystokyo.paper.event.server.ServerExceptionEvent;
+import com.destroystokyo.paper.exception.ServerInternalException;
+import com.google.common.base.MoreObjects;
 import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Objects;
 import java.util.Random;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
@@ -22,8 +28,10 @@
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MCUtil;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundSource;
 import net.minecraft.tags.TagContainer;
@@ -34,6 +42,7 @@
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.boss.EnderDragonPart;
 import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
+import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.crafting.RecipeManager;
@@ -45,8 +54,10 @@
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.TickingBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.border.BorderChangeListener;
 import net.minecraft.world.level.border.WorldBorder;
 import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkSource;
 import net.minecraft.world.level.chunk.ChunkStatus;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.dimension.DimensionType;
@@ -61,11 +72,36 @@
 import net.minecraft.world.level.storage.LevelData;
 import net.minecraft.world.level.storage.WritableLevelData;
 import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.shapes.BooleanOp;
+import net.minecraft.world.phys.shapes.CollisionContext;
+import net.minecraft.world.phys.shapes.Shapes;
+import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.scores.Scoreboard;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+// CraftBukkit start
+import java.util.HashMap;
+import java.util.Map;
+import net.minecraft.network.protocol.game.ClientboundSetBorderCenterPacket;
+import net.minecraft.network.protocol.game.ClientboundSetBorderLerpSizePacket;
+import net.minecraft.network.protocol.game.ClientboundSetBorderSizePacket;
+import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDelayPacket;
+import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDistancePacket;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.v1_17_R1.CraftServer;
+import org.bukkit.craftbukkit.v1_17_R1.CraftWorld;
+import org.bukkit.craftbukkit.v1_17_R1.block.CapturedBlockState;
+import org.bukkit.craftbukkit.v1_17_R1.block.CraftBlockState;
+import org.bukkit.craftbukkit.v1_17_R1.block.data.CraftBlockData;
+import org.bukkit.craftbukkit.v1_17_R1.util.CraftNamespacedKey;
+import org.bukkit.event.block.BlockPhysicsEvent;
+import org.bukkit.event.world.GenericGameEvent;
+// CraftBukkit end
+
 public abstract class Level implements LevelAccessor, AutoCloseable {
+
     protected static final Logger LOGGER = LogManager.getLogger();
     public static final Codec<ResourceKey<Level>> RESOURCE_KEY_CODEC = ResourceLocation.CODEC.xmap(ResourceKey.elementKey(Registry.DIMENSION_REGISTRY), ResourceKey::location);
     public static final ResourceKey<Level> OVERWORLD = ResourceKey.create(Registry.DIMENSION_REGISTRY, new ResourceLocation("overworld"));
@@ -79,41 +115,123 @@
     public static final int TICKS_PER_DAY = 24000;
     public static final int MAX_ENTITY_SPAWN_Y = 20000000;
     public static final int MIN_ENTITY_SPAWN_Y = -20000000;
-    protected final List<TickingBlockEntity> blockEntityTickers = Lists.newArrayList();
+    protected final List<TickingBlockEntity> blockEntityTickers = Lists.newArrayList(); public final int getTotalTileEntityTickers() { return this.blockEntityTickers.size(); } // Paper
     private final List<TickingBlockEntity> pendingBlockEntityTickers = Lists.newArrayList();
     private boolean tickingBlockEntities;
-    private final Thread thread;
+    public final Thread thread;
     private final boolean isDebug;
     private int skyDarken;
     protected int randValue = (new Random()).nextInt();
     protected final int addend = 1013904223;
     protected float oRainLevel;
-    protected float rainLevel;
+    public float rainLevel;
     protected float oThunderLevel;
-    protected float thunderLevel;
+    public float thunderLevel;
     public final Random random = new Random();
     private final DimensionType dimensionType;
-    protected final WritableLevelData levelData;
+    public final WritableLevelData levelData;
     private final Supplier<ProfilerFiller> profiler;
     public final boolean isClientSide;
     private final WorldBorder worldBorder;
     private final BiomeManager biomeManager;
     private final ResourceKey<Level> dimension;
 
-    protected Level(WritableLevelData properties, ResourceKey<Level> registryRef, DimensionType dimensionType, Supplier<ProfilerFiller> profiler, boolean isClient, boolean debugWorld, long seed) {
-        this.profiler = profiler;
-        this.levelData = properties;
-        this.dimensionType = dimensionType;
-        this.dimension = registryRef;
-        this.isClientSide = isClient;
-        if (dimensionType.coordinateScale() != 1.0D) {
+    // CraftBukkit start Added the following
+    private final ResourceKey<DimensionType> typeKey;
+    private final CraftWorld world;
+    public boolean pvpMode;
+    public boolean keepSpawnInMemory = true;
+    public org.bukkit.generator.ChunkGenerator generator;
+    public static final boolean DEBUG_ENTITIES = Boolean.getBoolean("debug.entities"); // Paper
+
+    public boolean preventPoiUpdated = false; // CraftBukkit - SPIGOT-5710
+    public boolean captureBlockStates = false;
+    public boolean captureTreeGeneration = false;
+    public Map<BlockPos, org.bukkit.craftbukkit.v1_17_R1.block.CraftBlockState> capturedBlockStates = new java.util.LinkedHashMap<>(); // Paper
+    public Map<BlockPos, BlockEntity> capturedTileEntities = new java.util.LinkedHashMap<>(); // Paper
+    public List<ItemEntity> captureDrops;
+    public long ticksPerAnimalSpawns;
+    public long ticksPerMonsterSpawns;
+    public long ticksPerWaterSpawns;
+    public long ticksPerWaterAmbientSpawns;
+    public long ticksPerAmbientSpawns;
+    // Paper start
+    public int wakeupInactiveRemainingAnimals;
+    public int wakeupInactiveRemainingFlying;
+    public int wakeupInactiveRemainingMonsters;
+    public int wakeupInactiveRemainingVillagers;
+    // Paper end
+    public boolean populating;
+    public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
+
+    public final com.destroystokyo.paper.PaperWorldConfig paperConfig; // Paper
+    public final com.destroystokyo.paper.antixray.ChunkPacketBlockController chunkPacketBlockController; // Paper - Anti-Xray
+
+    public final co.aikar.timings.WorldTimingsHandler timings; // Paper
+    public static BlockPos lastPhysicsProblem; // Spigot
+    private org.spigotmc.TickLimiter entityLimiter;
+    private org.spigotmc.TickLimiter tileLimiter;
+    private int tileTickPosition;
+    public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<>(); // Paper - Optimize explosions
+    public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos; // Paper - Move from Map in BlockRedstoneTorch to here
+
+    // Paper start - fix and optimise world upgrading
+    // copied from below
+    public static ResourceKey<DimensionType> getDimensionKey(DimensionType manager) {
+        return ((org.bukkit.craftbukkit.v1_17_R1.CraftServer)org.bukkit.Bukkit.getServer()).getHandle().getServer().registryHolder.ownedRegistryOrThrow(net.minecraft.core.Registry.DIMENSION_TYPE_REGISTRY).getResourceKey(manager).orElseThrow(() -> {
+            return new IllegalStateException("Unregistered dimension type: " + manager);
+        });
+    }
+    // Paper end - fix and optimise world upgrading
+
+    public CraftWorld getWorld() {
+        return this.world;
+    }
+
+    public CraftServer getCraftServer() {
+        return (CraftServer) Bukkit.getServer();
+    }
+
+    // Paper start
+    @Override
+    public boolean hasChunk(int chunkX, int chunkZ) {
+        return ((ServerLevel) this).getChunkIfLoaded(chunkX, chunkZ) != null;
+    }
+    // Paper end
+
+    public ResourceKey<DimensionType> getTypeKey() {
+        return this.typeKey;
+    }
+
+    protected Level(WritableLevelData worlddatamutable, ResourceKey<Level> resourcekey, final DimensionType dimensionmanager, Supplier<ProfilerFiller> supplier, boolean flag, boolean flag1, long i, org.bukkit.generator.ChunkGenerator gen, org.bukkit.World.Environment env, java.util.concurrent.Executor executor) { // Paper - Anti-Xray - Pass executor
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) worlddatamutable).getLevelName()); // Spigot
+        this.paperConfig = new com.destroystokyo.paper.PaperWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) worlddatamutable).getLevelName(), this.spigotConfig); // Paper
+        this.generator = gen;
+        this.world = new CraftWorld((ServerLevel) this, gen, env);
+        this.ticksPerAnimalSpawns = this.getCraftServer().getTicksPerAnimalSpawns(); // CraftBukkit
+        this.ticksPerMonsterSpawns = this.getCraftServer().getTicksPerMonsterSpawns(); // CraftBukkit
+        this.ticksPerWaterSpawns = this.getCraftServer().getTicksPerWaterSpawns(); // CraftBukkit
+        this.ticksPerWaterAmbientSpawns = this.getCraftServer().getTicksPerWaterAmbientSpawns(); // CraftBukkit
+        this.ticksPerAmbientSpawns = this.getCraftServer().getTicksPerAmbientSpawns(); // CraftBukkit
+        this.typeKey = (ResourceKey) this.getCraftServer().getHandle().getServer().registryHolder.registryOrThrow(Registry.DIMENSION_TYPE_REGISTRY).getResourceKey(dimensionmanager).orElseThrow(() -> {
+            return new IllegalStateException("Unregistered dimension type: " + dimensionmanager);
+        });
+        // CraftBukkit end
+        this.profiler = supplier;
+        this.levelData = worlddatamutable;
+        this.dimensionType = dimensionmanager;
+        this.dimension = resourcekey;
+        this.isClientSide = flag;
+        if (dimensionmanager.coordinateScale() != 1.0D) {
             this.worldBorder = new WorldBorder() {
+                @Override
                 public double getCenterX() {
-                    return super.getCenterX() / dimensionType.coordinateScale();
+                    return super.getCenterX(); // CraftBukkit
                 }
 
+                @Override
                 public double getCenterZ() {
-                    return super.getCenterZ() / dimensionType.coordinateScale();
+                    return super.getCenterZ(); // CraftBukkit
                 }
             };
         } else {
@@ -121,25 +239,115 @@
         }
 
         this.thread = Thread.currentThread();
-        this.biomeManager = new BiomeManager(this, seed, dimensionType.getBiomeZoomer());
-        this.isDebug = debugWorld;
+        this.biomeManager = new BiomeManager(this, i, dimensionmanager.getBiomeZoomer());
+        this.isDebug = flag1;
+        // CraftBukkit start
+        this.getWorldBorder().world = (ServerLevel) this;
+        // From PlayerList.setPlayerFileData
+        this.getWorldBorder().addListener(new BorderChangeListener() {
+            public void onBorderSizeSet(WorldBorder border, double size) {
+                Level.this.getCraftServer().getHandle().sendAll(new ClientboundSetBorderSizePacket(border), border.world);
+            }
+
+            public void onBorderSizeLerping(WorldBorder border, double fromSize, double toSize, long time) {
+                Level.this.getCraftServer().getHandle().sendAll(new ClientboundSetBorderLerpSizePacket(border), border.world);
+            }
+
+            public void onBorderCenterSet(WorldBorder border, double centerX, double centerZ) {
+                Level.this.getCraftServer().getHandle().sendAll(new ClientboundSetBorderCenterPacket(border), border.world);
+            }
+
+            public void onBorderSetWarningTime(WorldBorder border, int warningTime) {
+                Level.this.getCraftServer().getHandle().sendAll(new ClientboundSetBorderWarningDelayPacket(border), border.world);
+            }
+
+            public void onBorderSetWarningBlocks(WorldBorder border, int warningBlockDistance) {
+                Level.this.getCraftServer().getHandle().sendAll(new ClientboundSetBorderWarningDistancePacket(border), border.world);
+            }
+
+            public void onBorderSetDamagePerBlock(WorldBorder border, double damagePerBlock) {
+            }
+
+            public void onBorderSetDamageSafeZOne(WorldBorder border, double safeZoneRadius) {
+            }
+        });
+        // CraftBukkit end
+        timings = new co.aikar.timings.WorldTimingsHandler(this); // Paper - code below can generate new world and access timings
+        this.keepSpawnInMemory = this.paperConfig.keepSpawnInMemory; // Paper
+        this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
+        this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
+        this.chunkPacketBlockController = this.paperConfig.antiXray ?
+            new com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray(this, executor)
+            : com.destroystokyo.paper.antixray.ChunkPacketBlockController.NO_OPERATION_INSTANCE; // Paper - Anti-Xray
     }
 
+    // Paper start
+    // ret true if no collision
+    public final boolean checkEntityCollision(BlockState data, Entity source, CollisionContext voxelshapedcollision,
+                                              BlockPos position, boolean checkCanSee) {
+        // Copied from IWorldReader#a(IBlockData, BlockPosition, VoxelShapeCollision) & EntityAccess#a(Entity, VoxelShape)
+        VoxelShape voxelshape = data.getCollisionShape(this, position, voxelshapedcollision);
+        if (voxelshape.isEmpty()) {
+            return true;
+        }
+
+        voxelshape = voxelshape.move((double) position.getX(), (double) position.getY(), (double) position.getZ());
+        if (voxelshape.isEmpty()) {
+            return true;
+        }
+
+        List<Entity> entities = this.getEntities(null, voxelshape.bounds());
+        for (int i = 0, len = entities.size(); i < len; ++i) {
+            Entity entity = entities.get(i);
+
+            if (checkCanSee && source instanceof net.minecraft.server.level.ServerPlayer && entity instanceof net.minecraft.server.level.ServerPlayer
+                && !((net.minecraft.server.level.ServerPlayer) source).getBukkitEntity().canSee(((net.minecraft.server.level.ServerPlayer) entity).getBukkitEntity())) {
+                continue;
+            }
+
+            // !entity1.dead && entity1.i && (entity == null || !entity1.x(entity));
+            // elide the last check since vanilla calls with entity = null
+            // only we care about the source for the canSee check
+            if (entity.isRemoved() || !entity.blocksBuilding) {
+                continue;
+            }
+
+            if (Shapes.joinIsNotEmpty(voxelshape, Shapes.create(entity.getBoundingBox()), BooleanOp.AND)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+    // Paper end
+    // Paper start - moved up from ServerLevel
+    public BlockPos getSharedSpawnPos() {
+        BlockPos blockposition = new BlockPos(this.levelData.getXSpawn(), this.levelData.getYSpawn(), this.levelData.getZSpawn());
+
+        if (!this.getWorldBorder().isWithinBounds(blockposition)) {
+            blockposition = this.getHeightmapPos(Heightmap.Types.MOTION_BLOCKING, new BlockPos(this.getWorldBorder().getCenterX(), 0.0D, this.getWorldBorder().getCenterZ()));
+        }
+
+        return blockposition;
+    }
+    // Paper end
+    @Override
     public boolean isClientSide() {
         return this.isClientSide;
     }
 
     @Nullable
+    @Override
     public MinecraftServer getServer() {
         return null;
     }
 
     public boolean isInWorldBounds(BlockPos pos) {
-        return !this.isOutsideBuildHeight(pos) && isInWorldBoundsHorizontal(pos);
+        return pos.isValidLocation(this); // Paper - use better/optimized check
     }
 
     public static boolean isInSpawnableBounds(BlockPos pos) {
-        return !isOutsideSpawnableHeight(pos.getY()) && isInWorldBoundsHorizontal(pos);
+        return !Level.isOutsideSpawnableHeight(pos.getY()) && Level.isInWorldBoundsHorizontal(pos);
     }
 
     private static boolean isInWorldBoundsHorizontal(BlockPos pos) {
@@ -150,112 +358,291 @@
         return y < -20000000 || y >= 20000000;
     }
 
-    public LevelChunk getChunkAt(BlockPos pos) {
+    public final LevelChunk getChunkAt(BlockPos pos) { // Paper - help inline
         return this.getChunk(SectionPos.blockToSectionCoord(pos.getX()), SectionPos.blockToSectionCoord(pos.getZ()));
     }
 
-    public LevelChunk getChunk(int i, int j) {
-        return (LevelChunk)this.getChunk(i, j, ChunkStatus.FULL);
+    @Override
+    public final LevelChunk getChunk(int chunkX, int chunkZ) { // Paper - final to help inline
+        return (LevelChunk) this.getChunk(chunkX, chunkZ, ChunkStatus.FULL, true); // Paper - avoid a method jump
     }
 
+    // Paper start - if loaded
     @Nullable
-    public ChunkAccess getChunk(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create) {
-        ChunkAccess chunkAccess = this.getChunkSource().getChunk(chunkX, chunkZ, leastStatus, create);
-        if (chunkAccess == null && create) {
+    @Override
+    public final ChunkAccess getChunkIfLoadedImmediately(int x, int z) {
+        return ((ServerLevel)this).chunkSource.getChunkAtIfLoadedImmediately(x, z);
+    }
+
+    @Override
+    public final BlockState getTypeIfLoaded(BlockPos blockposition) {
+        // CraftBukkit start - tree generation
+        if (captureTreeGeneration) {
+            CraftBlockState previous = capturedBlockStates.get(blockposition);
+            if (previous != null) {
+                return previous.getHandle();
+            }
+        }
+        // CraftBukkit end
+        if (!isInWorldBounds(blockposition)) {
+            return Blocks.AIR.defaultBlockState();
+        }
+        ChunkAccess chunk = this.getChunkIfLoadedImmediately(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+
+        return chunk == null ? null : chunk.getBlockState(blockposition);
+    }
+
+    @Override
+    public final FluidState getFluidIfLoaded(BlockPos blockposition) {
+        ChunkAccess chunk = this.getChunkIfLoadedImmediately(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+
+        return chunk == null ? null : chunk.getFluidState(blockposition);
+    }
+
+    @Override
+    public final boolean hasChunkAt(BlockPos pos) {
+        return getChunkIfLoaded(pos.getX() >> 4, pos.getZ() >> 4) != null; // Paper
+    }
+
+    public final boolean isLoadedAndInBounds(BlockPos blockposition) { // Paper - final for inline
+        return getWorldBorder().isWithinBounds(blockposition) && getChunkIfLoadedImmediately(blockposition.getX() >> 4, blockposition.getZ() >> 4) != null;
+    }
+
+    public LevelChunk getChunkIfLoaded(int x, int z) { // Overridden in WorldServer for ABI compat which has final
+        return ((ServerLevel) this).getChunkSource().getChunkAtIfLoadedImmediately(x, z);
+    }
+    public final LevelChunk getChunkIfLoaded(BlockPos blockposition) {
+        return ((ServerLevel) this).getChunkSource().getChunkAtIfLoadedImmediately(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+    }
+
+    //  reduces need to do isLoaded before getType
+    public final BlockState getTypeIfLoadedAndInBounds(BlockPos blockposition) {
+        return getWorldBorder().isWithinBounds(blockposition) ? getTypeIfLoaded(blockposition) : null;
+    }
+    // Paper end
+
+    @Override
+    public final ChunkAccess getChunk(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create) { // Paper - final for inline
+        ChunkAccess ichunkaccess = this.getChunkSource().getChunk(chunkX, chunkZ, leastStatus, create);
+
+        if (ichunkaccess == null && create) {
             throw new IllegalStateException("Should always be able to create a chunk!");
         } else {
-            return chunkAccess;
+            return ichunkaccess;
         }
     }
 
-    public boolean setBlock(BlockPos pos, BlockState state, int flags) {
+    @Override
+    public final boolean setBlock(BlockPos pos, BlockState state, int flags) { // Paper - final for inline
         return this.setBlock(pos, state, flags, 512);
     }
 
+    @Override
     public boolean setBlock(BlockPos pos, BlockState state, int flags, int maxUpdateDepth) {
+        // CraftBukkit start - tree generation
+        if (this.captureTreeGeneration) {
+            // Paper start
+            BlockState type = getBlockState(pos);
+            if (!type.isDestroyable()) return false;
+            // Paper end
+            CraftBlockState blockstate = this.capturedBlockStates.get(pos);
+            if (blockstate == null) {
+                blockstate = CapturedBlockState.getTreeBlockState(this, pos, flags);
+                this.capturedBlockStates.put(pos.immutable(), blockstate);
+            }
+            blockstate.setData(state);
+            return true;
+        }
+        // CraftBukkit end
         if (this.isOutsideBuildHeight(pos)) {
             return false;
         } else if (!this.isClientSide && this.isDebug()) {
             return false;
         } else {
-            LevelChunk levelChunk = this.getChunkAt(pos);
+            LevelChunk chunk = this.getChunkAt(pos);
             Block block = state.getBlock();
-            BlockState blockState = levelChunk.setBlockState(pos, state, (flags & 64) != 0);
-            if (blockState == null) {
+
+            // CraftBukkit start - capture blockstates
+            boolean captured = false;
+            if (this.captureBlockStates && !this.capturedBlockStates.containsKey(pos)) {
+                CraftBlockState blockstate = (CraftBlockState) world.getBlockAt(pos.getX(), pos.getY(), pos.getZ()).getState(); // Paper - use CB getState to get a suitable snapshot
+                blockstate.setFlag(flags); // Paper - set flag
+                this.capturedBlockStates.put(pos.immutable(), blockstate);
+                captured = true;
+            }
+            // CraftBukkit end
+
+            BlockState iblockdata1 = chunk.setType(pos, state, (flags & 64) != 0, (flags & 1024) == 0); // CraftBukkit custom NO_PLACE flag
+            this.chunkPacketBlockController.onBlockChange(this, pos, state, iblockdata1, flags, maxUpdateDepth); // Paper - Anti-Xray
+
+            if (iblockdata1 == null) {
+                // CraftBukkit start - remove blockstate if failed (or the same)
+                if (this.captureBlockStates && captured) {
+                    this.capturedBlockStates.remove(pos);
+                }
+                // CraftBukkit end
                 return false;
             } else {
-                BlockState blockState2 = this.getBlockState(pos);
-                if ((flags & 128) == 0 && blockState2 != blockState && (blockState2.getLightBlock(this, pos) != blockState.getLightBlock(this, pos) || blockState2.getLightEmission() != blockState.getLightEmission() || blockState2.useShapeForLightOcclusion() || blockState.useShapeForLightOcclusion())) {
+                BlockState iblockdata2 = this.getBlockState(pos);
+
+                if ((flags & 128) == 0 && iblockdata2 != iblockdata1 && (iblockdata2.getLightBlock((BlockGetter) this, pos) != iblockdata1.getLightBlock((BlockGetter) this, pos) || iblockdata2.getLightEmission() != iblockdata1.getLightEmission() || iblockdata2.useShapeForLightOcclusion() || iblockdata1.useShapeForLightOcclusion())) {
                     this.getProfiler().push("queueCheckLight");
                     this.getChunkSource().getLightEngine().checkBlock(pos);
                     this.getProfiler().pop();
                 }
 
-                if (blockState2 == state) {
-                    if (blockState != blockState2) {
-                        this.setBlocksDirty(pos, blockState, blockState2);
+                /*
+                if (iblockdata2 == iblockdata) {
+                    if (iblockdata1 != iblockdata2) {
+                        this.b(blockposition, iblockdata1, iblockdata2);
                     }
 
-                    if ((flags & 2) != 0 && (!this.isClientSide || (flags & 4) == 0) && (this.isClientSide || levelChunk.getFullStatus() != null && levelChunk.getFullStatus().isOrAfter(ChunkHolder.FullChunkStatus.TICKING))) {
-                        this.sendBlockUpdated(pos, blockState, state, flags);
+                    if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk.getState() != null && chunk.getState().isAtLeast(PlayerChunk.State.TICKING))) {
+                        this.notify(blockposition, iblockdata1, iblockdata, i);
                     }
 
-                    if ((flags & 1) != 0) {
-                        this.blockUpdated(pos, blockState.getBlock());
-                        if (!this.isClientSide && state.hasAnalogOutputSignal()) {
-                            this.updateNeighbourForOutputSignal(pos, block);
+                    if ((i & 1) != 0) {
+                        this.update(blockposition, iblockdata1.getBlock());
+                        if (!this.isClientSide && iblockdata.isComplexRedstone()) {
+                            this.updateAdjacentComparators(blockposition, block);
                         }
                     }
 
-                    if ((flags & 16) == 0 && maxUpdateDepth > 0) {
-                        int i = flags & -34;
-                        blockState.updateIndirectNeighbourShapes(this, pos, i, maxUpdateDepth - 1);
-                        state.updateNeighbourShapes(this, pos, i, maxUpdateDepth - 1);
-                        state.updateIndirectNeighbourShapes(this, pos, i, maxUpdateDepth - 1);
+                    if ((i & 16) == 0 && j > 0) {
+                        int k = i & -34;
+
+                        iblockdata1.b(this, blockposition, k, j - 1);
+                        iblockdata.a((GeneratorAccess) this, blockposition, k, j - 1);
+                        iblockdata.b(this, blockposition, k, j - 1);
                     }
 
-                    this.onBlockStateChange(pos, blockState, blockState2);
+                    this.a(blockposition, iblockdata1, iblockdata2);
+                }
+                */
+
+                // CraftBukkit start
+                if (!this.captureBlockStates) { // Don't notify clients or update physics while capturing blockstates
+                    // Modularize client and physic updates
+                    // Spigot start
+                    try {
+                        this.notifyAndUpdatePhysics(pos, chunk, iblockdata1, state, iblockdata2, flags, maxUpdateDepth);
+                    } catch (StackOverflowError ex) {
+                        Level.lastPhysicsProblem = new BlockPos(pos);
+                    }
+                    // Spigot end
                 }
+                // CraftBukkit end
 
                 return true;
             }
         }
     }
 
-    public void onBlockStateChange(BlockPos pos, BlockState oldBlock, BlockState newBlock) {
+    // CraftBukkit start - Split off from above in order to directly send client and physic updates
+    public void notifyAndUpdatePhysics(BlockPos blockposition, LevelChunk chunk, BlockState oldBlock, BlockState newBlock, BlockState actualBlock, int i, int j) {
+        BlockState iblockdata = newBlock;
+        BlockState iblockdata1 = oldBlock;
+        BlockState iblockdata2 = actualBlock;
+        if (iblockdata2 == iblockdata) {
+            if (iblockdata1 != iblockdata2) {
+                this.setBlocksDirty(blockposition, iblockdata1, iblockdata2);
+            }
+
+            if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || (chunk.getFullStatus() != null && chunk.getFullStatus().isOrAfter(ChunkHolder.FullChunkStatus.TICKING)))) { // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement // Paper - diff on change, see below
+                this.sendBlockUpdated(blockposition, iblockdata1, iblockdata, i);
+                // Paper start - per player view distance - allow block updates for non-ticking chunks in player view distance
+                // if copied from above
+            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((ServerLevel)this).getChunkSource().chunkMap.playerViewDistanceBroadcastMap.getObjectsInRange(MCUtil.getCoordinateKey(blockposition)) != null)) {
+                ((ServerLevel)this).getChunkSource().blockChanged(blockposition);
+                // Paper end - per player view distance
+            }
+
+            if ((i & 1) != 0) {
+                this.blockUpdated(blockposition, iblockdata1.getBlock());
+                if (!this.isClientSide && iblockdata.hasAnalogOutputSignal()) {
+                    this.updateNeighbourForOutputSignal(blockposition, newBlock.getBlock());
+                }
+            }
+
+            if ((i & 16) == 0 && j > 0) {
+                int k = i & -34;
+
+                // CraftBukkit start
+                iblockdata1.updateIndirectNeighbourShapes(this, blockposition, k, j - 1); // Don't call an event for the old block to limit event spam
+                CraftWorld world = ((ServerLevel) this).getWorld();
+                if (world != null && ((ServerLevel)this).hasPhysicsEvent) { // Paper
+                    BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftBlockData.fromData(iblockdata));
+                    this.getCraftServer().getPluginManager().callEvent(event);
+
+                    if (event.isCancelled()) {
+                        return;
+                    }
+                }
+                // CraftBukkit end
+                iblockdata.updateNeighbourShapes((LevelAccessor) this, blockposition, k, j - 1);
+                iblockdata.updateIndirectNeighbourShapes(this, blockposition, k, j - 1);
+            }
+
+            // CraftBukkit start - SPIGOT-5710
+            if (!this.preventPoiUpdated) {
+                this.onBlockStateChange(blockposition, iblockdata1, iblockdata2);
+            }
+            // CraftBukkit end
+        }
     }
+    // CraftBukkit end
+
+    public void onBlockStateChange(BlockPos pos, BlockState oldBlock, BlockState newBlock) {}
 
+    @Override
     public boolean removeBlock(BlockPos pos, boolean move) {
-        FluidState fluidState = this.getFluidState(pos);
-        return this.setBlock(pos, fluidState.createLegacyBlock(), 3 | (move ? 64 : 0));
+        FluidState fluid = this.getFluidState(pos);
+
+        return this.setBlock(pos, fluid.createLegacyBlock(), 3 | (move ? 64 : 0));
     }
 
+    @Override
     public boolean destroyBlock(BlockPos pos, boolean drop, @Nullable Entity breakingEntity, int maxUpdateDepth) {
-        BlockState blockState = this.getBlockState(pos);
-        if (blockState.isAir()) {
+        BlockState iblockdata = this.getBlockState(pos);
+
+        if (iblockdata.isAir()) {
             return false;
         } else {
-            FluidState fluidState = this.getFluidState(pos);
-            if (!(blockState.getBlock() instanceof BaseFireBlock)) {
-                this.levelEvent(2001, pos, Block.getId(blockState));
+            FluidState fluid = this.getFluidState(pos);
+            // Paper start - while the above setAir method is named same and looks very similar
+            // they are NOT used with same intent and the above should not fire this event. The above method is more of a BlockSetToAirEvent,
+            // it doesn't imply destruction of a block that plays a sound effect / drops an item.
+            boolean playEffect = true;
+            if (com.destroystokyo.paper.event.block.BlockDestroyEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                com.destroystokyo.paper.event.block.BlockDestroyEvent event = new com.destroystokyo.paper.event.block.BlockDestroyEvent(MCUtil.toBukkitBlock(this, pos), fluid.createLegacyBlock().createCraftBlockData(), drop);
+                if (!event.callEvent()) {
+                    return false;
+                }
+                playEffect = event.playEffect();
+            }
+            // Paper end
+
+            if (playEffect && !(iblockdata.getBlock() instanceof BaseFireBlock)) { // Paper
+                this.levelEvent(2001, pos, Block.getId(iblockdata));
             }
 
             if (drop) {
-                BlockEntity blockEntity = blockState.hasBlockEntity() ? this.getBlockEntity(pos) : null;
-                Block.dropResources(blockState, this, pos, blockEntity, breakingEntity, ItemStack.EMPTY);
+                BlockEntity tileentity = iblockdata.hasBlockEntity() ? this.getBlockEntity(pos) : null;
+
+                Block.dropResources(iblockdata, this, pos, tileentity, breakingEntity, ItemStack.EMPTY);
             }
 
-            boolean bl = this.setBlock(pos, fluidState.createLegacyBlock(), 3, maxUpdateDepth);
-            if (bl) {
+            boolean flag1 = this.setBlock(pos, fluid.createLegacyBlock(), 3, maxUpdateDepth);
+
+            if (flag1) {
                 this.gameEvent(breakingEntity, GameEvent.BLOCK_DESTROY, pos);
             }
 
-            return bl;
+            return flag1;
         }
     }
 
-    public void addDestroyBlockEffect(BlockPos pos, BlockState state) {
-    }
+    public void addDestroyBlockEffect(BlockPos pos, BlockState state) {}
 
     public boolean setBlockAndUpdate(BlockPos pos, BlockState state) {
         return this.setBlock(pos, state, 3);
@@ -263,10 +650,10 @@
 
     public abstract void sendBlockUpdated(BlockPos pos, BlockState oldState, BlockState newState, int flags);
 
-    public void setBlocksDirty(BlockPos pos, BlockState old, BlockState updated) {
-    }
+    public void setBlocksDirty(BlockPos pos, BlockState old, BlockState updated) {}
 
     public void updateNeighborsAt(BlockPos pos, Block block) {
+        if (captureBlockStates) { return; } // Paper - Cancel all physics during placement
         this.neighborChanged(pos.west(), block, pos);
         this.neighborChanged(pos.east(), block, pos);
         this.neighborChanged(pos.below(), block, pos);
@@ -304,60 +691,91 @@
 
     public void neighborChanged(BlockPos pos, Block sourceBlock, BlockPos neighborPos) {
         if (!this.isClientSide) {
-            BlockState blockState = this.getBlockState(pos);
+            BlockState iblockdata = this.getBlockState(pos);
 
             try {
-                blockState.neighborChanged(this, pos, sourceBlock, neighborPos, false);
-            } catch (Throwable var8) {
-                CrashReport crashReport = CrashReport.forThrowable(var8, "Exception while updating neighbours");
-                CrashReportCategory crashReportCategory = crashReport.addCategory("Block being updated");
-                crashReportCategory.setDetail("Source block type", () -> {
+                // CraftBukkit start
+                CraftWorld world = ((ServerLevel) this).getWorld();
+                if (world != null && ((ServerLevel)this).hasPhysicsEvent) { // Paper
+                    BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(pos.getX(), pos.getY(), pos.getZ()), CraftBlockData.fromData(iblockdata), world.getBlockAt(neighborPos.getX(), neighborPos.getY(), neighborPos.getZ()));
+                    this.getCraftServer().getPluginManager().callEvent(event);
+
+                    if (event.isCancelled()) {
+                        return;
+                    }
+                }
+                // CraftBukkit end
+                iblockdata.neighborChanged(this, pos, sourceBlock, neighborPos, false);
+            // Spigot Start
+            } catch (StackOverflowError ex) {
+                Level.lastPhysicsProblem = new BlockPos(pos);
+                // Spigot End
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception while updating neighbours");
+                CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Block being updated");
+
+                crashreportsystemdetails.setDetail("Source block type", () -> {
                     try {
                         return String.format("ID #%s (%s // %s)", Registry.BLOCK.getKey(sourceBlock), sourceBlock.getDescriptionId(), sourceBlock.getClass().getCanonicalName());
-                    } catch (Throwable var2) {
+                    } catch (Throwable throwable1) {
                         return "ID #" + Registry.BLOCK.getKey(sourceBlock);
                     }
                 });
-                CrashReportCategory.populateBlockDetails(crashReportCategory, this, pos, blockState);
-                throw new ReportedException(crashReport);
+                CrashReportCategory.populateBlockDetails(crashreportsystemdetails, this, pos, iblockdata);
+                throw new ReportedException(crashreport);
             }
         }
     }
 
+    @Override
     public int getHeight(Heightmap.Types heightmap, int x, int z) {
-        int j;
+        int k;
+
         if (x >= -30000000 && z >= -30000000 && x < 30000000 && z < 30000000) {
             if (this.hasChunk(SectionPos.blockToSectionCoord(x), SectionPos.blockToSectionCoord(z))) {
-                j = this.getChunk(SectionPos.blockToSectionCoord(x), SectionPos.blockToSectionCoord(z)).getHeight(heightmap, x & 15, z & 15) + 1;
+                k = this.getChunk(SectionPos.blockToSectionCoord(x), SectionPos.blockToSectionCoord(z)).getHeight(heightmap, x & 15, z & 15) + 1;
             } else {
-                j = this.getMinBuildHeight();
+                k = this.getMinBuildHeight();
             }
         } else {
-            j = this.getSeaLevel() + 1;
+            k = this.getSeaLevel() + 1;
         }
 
-        return j;
+        return k;
     }
 
+    @Override
     public LevelLightEngine getLightEngine() {
         return this.getChunkSource().getLightEngine();
     }
 
+    @Override
     public BlockState getBlockState(BlockPos pos) {
+        // CraftBukkit start - tree generation
+        if (this.captureTreeGeneration) {
+            CraftBlockState previous = this.capturedBlockStates.get(pos); // Paper
+            if (previous != null) {
+                return previous.getHandle();
+            }
+        }
+        // CraftBukkit end
         if (this.isOutsideBuildHeight(pos)) {
             return Blocks.VOID_AIR.defaultBlockState();
         } else {
-            LevelChunk levelChunk = this.getChunk(SectionPos.blockToSectionCoord(pos.getX()), SectionPos.blockToSectionCoord(pos.getZ()));
-            return levelChunk.getBlockState(pos);
+            ChunkAccess chunk = this.getChunk(pos.getX() >> 4, pos.getZ() >> 4, ChunkStatus.FULL, true); // Paper - manually inline to reduce hops and avoid unnecessary null check to reduce total byte code size, this should never return null and if it does we will see it the next line but the real stack trace will matter in the chunk engine
+
+            return chunk.getBlockState(pos);
         }
     }
 
+    @Override
     public FluidState getFluidState(BlockPos pos) {
         if (this.isOutsideBuildHeight(pos)) {
             return Fluids.EMPTY.defaultFluidState();
         } else {
-            LevelChunk levelChunk = this.getChunkAt(pos);
-            return levelChunk.getFluidState(pos);
+            LevelChunk chunk = this.getChunkAt(pos);
+
+            return chunk.getFluidState(pos);
         }
     }
 
@@ -369,32 +787,30 @@
         return !this.dimensionType().hasFixedTime() && !this.isDay();
     }
 
+    @Override
     public void playSound(@Nullable Player player, BlockPos pos, SoundEvent sound, SoundSource category, float volume, float pitch) {
-        this.playSound(player, (double)pos.getX() + 0.5D, (double)pos.getY() + 0.5D, (double)pos.getZ() + 0.5D, sound, category, volume, pitch);
+        this.playSound(player, (double) pos.getX() + 0.5D, (double) pos.getY() + 0.5D, (double) pos.getZ() + 0.5D, sound, category, volume, pitch);
     }
 
     public abstract void playSound(@Nullable Player player, double x, double y, double z, SoundEvent sound, SoundSource category, float volume, float pitch);
 
     public abstract void playSound(@Nullable Player player, Entity entity, SoundEvent sound, SoundSource category, float volume, float pitch);
 
-    public void playLocalSound(double x, double y, double z, SoundEvent sound, SoundSource category, float volume, float pitch, boolean useDistance) {
-    }
+    public void playLocalSound(double x, double y, double z, SoundEvent sound, SoundSource category, float volume, float pitch, boolean useDistance) {}
 
-    public void addParticle(ParticleOptions parameters, double x, double y, double z, double velocityX, double velocityY, double velocityZ) {
-    }
+    @Override
+    public void addParticle(ParticleOptions parameters, double x, double y, double z, double velocityX, double velocityY, double velocityZ) {}
 
-    public void addParticle(ParticleOptions parameters, boolean alwaysSpawn, double x, double y, double z, double velocityX, double velocityY, double velocityZ) {
-    }
+    public void addParticle(ParticleOptions parameters, boolean alwaysSpawn, double x, double y, double z, double velocityX, double velocityY, double velocityZ) {}
 
-    public void addAlwaysVisibleParticle(ParticleOptions parameters, double x, double y, double z, double velocityX, double velocityY, double velocityZ) {
-    }
+    public void addAlwaysVisibleParticle(ParticleOptions parameters, double x, double y, double z, double velocityX, double velocityY, double velocityZ) {}
 
-    public void addAlwaysVisibleParticle(ParticleOptions parameters, boolean alwaysSpawn, double x, double y, double z, double velocityX, double velocityY, double velocityZ) {
-    }
+    public void addAlwaysVisibleParticle(ParticleOptions parameters, boolean alwaysSpawn, double x, double y, double z, double velocityX, double velocityY, double velocityZ) {}
 
     public float getSunAngle(float tickDelta) {
-        float f = this.getTimeOfDay(tickDelta);
-        return f * ((float)Math.PI * 2F);
+        float f1 = this.getTimeOfDay(tickDelta);
+
+        return f1 * 6.2831855F;
     }
 
     public void addBlockEntityTicker(TickingBlockEntity ticker) {
@@ -402,50 +818,84 @@
     }
 
     protected void tickBlockEntities() {
-        ProfilerFiller profilerFiller = this.getProfiler();
-        profilerFiller.push("blockEntities");
+        ProfilerFiller gameprofilerfiller = this.getProfiler();
+
+        gameprofilerfiller.push("blockEntities");
+        timings.tileEntityPending.startTiming(); // Spigot
         this.tickingBlockEntities = true;
         if (!this.pendingBlockEntityTickers.isEmpty()) {
             this.blockEntityTickers.addAll(this.pendingBlockEntityTickers);
             this.pendingBlockEntityTickers.clear();
         }
+        timings.tileEntityPending.stopTiming(); // Spigot
 
-        Iterator<TickingBlockEntity> iterator = this.blockEntityTickers.iterator();
+        timings.tileEntityTick.startTiming(); // Spigot
+        // Spigot start
+        // Iterator iterator = this.blockEntityTickers.iterator();
+        int tilesThisCycle = 0;
+        var toRemove = new it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet<TickingBlockEntity>(net.minecraft.Util.identityStrategy()); // Paper - use removeAll
+        toRemove.add(null);
+        for (tileTickPosition = 0; tileTickPosition < this.blockEntityTickers.size(); tileTickPosition++) { // Paper - Disable tick limiters
+            this.tileTickPosition = (this.tileTickPosition < this.blockEntityTickers.size()) ? this.tileTickPosition : 0;
+            TickingBlockEntity tickingblockentity = (TickingBlockEntity) this.blockEntityTickers.get(tileTickPosition);
+            // Spigot start
+            if (tickingblockentity == null) {
+                this.getCraftServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
+                tilesThisCycle--;
+                continue;
+            }
+            // Spigot end
 
-        while(iterator.hasNext()) {
-            TickingBlockEntity tickingBlockEntity = iterator.next();
-            if (tickingBlockEntity.isRemoved()) {
-                iterator.remove();
+            if (tickingblockentity.isRemoved()) {
+                // Spigot start
+                tilesThisCycle--;
+                toRemove.add(tickingblockentity); // Paper - use removeAll
+                // Spigot end
             } else {
-                tickingBlockEntity.tick();
+                tickingblockentity.tick();
             }
         }
+        this.blockEntityTickers.removeAll(toRemove);
 
+        timings.tileEntityTick.stopTiming(); // Spigot
         this.tickingBlockEntities = false;
-        profilerFiller.pop();
+        co.aikar.timings.TimingHistory.tileEntityTicks += this.blockEntityTickers.size(); // Paper
+        gameprofilerfiller.pop();
+        spigotConfig.currentPrimedTnt = 0; // Spigot
     }
 
     public <T extends Entity> void guardEntityTick(Consumer<T> tickConsumer, T entity) {
         try {
             tickConsumer.accept(entity);
-        } catch (Throwable var6) {
-            CrashReport crashReport = CrashReport.forThrowable(var6, "Ticking entity");
-            CrashReportCategory crashReportCategory = crashReport.addCategory("Entity being ticked");
-            entity.fillCrashReportCategory(crashReportCategory);
-            throw new ReportedException(crashReport);
+        } catch (Throwable throwable) {
+            if (throwable instanceof ThreadDeath) throw throwable; // Paper
+            // Paper start - Prevent tile entity and entity crashes
+            final String msg = String.format("Entity threw exception at %s:%s,%s,%s", entity.level.getWorld().getName(), entity.getX(), entity.getY(), entity.getZ());
+            MinecraftServer.LOGGER.error(msg, throwable);
+            getCraftServer().getPluginManager().callEvent(new ServerExceptionEvent(new ServerInternalException(msg, throwable)));
+            entity.discard();
+            // Paper end
         }
     }
+    // Paper start - Prevent armor stands from doing entity lookups
+    @Override
+    public boolean noCollision(@Nullable Entity entity, AABB box) {
+        if (entity instanceof net.minecraft.world.entity.decoration.ArmorStand && !entity.level.paperConfig.armorStandEntityLookups) return false;
+        return LevelAccessor.super.noCollision(entity, box);
+    }
+    // Paper end
 
     public Explosion explode(@Nullable Entity entity, double x, double y, double z, float power, Explosion.BlockInteraction destructionType) {
-        return this.explode(entity, (DamageSource)null, (ExplosionDamageCalculator)null, x, y, z, power, false, destructionType);
+        return this.explode(entity, (DamageSource) null, (ExplosionDamageCalculator) null, x, y, z, power, false, destructionType);
     }
 
     public Explosion explode(@Nullable Entity entity, double x, double y, double z, float power, boolean createFire, Explosion.BlockInteraction destructionType) {
-        return this.explode(entity, (DamageSource)null, (ExplosionDamageCalculator)null, x, y, z, power, createFire, destructionType);
+        return this.explode(entity, (DamageSource) null, (ExplosionDamageCalculator) null, x, y, z, power, createFire, destructionType);
     }
 
     public Explosion explode(@Nullable Entity entity, @Nullable DamageSource damageSource, @Nullable ExplosionDamageCalculator behavior, double x, double y, double z, float power, boolean createFire, Explosion.BlockInteraction destructionType) {
         Explosion explosion = new Explosion(this, entity, damageSource, behavior, x, y, z, power, createFire, destructionType);
+
         explosion.explode();
         explosion.finalizeExplosion(true);
         return explosion;
@@ -454,18 +904,35 @@
     public abstract String gatherChunkSourceStats();
 
     @Nullable
+    @Override
+    // CraftBukkit start
     public BlockEntity getBlockEntity(BlockPos pos) {
-        if (this.isOutsideBuildHeight(pos)) {
-            return null;
-        } else {
-            return !this.isClientSide && Thread.currentThread() != this.thread ? null : this.getChunkAt(pos).getBlockEntity(pos, LevelChunk.EntityCreationType.IMMEDIATE);
+        return this.getTileEntity(pos, true);
+    }
+
+    @Nullable
+    public BlockEntity getTileEntity(BlockPos blockposition, boolean validate) {
+        // Paper start - Optimize capturedTileEntities lookup
+        net.minecraft.world.level.block.entity.BlockEntity blockEntity;
+        if (!this.capturedTileEntities.isEmpty() && (blockEntity = this.capturedTileEntities.get(blockposition)) != null) {
+            return blockEntity;
         }
+        // Paper end
+        // CraftBukkit end
+        return this.isOutsideBuildHeight(blockposition) ? null : (!this.isClientSide && Thread.currentThread() != this.thread ? null : this.getChunkAt(blockposition).getBlockEntity(blockposition, LevelChunk.EntityCreationType.IMMEDIATE));
     }
 
     public void setBlockEntity(BlockEntity blockEntity) {
-        BlockPos blockPos = blockEntity.getBlockPos();
-        if (!this.isOutsideBuildHeight(blockPos)) {
-            this.getChunkAt(blockPos).addAndRegisterBlockEntity(blockEntity);
+        BlockPos blockposition = blockEntity.getBlockPos();
+
+        if (!this.isOutsideBuildHeight(blockposition)) {
+            // CraftBukkit start
+            if (this.captureBlockStates) {
+                this.capturedTileEntities.put(blockposition.immutable(), blockEntity);
+                return;
+            }
+            // CraftBukkit end
+            this.getChunkAt(blockposition).addAndRegisterBlockEntity(blockEntity);
         }
     }
 
@@ -483,8 +950,9 @@
         if (this.isOutsideBuildHeight(pos)) {
             return false;
         } else {
-            ChunkAccess chunkAccess = this.getChunk(SectionPos.blockToSectionCoord(pos.getX()), SectionPos.blockToSectionCoord(pos.getZ()), ChunkStatus.FULL, false);
-            return chunkAccess == null ? false : chunkAccess.getBlockState(pos).entityCanStandOnFace(this, pos, entity, direction);
+            ChunkAccess ichunkaccess = this.getChunk(SectionPos.blockToSectionCoord(pos.getX()), SectionPos.blockToSectionCoord(pos.getZ()), ChunkStatus.FULL, false);
+
+            return ichunkaccess == null ? false : ichunkaccess.getBlockState(pos).entityCanStandOnFace((BlockGetter) this, pos, entity, direction);
         }
     }
 
@@ -493,10 +961,11 @@
     }
 
     public void updateSkyBrightness() {
-        double d = 1.0D - (double)(this.getRainLevel(1.0F) * 5.0F) / 16.0D;
-        double e = 1.0D - (double)(this.getThunderLevel(1.0F) * 5.0F) / 16.0D;
-        double f = 0.5D + 2.0D * Mth.clamp((double)Mth.cos(this.getTimeOfDay(1.0F) * ((float)Math.PI * 2F)), -0.25D, 0.25D);
-        this.skyDarken = (int)((1.0D - f * d * e) * 11.0D);
+        double d0 = 1.0D - (double) (this.getRainLevel(1.0F) * 5.0F) / 16.0D;
+        double d1 = 1.0D - (double) (this.getThunderLevel(1.0F) * 5.0F) / 16.0D;
+        double d2 = 0.5D + 2.0D * Mth.clamp((double) Mth.cos(this.getTimeOfDay(1.0F) * 6.2831855F), -0.25D, 0.25D);
+
+        this.skyDarken = (int) ((1.0D - d2 * d0 * d1) * 11.0D);
     }
 
     public void setSpawnSettings(boolean spawnMonsters, boolean spawnAnimals) {
@@ -518,43 +987,58 @@
     }
 
     @Nullable
+    @Override
     public BlockGetter getChunkForCollisions(int chunkX, int chunkZ) {
         return this.getChunk(chunkX, chunkZ, ChunkStatus.FULL, false);
     }
 
+    @Override
     public List<Entity> getEntities(@Nullable Entity except, AABB box, Predicate<? super Entity> predicate) {
         this.getProfiler().incrementCounter("getEntities");
         List<Entity> list = Lists.newArrayList();
-        this.getEntities().get(box, (entity2) -> {
-            if (entity2 != except && predicate.test(entity2)) {
-                list.add(entity2);
+
+        this.getEntities().get(box, (entity1) -> {
+            if (entity1 != except && predicate.test(entity1)) {
+                list.add(entity1);
             }
 
-            if (entity2 instanceof EnderDragon) {
-                for(EnderDragonPart enderDragonPart : ((EnderDragon)entity2).getSubEntities()) {
-                    if (entity2 != except && predicate.test(enderDragonPart)) {
-                        list.add(enderDragonPart);
+            if (entity1 instanceof EnderDragon) {
+                EnderDragonPart[] aentitycomplexpart = ((EnderDragon) entity1).getSubEntities();
+                int i = aentitycomplexpart.length;
+
+                for (int j = 0; j < i; ++j) {
+                    EnderDragonPart entitycomplexpart = aentitycomplexpart[j];
+
+                    if (entity1 != except && predicate.test(entitycomplexpart)) {
+                        list.add(entitycomplexpart);
                     }
                 }
             }
 
-        });
+        }, predicate == net.minecraft.world.entity.EntitySelector.CONTAINER_ENTITY_SELECTOR); // Paper
         return list;
     }
 
+    @Override
     public <T extends Entity> List<T> getEntities(EntityTypeTest<Entity, T> filter, AABB box, Predicate<? super T> predicate) {
         this.getProfiler().incrementCounter("getEntities");
         List<T> list = Lists.newArrayList();
+
         this.getEntities().get(filter, box, (entity) -> {
             if (predicate.test(entity)) {
                 list.add(entity);
             }
 
             if (entity instanceof EnderDragon) {
-                for(EnderDragonPart enderDragonPart : ((EnderDragon)entity).getSubEntities()) {
-                    T entity2 = filter.tryCast(enderDragonPart);
-                    if (entity2 != null && predicate.test(entity2)) {
-                        list.add(entity2);
+                EnderDragonPart[] aentitycomplexpart = ((EnderDragon) entity).getSubEntities();
+                int i = aentitycomplexpart.length;
+
+                for (int j = 0; j < i; ++j) {
+                    EnderDragonPart entitycomplexpart = aentitycomplexpart[j];
+                    T t0 = filter.tryCast(entitycomplexpart);
+
+                    if (t0 != null && predicate.test(t0)) {
+                        list.add(t0);
                     }
                 }
             }
@@ -573,13 +1057,15 @@
 
     }
 
+    @Override
     public int getSeaLevel() {
         return 63;
     }
 
     public int getDirectSignalTo(BlockPos pos) {
-        int i = 0;
-        i = Math.max(i, this.getDirectSignal(pos.below(), Direction.DOWN));
+        byte b0 = 0;
+        int i = Math.max(b0, this.getDirectSignal(pos.below(), Direction.DOWN));
+
         if (i >= 15) {
             return i;
         } else {
@@ -613,46 +1099,38 @@
     }
 
     public int getSignal(BlockPos pos, Direction direction) {
-        BlockState blockState = this.getBlockState(pos);
-        int i = blockState.getSignal(this, pos, direction);
-        return blockState.isRedstoneConductor(this, pos) ? Math.max(i, this.getDirectSignalTo(pos)) : i;
+        BlockState iblockdata = this.getBlockState(pos);
+        int i = iblockdata.getSignal((BlockGetter) this, pos, direction);
+
+        return iblockdata.isRedstoneConductor(this, pos) ? Math.max(i, this.getDirectSignalTo(pos)) : i;
     }
 
     public boolean hasNeighborSignal(BlockPos pos) {
-        if (this.getSignal(pos.below(), Direction.DOWN) > 0) {
-            return true;
-        } else if (this.getSignal(pos.above(), Direction.UP) > 0) {
-            return true;
-        } else if (this.getSignal(pos.north(), Direction.NORTH) > 0) {
-            return true;
-        } else if (this.getSignal(pos.south(), Direction.SOUTH) > 0) {
-            return true;
-        } else if (this.getSignal(pos.west(), Direction.WEST) > 0) {
-            return true;
-        } else {
-            return this.getSignal(pos.east(), Direction.EAST) > 0;
-        }
+        return this.getSignal(pos.below(), Direction.DOWN) > 0 ? true : (this.getSignal(pos.above(), Direction.UP) > 0 ? true : (this.getSignal(pos.north(), Direction.NORTH) > 0 ? true : (this.getSignal(pos.south(), Direction.SOUTH) > 0 ? true : (this.getSignal(pos.west(), Direction.WEST) > 0 ? true : this.getSignal(pos.east(), Direction.EAST) > 0))));
     }
 
     public int getBestNeighborSignal(BlockPos pos) {
         int i = 0;
+        Direction[] aenumdirection = Level.DIRECTIONS;
+        int j = aenumdirection.length;
 
-        for(Direction direction : DIRECTIONS) {
-            int j = this.getSignal(pos.relative(direction), direction);
-            if (j >= 15) {
+        for (int k = 0; k < j; ++k) {
+            Direction enumdirection = aenumdirection[k];
+            int l = this.getSignal(pos.relative(enumdirection), enumdirection);
+
+            if (l >= 15) {
                 return 15;
             }
 
-            if (j > i) {
-                i = j;
+            if (l > i) {
+                i = l;
             }
         }
 
         return i;
     }
 
-    public void disconnect() {
-    }
+    public void disconnect() {}
 
     public long getGameTime() {
         return this.levelData.getGameTime();
@@ -666,13 +1144,13 @@
         return true;
     }
 
-    public void broadcastEntityEvent(Entity entity, byte status) {
-    }
+    public void broadcastEntityEvent(Entity entity, byte status) {}
 
     public void blockEvent(BlockPos pos, Block block, int type, int data) {
         this.getBlockState(pos).triggerEvent(this, pos, type, data);
     }
 
+    @Override
     public LevelData getLevelData() {
         return this.levelData;
     }
@@ -686,9 +1164,10 @@
     }
 
     public void setThunderLevel(float thunderGradient) {
-        float f = Mth.clamp(thunderGradient, 0.0F, 1.0F);
-        this.oThunderLevel = f;
-        this.thunderLevel = f;
+        float f1 = Mth.clamp(thunderGradient, 0.0F, 1.0F);
+
+        this.oThunderLevel = f1;
+        this.thunderLevel = f1;
     }
 
     public float getRainLevel(float delta) {
@@ -696,21 +1175,18 @@
     }
 
     public void setRainLevel(float rainGradient) {
-        float f = Mth.clamp(rainGradient, 0.0F, 1.0F);
-        this.oRainLevel = f;
-        this.rainLevel = f;
+        float f1 = Mth.clamp(rainGradient, 0.0F, 1.0F);
+
+        this.oRainLevel = f1;
+        this.rainLevel = f1;
     }
 
     public boolean isThundering() {
-        if (this.dimensionType().hasSkyLight() && !this.dimensionType().hasCeiling()) {
-            return (double)this.getThunderLevel(1.0F) > 0.9D;
-        } else {
-            return false;
-        }
+        return this.dimensionType().hasSkyLight() && !this.dimensionType().hasCeiling() ? (double) this.getThunderLevel(1.0F) > 0.9D : false;
     }
 
     public boolean isRaining() {
-        return (double)this.getRainLevel(1.0F) > 0.2D;
+        return (double) this.getRainLevel(1.0F) > 0.2D;
     }
 
     public boolean isRainingAt(BlockPos pos) {
@@ -721,14 +1197,16 @@
         } else if (this.getHeightmapPos(Heightmap.Types.MOTION_BLOCKING, pos).getY() > pos.getY()) {
             return false;
         } else {
-            Biome biome = this.getBiome(pos);
-            return biome.getPrecipitation() == Biome.Precipitation.RAIN && biome.getTemperature(pos) >= 0.15F;
+            Biome biomebase = this.getBiome(pos);
+
+            return biomebase.getPrecipitation() == Biome.Precipitation.RAIN && biomebase.getTemperature(pos) >= 0.15F;
         }
     }
 
     public boolean isHumidAt(BlockPos pos) {
-        Biome biome = this.getBiome(pos);
-        return biome.isHumid();
+        Biome biomebase = this.getBiome(pos);
+
+        return biomebase.isHumid();
     }
 
     @Nullable
@@ -738,47 +1216,56 @@
 
     public abstract int getFreeMapId();
 
-    public void globalLevelEvent(int eventId, BlockPos pos, int data) {
-    }
+    public void globalLevelEvent(int eventId, BlockPos pos, int data) {}
 
     public CrashReportCategory fillReportDetails(CrashReport report) {
-        CrashReportCategory crashReportCategory = report.addCategory("Affected level", 1);
-        crashReportCategory.setDetail("All players", () -> {
-            return this.players().size() + " total; " + this.players();
+        CrashReportCategory crashreportsystemdetails = report.addCategory("Affected level", 1);
+
+        crashreportsystemdetails.setDetail("All players", () -> {
+            int i = this.players().size();
+
+            return i + " total; " + this.players();
         });
-        crashReportCategory.setDetail("Chunk stats", this.getChunkSource()::gatherStats);
-        crashReportCategory.setDetail("Level dimension", () -> {
+        ChunkSource ichunkprovider = this.getChunkSource();
+
+        Objects.requireNonNull(ichunkprovider);
+        crashreportsystemdetails.setDetail("Chunk stats", ichunkprovider::gatherStats);
+        crashreportsystemdetails.setDetail("Level dimension", () -> {
             return this.dimension().location().toString();
         });
 
         try {
-            this.levelData.fillCrashReportCategory(crashReportCategory, this);
-        } catch (Throwable var4) {
-            crashReportCategory.setDetailError("Level Data Unobtainable", var4);
+            this.levelData.fillCrashReportCategory(crashreportsystemdetails, this);
+        } catch (Throwable throwable) {
+            crashreportsystemdetails.setDetailError("Level Data Unobtainable", throwable);
         }
 
-        return crashReportCategory;
+        return crashreportsystemdetails;
     }
 
     public abstract void destroyBlockProgress(int entityId, BlockPos pos, int progress);
 
-    public void createFireworks(double x, double y, double z, double velocityX, double velocityY, double velocityZ, @Nullable CompoundTag nbt) {
-    }
+    public void createFireworks(double x, double y, double z, double velocityX, double velocityY, double velocityZ, @Nullable CompoundTag nbt) {}
 
     public abstract Scoreboard getScoreboard();
 
     public void updateNeighbourForOutputSignal(BlockPos pos, Block block) {
-        for(Direction direction : Direction.Plane.HORIZONTAL) {
-            BlockPos blockPos = pos.relative(direction);
-            if (this.hasChunkAt(blockPos)) {
-                BlockState blockState = this.getBlockState(blockPos);
-                if (blockState.is(Blocks.COMPARATOR)) {
-                    blockState.neighborChanged(this, blockPos, block, pos, false);
-                } else if (blockState.isRedstoneConductor(this, blockPos)) {
-                    blockPos = blockPos.relative(direction);
-                    blockState = this.getBlockState(blockPos);
-                    if (blockState.is(Blocks.COMPARATOR)) {
-                        blockState.neighborChanged(this, blockPos, block, pos, false);
+        Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
+
+        while (iterator.hasNext()) {
+            Direction enumdirection = (Direction) iterator.next();
+            BlockPos blockposition1 = pos.relative(enumdirection);
+
+            if (this.hasChunkAt(blockposition1)) {
+                BlockState iblockdata = this.getBlockState(blockposition1);
+
+                if (iblockdata.is(Blocks.COMPARATOR)) {
+                    iblockdata.neighborChanged(this, blockposition1, block, pos, false);
+                } else if (iblockdata.isRedstoneConductor(this, blockposition1)) {
+                    blockposition1 = blockposition1.relative(enumdirection);
+                    iblockdata = this.getBlockState(blockposition1);
+                    if (iblockdata.is(Blocks.COMPARATOR)) {
+                        iblockdata.neighborChanged(this, blockposition1, block, pos, false);
                     }
                 }
             }
@@ -786,24 +1273,27 @@
 
     }
 
+    @Override
     public DifficultyInstance getCurrentDifficultyAt(BlockPos pos) {
-        long l = 0L;
+        long i = 0L;
         float f = 0.0F;
+
         if (this.hasChunkAt(pos)) {
             f = this.getMoonBrightness();
-            l = this.getChunkAt(pos).getInhabitedTime();
+            i = this.getChunkAt(pos).getInhabitedTime();
         }
 
-        return new DifficultyInstance(this.getDifficulty(), this.getDayTime(), l, f);
+        return new DifficultyInstance(this.getDifficulty(), this.getDayTime(), i, f);
     }
 
+    @Override
     public int getSkyDarken() {
         return this.skyDarken;
     }
 
-    public void setSkyFlashTime(int lightningTicksLeft) {
-    }
+    public void setSkyFlashTime(int lightningTicksLeft) {}
 
+    @Override
     public WorldBorder getWorldBorder() {
         return this.worldBorder;
     }
@@ -812,6 +1302,7 @@
         throw new UnsupportedOperationException("Can't send packets to server unless you're on the client.");
     }
 
+    @Override
     public DimensionType dimensionType() {
         return this.dimensionType;
     }
@@ -820,14 +1311,17 @@
         return this.dimension;
     }
 
+    @Override
     public Random getRandom() {
         return this.random;
     }
 
+    @Override
     public boolean isStateAtPosition(BlockPos pos, Predicate<BlockState> state) {
         return state.test(this.getBlockState(pos));
     }
 
+    @Override
     public boolean isFluidAtPosition(BlockPos pos, Predicate<FluidState> state) {
         return state.test(this.getFluidState(pos));
     }
@@ -836,10 +1330,11 @@
 
     public abstract TagContainer getTagManager();
 
-    public BlockPos getBlockRandomPos(int x, int y, int z, int i) {
+    public BlockPos getBlockRandomPos(int x, int y, int z, int l) {
         this.randValue = this.randValue * 3 + 1013904223;
-        int j = this.randValue >> 2;
-        return new BlockPos(x + (j & 15), y + (j >> 16 & i), z + (j >> 8 & 15));
+        int i1 = this.randValue >> 2;
+
+        return new BlockPos(x + (i1 & 15), y + (i1 >> 16 & l), z + (i1 >> 8 & 15));
     }
 
     public boolean noSave() {
@@ -847,13 +1342,14 @@
     }
 
     public ProfilerFiller getProfiler() {
-        return this.profiler.get();
+        return (ProfilerFiller) this.profiler.get();
     }
 
     public Supplier<ProfilerFiller> getProfilerSupplier() {
         return this.profiler;
     }
 
+    @Override
     public BiomeManager getBiomeManager() {
         return this.biomeManager;
     }
@@ -862,22 +1358,31 @@
         return this.isDebug;
     }
 
-    protected abstract LevelEntityGetter<Entity> getEntities();
+    public abstract LevelEntityGetter<Entity> getEntities();
 
     protected void postGameEventInRadius(@Nullable Entity entity, GameEvent gameEvent, BlockPos pos, int range) {
-        int i = SectionPos.blockToSectionCoord(pos.getX() - range);
-        int j = SectionPos.blockToSectionCoord(pos.getZ() - range);
-        int k = SectionPos.blockToSectionCoord(pos.getX() + range);
-        int l = SectionPos.blockToSectionCoord(pos.getZ() + range);
-        int m = SectionPos.blockToSectionCoord(pos.getY() - range);
-        int n = SectionPos.blockToSectionCoord(pos.getY() + range);
+        // CraftBukkit start
+        GenericGameEvent event = new GenericGameEvent(org.bukkit.GameEvent.getByKey(CraftNamespacedKey.fromMinecraft(Registry.GAME_EVENT.getKey(gameEvent))), new Location(this.getWorld(), pos.getX(), pos.getY(), pos.getZ()), (entity == null) ? null : entity.getBukkitEntity(), range);
+        this.getCraftServer().getPluginManager().callEvent(event);
+        if (event.isCancelled()) {
+            return;
+        }
+        range = event.getRadius();
+        // CraftBukkit end
+        int j = SectionPos.blockToSectionCoord(pos.getX() - range);
+        int k = SectionPos.blockToSectionCoord(pos.getZ() - range);
+        int l = SectionPos.blockToSectionCoord(pos.getX() + range);
+        int i1 = SectionPos.blockToSectionCoord(pos.getZ() + range);
+        int j1 = SectionPos.blockToSectionCoord(pos.getY() - range);
+        int k1 = SectionPos.blockToSectionCoord(pos.getY() + range);
 
-        for(int o = i; o <= k; ++o) {
-            for(int p = j; p <= l; ++p) {
-                ChunkAccess chunkAccess = this.getChunkSource().getChunkNow(o, p);
-                if (chunkAccess != null) {
-                    for(int q = m; q <= n; ++q) {
-                        chunkAccess.getEventDispatcher(q).post(gameEvent, entity, pos);
+        for (int l1 = j; l1 <= l; ++l1) {
+            for (int i2 = k; i2 <= i1; ++i2) {
+                LevelChunk chunk = (LevelChunk) this.getChunkIfLoadedImmediately(l1, i2); // Paper
+
+                if (chunk != null) {
+                    for (int j2 = j1; j2 <= k1; ++j2) {
+                        chunk.getEventDispatcher(j2).post(gameEvent, entity, pos);
                     }
                 }
             }
