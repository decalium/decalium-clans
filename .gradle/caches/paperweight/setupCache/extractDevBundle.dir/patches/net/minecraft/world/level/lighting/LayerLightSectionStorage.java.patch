--- a/net/minecraft/world/level/lighting/LayerLightSectionStorage.java
+++ b/net/minecraft/world/level/lighting/LayerLightSectionStorage.java
@@ -28,10 +28,10 @@
     protected final LongSet dataSectionSet = new LongOpenHashSet();
     protected final LongSet toMarkNoData = new LongOpenHashSet();
     protected final LongSet toMarkData = new LongOpenHashSet();
-    protected volatile M visibleSectionData;
-    protected final M updatingSectionData;
+    protected volatile M e_visible; protected final Object visibleUpdateLock = new Object(); // Paper - diff on change, should be "visible" - force compile fail on usage change
+    protected final M updatingSectionData; protected final M updating; // Paper - diff on change, should be "updating"
     protected final LongSet changedSections = new LongOpenHashSet();
-    protected final LongSet sectionsAffectedByLightUpdates = new LongOpenHashSet();
+    protected final LongSet sectionsAffectedByLightUpdates = new LongOpenHashSet(); LongSet dirty = sectionsAffectedByLightUpdates; // Paper - OBFHELPER
     protected final Long2ObjectMap<DataLayer> queuedSections = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap<>());
     private final LongSet untrustedSections = new LongOpenHashSet();
     private final LongSet columnsToRetainQueuedDataFor = new LongOpenHashSet();
@@ -39,25 +39,33 @@
     protected volatile boolean hasToRemove;
 
     protected LayerLightSectionStorage(LightLayer lightType, LightChunkGetter chunkProvider, M lightData) {
-        super(3, 16, 256);
+        super(3, 256, 256); // Paper - bump expected size of level sets to improve collisions and reduce rehashing (seen a lot of it)
         this.layer = lightType;
         this.chunkSource = chunkProvider;
-        this.updatingSectionData = lightData;
-        this.visibleSectionData = lightData.copy();
-        this.visibleSectionData.disableCache();
+        this.updatingSectionData = lightData; updating = lightData; // Paper
+        this.e_visible = lightData.copy(); // Paper - avoid copying light dat
+        this.e_visible.disableCache(); // Paper - avoid copying light dat
     }
 
-    protected boolean storingLightForSection(long sectionPos) {
-        return this.getDataLayer(sectionPos, true) != null;
+    protected final boolean storingLightForSection(long sectionPos) { // Paper - final to help inlining
+        return this.updating.getUpdatingOptimized(sectionPos) != null; // Paper - inline to avoid branching
     }
 
     @Nullable
     protected DataLayer getDataLayer(long sectionPos, boolean cached) {
-        return this.getDataLayer((M)(cached ? this.updatingSectionData : this.visibleSectionData), sectionPos);
+        // Paper start - avoid copying light data
+        if (cached) {
+            return this.updating.getUpdatingOptimized(sectionPos);
+        } else {
+            synchronized (this.visibleUpdateLock) {
+                return this.e_visible.lookup.apply(sectionPos);
+            }
+        }
+        // Paper end - avoid copying light data
     }
 
     @Nullable
-    protected DataLayer getDataLayer(M storage, long sectionPos) {
+    protected final DataLayer getDataLayer(M storage, long sectionPos) { // Paper
         return storage.getLayer(sectionPos);
     }
 
@@ -70,30 +78,63 @@
     protected abstract int getLightValue(long blockPos);
 
     protected int getStoredLevel(long blockPos) {
-        long l = SectionPos.blockToSection(blockPos);
-        DataLayer dataLayer = this.getDataLayer(l, true);
-        return dataLayer.get(SectionPos.sectionRelative(BlockPos.getX(blockPos)), SectionPos.sectionRelative(BlockPos.getY(blockPos)), SectionPos.sectionRelative(BlockPos.getZ(blockPos)));
+        // Paper start - reuse and inline math, use Optimized Updating path
+        final int x = (int) (blockPos >> 38);
+        final int y = (int) ((blockPos << 52) >> 52);
+        final int z = (int) ((blockPos << 26) >> 38);
+        long j = SectionPos.blockPosAsSectionLong(x, y, z);
+        DataLayer nibblearray = this.updating.getUpdatingOptimized(j);
+        //  BUG: Sometimes returns null and crashes, try to recover, but to prevent crash just return no light.
+        if (nibblearray == null) {
+            nibblearray = this.e_visible.lookup.apply(j);
+        }
+        if (nibblearray == null) {
+            System.err.println("Null nibble, preventing crash " + BlockPos.of(blockPos));
+            return 0;
+        }
+
+        return nibblearray.get(x & 15, y & 15, z & 15); // Paper - inline operations
+        // Paper end
     }
 
     protected void setStoredLevel(long blockPos, int value) {
-        long l = SectionPos.blockToSection(blockPos);
+        // Paper start - cache part of the math done in loop below
+        int x = (int) (blockPos >> 38);
+        int y = (int) ((blockPos << 52) >> 52);
+        int z = (int) ((blockPos << 26) >> 38);
+        long l = SectionPos.blockPosAsSectionLong(x, y, z);
+        // Paper end
         if (this.changedSections.add(l)) {
             this.updatingSectionData.copyDataLayer(l);
         }
 
         DataLayer dataLayer = this.getDataLayer(l, true);
-        dataLayer.set(SectionPos.sectionRelative(BlockPos.getX(blockPos)), SectionPos.sectionRelative(BlockPos.getY(blockPos)), SectionPos.sectionRelative(BlockPos.getZ(blockPos)), value);
+        dataLayer.set(x & 15, y & 15, z & 15, value); // Paper - use already calculated x/y/z
 
-        for(int i = -1; i <= 1; ++i) {
-            for(int j = -1; j <= 1; ++j) {
-                for(int k = -1; k <= 1; ++k) {
-                    this.sectionsAffectedByLightUpdates.add(SectionPos.blockToSection(BlockPos.offset(blockPos, j, k, i)));
+        // Paper start - credit to JellySquid for a major optimization here:
+        /*
+         * An extremely important optimization is made here in regards to adding items to the pending notification set. The
+         * original implementation attempts to add the coordinate of every chunk which contains a neighboring block position
+         * even though a huge number of loop iterations will simply map to block positions within the same updating chunk.
+         *
+         * Our implementation here avoids this by pre-calculating the min/max chunk coordinates so we can iterate over only
+         * the relevant chunk positions once. This reduces what would always be 27 iterations to just 1-8 iterations.
+         *
+         * @reason Use faster implementation
+         * @author JellySquid
+         */
+        for (int z2 = (z - 1) >> 4; z2 <= (z + 1) >> 4; ++z2) {
+            for (int x2 = (x - 1) >> 4; x2 <= (x + 1) >> 4; ++x2) {
+                for (int y2 = (y - 1) >> 4; y2 <= (y + 1) >> 4; ++y2) {
+                    this.dirty.add(SectionPos.asLong(x2, y2, z2));
+                    // Paper end
                 }
             }
         }
 
     }
 
+    @Override
     protected int getLevel(long id) {
         if (id == Long.MAX_VALUE) {
             return 2;
@@ -104,6 +145,7 @@
         }
     }
 
+    @Override
     protected int getLevelFromSource(long id) {
         if (this.toMarkNoData.contains(id)) {
             return 2;
@@ -112,6 +154,7 @@
         }
     }
 
+    @Override
     protected void setLevel(long id, int level) {
         int i = this.getLevel(id);
         if (i != 0 && level == 0) {
@@ -125,17 +168,23 @@
         }
 
         if (i >= 2 && level != 2) {
-            if (this.toRemove.contains(id)) {
-                this.toRemove.remove(id);
-            } else {
+            if (!this.toRemove.remove(id)) { // Paper - remove useless contains - credit to JellySquid
+                //this.toRemove.remove(id); // Paper
+            //} else { // Paper
                 this.updatingSectionData.setLayer(id, this.createDataLayer(id));
                 this.changedSections.add(id);
                 this.onNodeAdded(id);
 
-                for(int j = -1; j <= 1; ++j) {
-                    for(int k = -1; k <= 1; ++k) {
-                        for(int l = -1; l <= 1; ++l) {
-                            this.sectionsAffectedByLightUpdates.add(SectionPos.blockToSection(BlockPos.offset(id, k, l, j)));
+                // Paper start - reuse x/y/z and only notify valid chunks - Credit to JellySquid (See above method for notes)
+                int x = (int) (id >> 38);
+                int y = (int) ((id << 52) >> 52);
+                int z = (int) ((id << 26) >> 38);
+
+                for (int z2 = (z - 1) >> 4; z2 <= (z + 1) >> 4; ++z2) {
+                    for (int x2 = (x - 1) >> 4; x2 <= (x + 1) >> 4; ++x2) {
+                        for (int y2 = (y - 1) >> 4; y2 <= (y + 1) >> 4; ++y2) {
+                            this.dirty.add(SectionPos.asLong(x2, y2, z2));
+                            // Paper end
                         }
                     }
                 }
@@ -151,7 +200,7 @@
 
     protected DataLayer createDataLayer(long sectionPos) {
         DataLayer dataLayer = this.queuedSections.get(sectionPos);
-        return dataLayer != null ? dataLayer : new DataLayer();
+        return dataLayer != null ? dataLayer : new DataLayer().markPoolSafe(); // Paper
     }
 
     protected void clearQueuedSectionBlocks(LayerLightEngine<?, ?> storage, long sectionPos) {
@@ -160,9 +209,9 @@
                 return SectionPos.blockToSection(mx) == sectionPos;
             });
         } else {
-            int i = SectionPos.sectionToBlockCoord(SectionPos.x(sectionPos));
-            int j = SectionPos.sectionToBlockCoord(SectionPos.y(sectionPos));
-            int k = SectionPos.sectionToBlockCoord(SectionPos.z(sectionPos));
+            int i = (int) (sectionPos >> 42) << 4; // Paper - inline
+            int j = (int) (sectionPos << 44 >> 44) << 4; // Paper - inline
+            int k = (int) (sectionPos << 22 >> 42) << 4; // Paper - inline
 
             for(int l = 0; l < 16; ++l) {
                 for(int m = 0; m < 16; ++m) {
@@ -204,11 +253,12 @@
             this.toRemove.clear();
             this.hasToRemove = false;
 
+            DataLayer test = null; // Paper
             for(Entry<DataLayer> entry : this.queuedSections.long2ObjectEntrySet()) {
                 long n = entry.getLongKey();
-                if (this.storingLightForSection(n)) {
+                if ((test = this.updating.getUpdatingOptimized(n)) != null) { // Paper - dont look up data layer twice
                     DataLayer dataLayer3 = entry.getValue();
-                    if (this.updatingSectionData.getLayer(n) != dataLayer3) {
+                    if (test != dataLayer3) { // Paper
                         this.clearQueuedSectionBlocks(lightProvider, n);
                         this.updatingSectionData.setLayer(n, dataLayer3);
                         this.changedSections.add(n);
@@ -243,12 +293,17 @@
 
     private void checkEdgesForSection(LayerLightEngine<M, ?> lightProvider, long sectionPos) {
         if (this.storingLightForSection(sectionPos)) {
-            int i = SectionPos.sectionToBlockCoord(SectionPos.x(sectionPos));
-            int j = SectionPos.sectionToBlockCoord(SectionPos.y(sectionPos));
-            int k = SectionPos.sectionToBlockCoord(SectionPos.z(sectionPos));
+            // Paper start
+            int secX = (int) (sectionPos >> 42);
+            int secY = (int) (sectionPos << 44 >> 44);
+            int secZ = (int) (sectionPos << 22 >> 42);
+            int i = secX << 4; // baseX
+            int j = secY << 4; // baseY
+            int k = secZ << 4; // baseZ
+            // Paper end
 
             for(Direction direction : DIRECTIONS) {
-                long l = SectionPos.offset(sectionPos, direction);
+                long l = SectionPos.getAdjacentFromSectionPos(secX, secY, secZ, direction);
                 if (!this.queuedSections.containsKey(l) && this.storingLightForSection(l)) {
                     for(int m = 0; m < 16; ++m) {
                         for(int n = 0; n < 16; ++n) {
@@ -310,12 +365,12 @@
 
     protected void queueSectionData(long sectionPos, @Nullable DataLayer array, boolean bl) {
         if (array != null) {
-            this.queuedSections.put(sectionPos, array);
+            DataLayer remove = this.queuedSections.put(sectionPos, array); if (remove != null && remove.cleaner != null) remove.cleaner.run(); // Paper - clean up when removed
             if (!bl) {
                 this.untrustedSections.add(sectionPos);
             }
         } else {
-            this.queuedSections.remove(sectionPos);
+            DataLayer remove = this.queuedSections.remove(sectionPos); if (remove != null && remove.cleaner != null) remove.cleaner.run(); // Paper - clean up when removed
         }
 
     }
@@ -343,9 +398,11 @@
 
     protected void swapSectionMap() {
         if (!this.changedSections.isEmpty()) {
+            synchronized (this.visibleUpdateLock) { // Paper - avoid copying light data
             M dataLayerStorageMap = this.updatingSectionData.copy();
             dataLayerStorageMap.disableCache();
-            this.visibleSectionData = dataLayerStorageMap;
+            this.e_visible = dataLayerStorageMap; // Paper - avoid copying light data
+            } // Paper - avoid copying light data
             this.changedSections.clear();
         }
 
