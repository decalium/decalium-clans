--- a/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/net/minecraft/world/level/chunk/LevelChunk.java
@@ -1,19 +1,24 @@
 package net.minecraft.world.level.chunk;
 
 import com.google.common.collect.ImmutableList;
+import com.destroystokyo.paper.exception.ServerInternalException;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.google.common.collect.UnmodifiableIterator;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.shorts.ShortList;
+import it.unimi.dsi.fastutil.shorts.ShortListIterator;
 import java.util.BitSet;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Iterator;
 import java.util.Map;
-import java.util.Set;
 import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.Set;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
@@ -23,11 +28,16 @@
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
 import net.minecraft.core.BlockPos;
+import net.minecraft.core.DefaultedRegistry;
 import net.minecraft.core.Registry;
 import net.minecraft.core.SectionPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
 import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ChunkTaskPriorityQueueSorter;
+import net.minecraft.server.level.ServerChunkCache;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.entity.Entity;
@@ -35,14 +45,17 @@
 import net.minecraft.world.level.ChunkTickList;
 import net.minecraft.world.level.EmptyTickList;
 import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.TickList;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.EntityBlock;
+import net.minecraft.world.level.block.SpawnerBlock;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.BlockEntityTicker;
 import net.minecraft.world.level.block.entity.BlockEntityType;
 import net.minecraft.world.level.block.entity.TickingBlockEntity;
+import net.minecraft.world.level.block.entity.SpawnerBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.gameevent.EuclideanGameEventDispatcher;
 import net.minecraft.world.level.gameevent.GameEventDispatcher;
@@ -58,19 +71,23 @@
 import org.apache.logging.log4j.Logger;
 
 public class LevelChunk implements ChunkAccess {
+
     static final Logger LOGGER = LogManager.getLogger();
     private static final TickingBlockEntity NULL_TICKER = new TickingBlockEntity() {
-        public void tick() {
-        }
+        @Override
+        public void tick() {}
 
+        @Override
         public boolean isRemoved() {
             return true;
         }
 
+        @Override
         public BlockPos getPos() {
             return BlockPos.ZERO;
         }
 
+        @Override
         public String getType() {
             return "<null>";
         }
@@ -79,41 +96,59 @@
     public static final LevelChunkSection EMPTY_SECTION = null;
     private final LevelChunkSection[] sections;
     private ChunkBiomeContainer biomes;
-    private final Map<BlockPos, CompoundTag> pendingBlockEntities = Maps.newHashMap();
-    private final Map<BlockPos, LevelChunk.RebindableTickingBlockEntityWrapper> tickersInLevel = Maps.newHashMap();
-    private boolean loaded;
-    final Level level;
-    private final Map<Heightmap.Types, Heightmap> heightmaps = Maps.newEnumMap(Heightmap.Types.class);
+    private final Map<BlockPos, CompoundTag> pendingBlockEntities;
+    private final Map<BlockPos, LevelChunk.RebindableTickingBlockEntityWrapper> tickersInLevel;
+    public boolean loaded;
+    public final ServerLevel level; // CraftBukkit - type
+    public final Map<Heightmap.Types, Heightmap> heightmaps;
     private final UpgradeData upgradeData;
-    private final Map<BlockPos, BlockEntity> blockEntities = Maps.newHashMap();
-    private final Map<StructureFeature<?>, StructureStart<?>> structureStarts = Maps.newHashMap();
-    private final Map<StructureFeature<?>, LongSet> structuresRefences = Maps.newHashMap();
+    public final Map<BlockPos, BlockEntity> blockEntities;
+    private final Map<StructureFeature<?>, StructureStart<?>> structureStarts;
+    private final Map<StructureFeature<?>, LongSet> structuresRefences;
     private final ShortList[] postProcessing;
     private TickList<Block> blockTicks;
     private TickList<Fluid> liquidTicks;
+    // Paper start - track last save time
+    public long lastSaveTime;
+    @Override
+    public void setLastSaved(long ticks) {
+        this.lastSaveTime = ticks;
+    }
+    // Paper end
     private volatile boolean unsaved;
     private long inhabitedTime;
     @Nullable
     private Supplier<ChunkHolder.FullChunkStatus> fullStatus;
     @Nullable
     private Consumer<LevelChunk> postLoad;
-    private final ChunkPos chunkPos;
+    private final ChunkPos chunkPos; public final long coordinateKey; public final int locX; public final int locZ; // Paper - cache coordinate key
     private volatile boolean isLightCorrect;
     private final Int2ObjectMap<GameEventDispatcher> gameEventDispatcherSections;
 
     public LevelChunk(Level world, ChunkPos pos, ChunkBiomeContainer biomes) {
-        this(world, pos, biomes, UpgradeData.EMPTY, EmptyTickList.empty(), EmptyTickList.empty(), 0L, (LevelChunkSection[])null, (Consumer<LevelChunk>)null);
+        this(world, pos, biomes, UpgradeData.EMPTY, EmptyTickList.empty(), EmptyTickList.empty(), 0L, (LevelChunkSection[]) null, (Consumer) null);
     }
 
     public LevelChunk(Level world, ChunkPos pos, ChunkBiomeContainer biomes, UpgradeData upgradeData, TickList<Block> blockTickScheduler, TickList<Fluid> fluidTickScheduler, long inhabitedTime, @Nullable LevelChunkSection[] sections, @Nullable Consumer<LevelChunk> loadToWorldConsumer) {
-        this.level = world;
-        this.chunkPos = pos;
+        this.pendingBlockEntities = Maps.newHashMap();
+        this.tickersInLevel = Maps.newHashMap();
+        this.heightmaps = Maps.newEnumMap(Heightmap.Types.class);
+        this.blockEntities = Maps.newHashMap();
+        this.structureStarts = Maps.newHashMap();
+        this.structuresRefences = Maps.newHashMap();
+        this.level = (ServerLevel) world; // CraftBukkit - type
+        this.locX = pos.x; this.locZ = pos.z; // Paper - reduce need for field look ups
+        this.chunkPos = pos; this.coordinateKey = ChunkPos.asLong(locX, locZ); // Paper - cache long key
         this.upgradeData = upgradeData;
-        this.gameEventDispatcherSections = new Int2ObjectOpenHashMap<>();
+        this.gameEventDispatcherSections = new Int2ObjectOpenHashMap();
+        Heightmap.Types[] aheightmap_type = Heightmap.Types.values();
+        int j = aheightmap_type.length;
 
-        for(Heightmap.Types types : Heightmap.Types.values()) {
-            if (ChunkStatus.FULL.heightmapsAfter().contains(types)) {
-                this.heightmaps.put(types, new Heightmap(this, types));
+        for (int k = 0; k < j; ++k) {
+            Heightmap.Types heightmap_type = aheightmap_type[k];
+
+            if (ChunkStatus.FULL.heightmapsAfter().contains(heightmap_type)) {
+                this.heightmaps.put(heightmap_type, new Heightmap(this, heightmap_type));
             }
         }
 
@@ -127,251 +162,495 @@
             if (this.sections.length == sections.length) {
                 System.arraycopy(sections, 0, this.sections, 0, this.sections.length);
             } else {
-                LOGGER.warn("Could not set level chunk sections, array length is {} instead of {}", sections.length, this.sections.length);
+                LevelChunk.LOGGER.warn("Could not set level chunk sections, array length is {} instead of {}", sections.length, this.sections.length);
             }
         }
 
         this.postProcessing = new ShortList[world.getSectionsCount()];
+        // CraftBukkit start
+        this.bukkitChunk = new org.bukkit.craftbukkit.v1_17_R1.CraftChunk(this);
     }
 
-    public LevelChunk(ServerLevel serverLevel, ProtoChunk protoChunk, @Nullable Consumer<LevelChunk> consumer) {
-        this(serverLevel, protoChunk.getPos(), protoChunk.getBiomes(), protoChunk.getUpgradeData(), protoChunk.getBlockTicks(), protoChunk.getLiquidTicks(), protoChunk.getInhabitedTime(), protoChunk.getSections(), consumer);
+    public org.bukkit.Chunk bukkitChunk;
+    public org.bukkit.Chunk getBukkitChunk() {
+        return this.bukkitChunk;
+    }
 
-        for(BlockEntity blockEntity : protoChunk.getBlockEntities().values()) {
-            this.setBlockEntity(blockEntity);
+    public boolean mustNotSave;
+    public boolean needsDecoration;
+
+    private static final org.bukkit.craftbukkit.v1_17_R1.persistence.CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new org.bukkit.craftbukkit.v1_17_R1.persistence.CraftPersistentDataTypeRegistry();
+    public final org.bukkit.craftbukkit.v1_17_R1.persistence.CraftPersistentDataContainer persistentDataContainer = new org.bukkit.craftbukkit.v1_17_R1.persistence.CraftPersistentDataContainer(LevelChunk.DATA_TYPE_REGISTRY);
+    // CraftBukkit end
+
+    // Paper start
+    public final com.destroystokyo.paper.util.maplist.EntityList entities = new com.destroystokyo.paper.util.maplist.EntityList();
+    public ChunkHolder playerChunk;
+
+    static final int NEIGHBOUR_CACHE_RADIUS = 3;
+    public static int getNeighbourCacheRadius() {
+        return NEIGHBOUR_CACHE_RADIUS;
+    }
+
+    boolean loadedTicketLevel;
+    private long neighbourChunksLoadedBitset;
+    private final LevelChunk[] loadedNeighbourChunks = new LevelChunk[(NEIGHBOUR_CACHE_RADIUS * 2 + 1) * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)];
+
+    private static int getNeighbourIndex(final int relativeX, final int relativeZ) {
+        // index = (relativeX + NEIGHBOUR_CACHE_RADIUS) + (relativeZ + NEIGHBOUR_CACHE_RADIUS) * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)
+        // optimised variant of the above by moving some of the ops to compile time
+        return relativeX + (relativeZ * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)) + (NEIGHBOUR_CACHE_RADIUS + NEIGHBOUR_CACHE_RADIUS * ((NEIGHBOUR_CACHE_RADIUS * 2 + 1)));
+    }
+
+    public final LevelChunk getRelativeNeighbourIfLoaded(final int relativeX, final int relativeZ) {
+        return this.loadedNeighbourChunks[getNeighbourIndex(relativeX, relativeZ)];
+    }
+
+    public final boolean isNeighbourLoaded(final int relativeX, final int relativeZ) {
+        return (this.neighbourChunksLoadedBitset & (1L << getNeighbourIndex(relativeX, relativeZ))) != 0;
+    }
+
+    public final void setNeighbourLoaded(final int relativeX, final int relativeZ, final LevelChunk chunk) {
+        if (chunk == null) {
+            throw new IllegalArgumentException("Chunk must be non-null, neighbour: (" + relativeX + "," + relativeZ + "), chunk: " + this.chunkPos);
+        }
+        final long before = this.neighbourChunksLoadedBitset;
+        final int index = getNeighbourIndex(relativeX, relativeZ);
+        this.loadedNeighbourChunks[index] = chunk;
+        this.neighbourChunksLoadedBitset |= (1L << index);
+        this.onNeighbourChange(before, this.neighbourChunksLoadedBitset);
+    }
+
+    public final void setNeighbourUnloaded(final int relativeX, final int relativeZ) {
+        final long before = this.neighbourChunksLoadedBitset;
+        final int index = getNeighbourIndex(relativeX, relativeZ);
+        this.loadedNeighbourChunks[index] = null;
+        this.neighbourChunksLoadedBitset &= ~(1L << index);
+        this.onNeighbourChange(before, this.neighbourChunksLoadedBitset);
+    }
+
+    public final void resetNeighbours() {
+        final long before = this.neighbourChunksLoadedBitset;
+        this.neighbourChunksLoadedBitset = 0L;
+        java.util.Arrays.fill(this.loadedNeighbourChunks, null);
+        this.onNeighbourChange(before, 0L);
+    }
+
+    protected void onNeighbourChange(final long bitsetBefore, final long bitsetAfter) {
+        // Paper start - no-tick view distance
+        ServerChunkCache chunkProviderServer = ((ServerLevel)this.level).getChunkSource();
+        ChunkMap chunkMap = chunkProviderServer.chunkMap;
+        // this code handles the addition of ticking tickets - the distance map handles the removal
+        if (!areNeighboursLoaded(bitsetBefore, 2) && areNeighboursLoaded(bitsetAfter, 2)) {
+            if (chunkMap.playerViewDistanceTickMap.getObjectsInRange(this.coordinateKey) != null) {
+                // now we're ready for entity ticking
+                chunkProviderServer.mainThreadProcessor.execute(() -> {
+                    // double check that this condition still holds.
+                    if (LevelChunk.this.areNeighboursLoaded(2) && chunkMap.playerViewDistanceTickMap.getObjectsInRange(LevelChunk.this.coordinateKey) != null) {
+                        chunkProviderServer.addTicketAtLevel(net.minecraft.server.level.TicketType.PLAYER, LevelChunk.this.chunkPos, 31, LevelChunk.this.chunkPos); // 31 -> entity ticking, TODO check on update
+                    }
+                });
+            }
+        }
+
+        // this code handles the chunk sending
+        if (!areNeighboursLoaded(bitsetBefore, 1) && areNeighboursLoaded(bitsetAfter, 1)) {
+            if (chunkMap.playerViewDistanceBroadcastMap.getObjectsInRange(this.coordinateKey) != null) {
+                // now we're ready to send
+                chunkMap.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(chunkMap.getUpdatingChunkIfPresent(this.coordinateKey), (() -> { // Copied frm PlayerChunkMap
+                    // double check that this condition still holds.
+                    if (!LevelChunk.this.areNeighboursLoaded(1)) {
+                        return;
+                    }
+                    com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<net.minecraft.server.level.ServerPlayer> inRange = chunkMap.playerViewDistanceBroadcastMap.getObjectsInRange(LevelChunk.this.coordinateKey);
+                    if (inRange == null) {
+                        return;
+                    }
+
+                    // broadcast
+                    Object[] backingSet = inRange.getBackingSet();
+                    Packet[] chunkPackets = new Packet[2];
+                    for (int index = 0, len = backingSet.length; index < len; ++index) {
+                        Object temp = backingSet[index];
+                        if (!(temp instanceof net.minecraft.server.level.ServerPlayer)) {
+                            continue;
+                        }
+                        net.minecraft.server.level.ServerPlayer player = (net.minecraft.server.level.ServerPlayer)temp;
+                        chunkMap.playerLoadedChunk(player, chunkPackets, LevelChunk.this);
+                    }
+                })));
+            }
+        }
+        // Paper end - no-tick view distance
+    }
+
+    public final boolean isAnyNeighborsLoaded() {
+        return neighbourChunksLoadedBitset != 0;
+    }
+    public final boolean areNeighboursLoaded(final int radius) {
+        return LevelChunk.areNeighboursLoaded(this.neighbourChunksLoadedBitset, radius);
+    }
+
+    public static boolean areNeighboursLoaded(final long bitset, final int radius) {
+        // index = relativeX + (relativeZ * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)) + (NEIGHBOUR_CACHE_RADIUS + NEIGHBOUR_CACHE_RADIUS * ((NEIGHBOUR_CACHE_RADIUS * 2 + 1)))
+        switch (radius) {
+            case 0: {
+                return (bitset & (1L << getNeighbourIndex(0, 0))) != 0;
+            }
+            case 1: {
+                long mask = 0L;
+                for (int dx = -1; dx <= 1; ++dx) {
+                    for (int dz = -1; dz <= 1; ++dz) {
+                        mask |= (1L << getNeighbourIndex(dx, dz));
+                    }
+                }
+                return (bitset & mask) == mask;
+            }
+            case 2: {
+                long mask = 0L;
+                for (int dx = -2; dx <= 2; ++dx) {
+                    for (int dz = -2; dz <= 2; ++dz) {
+                        mask |= (1L << getNeighbourIndex(dx, dz));
+                    }
+                }
+                return (bitset & mask) == mask;
+            }
+            case 3: {
+                long mask = 0L;
+                for (int dx = -3; dx <= 3; ++dx) {
+                    for (int dz = -3; dz <= 3; ++dz) {
+                        mask |= (1L << getNeighbourIndex(dx, dz));
+                    }
+                }
+                return (bitset & mask) == mask;
+            }
+
+            default:
+                throw new IllegalArgumentException("Radius not recognized: " + radius);
+        }
+    }
+    // Paper end
+
+    public LevelChunk(ServerLevel worldserver, ProtoChunk protoChunk, @Nullable Consumer<LevelChunk> consumer) {
+        this(worldserver, protoChunk.getPos(), protoChunk.getBiomes(), protoChunk.getUpgradeData(), protoChunk.getBlockTicks(), protoChunk.getLiquidTicks(), protoChunk.getInhabitedTime(), protoChunk.getSections(), consumer);
+        Iterator iterator = protoChunk.getBlockEntities().values().iterator();
+
+        while (iterator.hasNext()) {
+            BlockEntity tileentity = (BlockEntity) iterator.next();
+
+            this.setBlockEntity(tileentity);
         }
 
         this.pendingBlockEntities.putAll(protoChunk.getBlockEntityNbts());
 
-        for(int i = 0; i < protoChunk.getPostProcessing().length; ++i) {
+        for (int i = 0; i < protoChunk.getPostProcessing().length; ++i) {
             this.postProcessing[i] = protoChunk.getPostProcessing()[i];
         }
 
         this.setAllStarts(protoChunk.getAllStarts());
         this.setAllReferences(protoChunk.getAllReferences());
+        iterator = protoChunk.getHeightmaps().iterator();
+
+        while (iterator.hasNext()) {
+            Entry<Heightmap.Types, Heightmap> entry = (Entry) iterator.next();
 
-        for(Entry<Heightmap.Types, Heightmap> entry : protoChunk.getHeightmaps()) {
             if (ChunkStatus.FULL.heightmapsAfter().contains(entry.getKey())) {
-                this.setHeightmap(entry.getKey(), entry.getValue().getRawData());
+                this.setHeightmap((Heightmap.Types) entry.getKey(), ((Heightmap) entry.getValue()).getRawData());
             }
         }
 
         this.setLightCorrect(protoChunk.isLightCorrect());
         this.unsaved = true;
+        this.needsDecoration = true; // CraftBukkit
     }
 
+    @Override
     public GameEventDispatcher getEventDispatcher(int ySectionCoord) {
-        return this.gameEventDispatcherSections.computeIfAbsent(ySectionCoord, (sectionCoord) -> {
+        return (GameEventDispatcher) this.gameEventDispatcherSections.computeIfAbsent(ySectionCoord, (j) -> {
             return new EuclideanGameEventDispatcher(this.level);
         });
     }
 
+    @Override
     public Heightmap getOrCreateHeightmapUnprimed(Heightmap.Types type) {
-        return this.heightmaps.computeIfAbsent(type, (typex) -> {
-            return new Heightmap(this, typex);
+        return (Heightmap) this.heightmaps.computeIfAbsent(type, (heightmap_type1) -> {
+            return new Heightmap(this, heightmap_type1);
         });
     }
 
+    @Override
     public Set<BlockPos> getBlockEntitiesPos() {
         Set<BlockPos> set = Sets.newHashSet(this.pendingBlockEntities.keySet());
+
         set.addAll(this.blockEntities.keySet());
         return set;
     }
 
+    @Override
     public LevelChunkSection[] getSections() {
         return this.sections;
     }
 
+    // Paper start - Optimize getBlockData to reduce instructions
+    @Override
     public BlockState getBlockState(BlockPos pos) {
-        int i = pos.getX();
-        int j = pos.getY();
-        int k = pos.getZ();
+        return this.getBlockData(pos.getX(), pos.getY(), pos.getZ());
+    }
+
+    public BlockState getType(final int x, final int y, final int z) {
+        return this.getBlockData(x, y, z);
+    }
+    public final BlockState getBlockData(final int x, final int y, final int z) {
+        // Method body / logic copied from below
+        final int i = this.getSectionIndex(y);
+        if (i < 0 || i >= this.sections.length || this.sections[i] == null || this.sections[i].nonEmptyBlockCount == 0) {
+            return Blocks.AIR.defaultBlockState();
+        }
+        // Inlined ChunkSection.getType() and DataPaletteBlock.a(int,int,int)
+        return this.sections[i].states.get((y & 15) << 8 | (z & 15) << 4 | x & 15);
+
+    }
+
+    public BlockState getBlockData_unused(int i, int j, int k) {
+        // Paper end
         if (this.level.isDebug()) {
-            BlockState blockState = null;
+            BlockState iblockdata = null;
+
             if (j == 60) {
-                blockState = Blocks.BARRIER.defaultBlockState();
+                iblockdata = Blocks.BARRIER.defaultBlockState();
             }
 
             if (j == 70) {
-                blockState = DebugLevelSource.getBlockStateFor(i, k);
+                iblockdata = DebugLevelSource.getBlockStateFor(i, k);
             }
 
-            return blockState == null ? Blocks.AIR.defaultBlockState() : blockState;
+            return iblockdata == null ? Blocks.AIR.defaultBlockState() : iblockdata;
         } else {
             try {
                 int l = this.getSectionIndex(j);
+
                 if (l >= 0 && l < this.sections.length) {
-                    LevelChunkSection levelChunkSection = this.sections[l];
-                    if (!LevelChunkSection.isEmpty(levelChunkSection)) {
-                        return levelChunkSection.getBlockState(i & 15, j & 15, k & 15);
+                    LevelChunkSection chunksection = this.sections[l];
+
+                    if (!LevelChunkSection.isEmpty(chunksection)) {
+                        return chunksection.getBlockState(i & 15, j & 15, k & 15);
                     }
                 }
 
                 return Blocks.AIR.defaultBlockState();
-            } catch (Throwable var8) {
-                CrashReport crashReport = CrashReport.forThrowable(var8, "Getting block state");
-                CrashReportCategory crashReportCategory = crashReport.addCategory("Block being got");
-                crashReportCategory.setDetail("Location", () -> {
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.forThrowable(throwable, "Getting block state");
+                CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Block being got");
+
+                crashreportsystemdetails.setDetail("Location", () -> {
                     return CrashReportCategory.formatLocation(this, i, j, k);
                 });
-                throw new ReportedException(crashReport);
+                throw new ReportedException(crashreport);
             }
         }
     }
 
+    // Paper start - If loaded util
+    @Override
+    public FluidState getFluidIfLoaded(BlockPos blockposition) {
+        return this.getFluidState(blockposition);
+    }
+
+    @Override
+    public BlockState getTypeIfLoaded(BlockPos blockposition) {
+        return this.getBlockState(blockposition);
+    }
+    // Paper end
+
+    @Override
     public FluidState getFluidState(BlockPos pos) {
         return this.getFluidState(pos.getX(), pos.getY(), pos.getZ());
     }
 
     public FluidState getFluidState(int x, int y, int z) {
-        try {
-            int i = this.getSectionIndex(y);
-            if (i >= 0 && i < this.sections.length) {
-                LevelChunkSection levelChunkSection = this.sections[i];
-                if (!LevelChunkSection.isEmpty(levelChunkSection)) {
-                    return levelChunkSection.getFluidState(x & 15, y & 15, z & 15);
+        // try {  // Paper - remove try catch
+        // Paper start - reduce the number of ops in this call
+        int index = this.getSectionIndex(y);
+            if (index >= 0 && index < this.sections.length) {
+                LevelChunkSection chunksection = this.sections[index];
+
+                if (chunksection != null) {
+                    return chunksection.states.get((y & 15) << 8 | (z & 15) << 4 | x & 15).getFluidState();
                 }
+                // Paper end
             }
 
             return Fluids.EMPTY.defaultFluidState();
-        } catch (Throwable var7) {
-            CrashReport crashReport = CrashReport.forThrowable(var7, "Getting fluid state");
-            CrashReportCategory crashReportCategory = crashReport.addCategory("Block being got");
-            crashReportCategory.setDetail("Location", () -> {
+        /* // Paper - remove try catch
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.forThrowable(throwable, "Getting fluid state");
+            CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Block being got");
+
+            crashreportsystemdetails.setDetail("Location", () -> {
                 return CrashReportCategory.formatLocation(this, x, y, z);
             });
-            throw new ReportedException(crashReport);
+            throw new ReportedException(crashreport);
         }
+         */  // Paper - remove try catch
     }
 
+    // CraftBukkit start
     @Nullable
+    @Override
     public BlockState setBlockState(BlockPos pos, BlockState state, boolean moved) {
-        int i = pos.getY();
+        return this.setType(pos, state, moved, true);
+    }
+
+    @Nullable
+    public BlockState setType(BlockPos blockposition, BlockState iblockdata, boolean flag, boolean doPlace) {
+        // CraftBukkit end
+        int i = blockposition.getY();
         int j = this.getSectionIndex(i);
-        LevelChunkSection levelChunkSection = this.sections[j];
-        if (levelChunkSection == EMPTY_SECTION) {
-            if (state.isAir()) {
+        LevelChunkSection chunksection = this.sections[j];
+
+        if (chunksection == LevelChunk.EMPTY_SECTION) {
+            if (iblockdata.isAir()) {
                 return null;
             }
 
-            levelChunkSection = new LevelChunkSection(SectionPos.blockToSectionCoord(i));
-            this.sections[j] = levelChunkSection;
+            chunksection = new LevelChunkSection(SectionPos.blockToSectionCoord(i), this, this.level, true); // Paper - Anti-Xray - Add parameters
+            this.sections[j] = chunksection;
         }
 
-        boolean bl = levelChunkSection.isEmpty();
-        int k = pos.getX() & 15;
+        boolean flag1 = chunksection.isEmpty();
+        int k = blockposition.getX() & 15;
         int l = i & 15;
-        int m = pos.getZ() & 15;
-        BlockState blockState = levelChunkSection.setBlockState(k, l, m, state);
-        if (blockState == state) {
+        int i1 = blockposition.getZ() & 15;
+        BlockState iblockdata1 = chunksection.setBlockState(k, l, i1, iblockdata);
+
+        if (iblockdata1 == iblockdata) {
             return null;
         } else {
-            Block block = state.getBlock();
-            this.heightmaps.get(Heightmap.Types.MOTION_BLOCKING).update(k, i, m, state);
-            this.heightmaps.get(Heightmap.Types.MOTION_BLOCKING_NO_LEAVES).update(k, i, m, state);
-            this.heightmaps.get(Heightmap.Types.OCEAN_FLOOR).update(k, i, m, state);
-            this.heightmaps.get(Heightmap.Types.WORLD_SURFACE).update(k, i, m, state);
-            boolean bl2 = levelChunkSection.isEmpty();
-            if (bl != bl2) {
-                this.level.getChunkSource().getLightEngine().updateSectionStatus(pos, bl2);
+            Block block = iblockdata.getBlock();
+
+            ((Heightmap) this.heightmaps.get(Heightmap.Types.MOTION_BLOCKING)).update(k, i, i1, iblockdata);
+            ((Heightmap) this.heightmaps.get(Heightmap.Types.MOTION_BLOCKING_NO_LEAVES)).update(k, i, i1, iblockdata);
+            ((Heightmap) this.heightmaps.get(Heightmap.Types.OCEAN_FLOOR)).update(k, i, i1, iblockdata);
+            ((Heightmap) this.heightmaps.get(Heightmap.Types.WORLD_SURFACE)).update(k, i, i1, iblockdata);
+            boolean flag2 = chunksection.isEmpty();
+
+            if (flag1 != flag2) {
+                this.level.getChunkSource().getLightEngine().updateSectionStatus(blockposition, flag2);
             }
 
-            boolean bl3 = blockState.hasBlockEntity();
+            boolean flag3 = iblockdata1.hasBlockEntity();
+
             if (!this.level.isClientSide) {
-                blockState.onRemove(this.level, pos, state, moved);
-            } else if (!blockState.is(block) && bl3) {
-                this.removeBlockEntity(pos);
+                iblockdata1.onRemove(this.level, blockposition, iblockdata, flag);
+            } else if (!iblockdata1.is(block) && flag3) {
+                this.removeBlockEntity(blockposition);
             }
 
-            if (!levelChunkSection.getBlockState(k, l, m).is(block)) {
+            if (!chunksection.getBlockState(k, l, i1).is(block)) {
                 return null;
             } else {
-                if (!this.level.isClientSide) {
-                    state.onPlace(this.level, pos, blockState, moved);
+                // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
+                if (!this.level.isClientSide && doPlace && (!this.level.captureBlockStates || block instanceof net.minecraft.world.level.block.BaseEntityBlock)) {
+                    iblockdata.onPlace(this.level, blockposition, iblockdata1, flag);
                 }
 
-                if (state.hasBlockEntity()) {
-                    BlockEntity blockEntity = this.getBlockEntity(pos, LevelChunk.EntityCreationType.CHECK);
-                    if (blockEntity == null) {
-                        blockEntity = ((EntityBlock)block).newBlockEntity(pos, state);
-                        if (blockEntity != null) {
-                            this.addAndRegisterBlockEntity(blockEntity);
+                if (iblockdata.hasBlockEntity()) {
+                    BlockEntity tileentity = this.getBlockEntity(blockposition, LevelChunk.EntityCreationType.CHECK);
+
+                    if (tileentity == null) {
+                        tileentity = ((EntityBlock) block).newBlockEntity(blockposition, iblockdata);
+                        if (tileentity != null) {
+                            this.addAndRegisterBlockEntity(tileentity);
                         }
                     } else {
-                        blockEntity.setBlockState(state);
-                        this.updateBlockEntityTicker(blockEntity);
+                        tileentity.setBlockState(iblockdata);
+                        this.updateBlockEntityTicker(tileentity);
                     }
                 }
 
                 this.unsaved = true;
-                return blockState;
+                return iblockdata1;
             }
         }
     }
 
     @Deprecated
-    public void addEntity(Entity entity) {
-    }
+    @Override
+    public void addEntity(Entity entity) {}
 
+    @Override
     public int getHeight(Heightmap.Types type, int x, int z) {
-        return this.heightmaps.get(type).getFirstAvailable(x & 15, z & 15) - 1;
+        return ((Heightmap) this.heightmaps.get(type)).getFirstAvailable(x & 15, z & 15) - 1;
     }
 
-    public BlockPos getHeighestPosition(Heightmap.Types types) {
-        ChunkPos chunkPos = this.getPos();
+    @Override
+    public BlockPos getHeighestPosition(Heightmap.Types heightmap_type) {
+        ChunkPos chunkcoordintpair = this.getPos();
         int i = this.getMinBuildHeight();
-        BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
+
+        for (int j = chunkcoordintpair.getMinBlockX(); j <= chunkcoordintpair.getMaxBlockX(); ++j) {
+            for (int k = chunkcoordintpair.getMinBlockZ(); k <= chunkcoordintpair.getMaxBlockZ(); ++k) {
+                int l = this.getHeight(heightmap_type, j & 15, k & 15);
 
-        for(int j = chunkPos.getMinBlockX(); j <= chunkPos.getMaxBlockX(); ++j) {
-            for(int k = chunkPos.getMinBlockZ(); k <= chunkPos.getMaxBlockZ(); ++k) {
-                int l = this.getHeight(types, j & 15, k & 15);
                 if (l > i) {
                     i = l;
-                    mutableBlockPos.set(j, l, k);
+                    blockposition_mutableblockposition.set(j, l, k);
                 }
             }
         }
 
-        return mutableBlockPos.immutable();
+        return blockposition_mutableblockposition.immutable();
     }
 
     @Nullable
     private BlockEntity createBlockEntity(BlockPos pos) {
-        BlockState blockState = this.getBlockState(pos);
-        return !blockState.hasBlockEntity() ? null : ((EntityBlock)blockState.getBlock()).newBlockEntity(pos, blockState);
+        BlockState iblockdata = this.getBlockState(pos);
+
+        return !iblockdata.hasBlockEntity() ? null : ((EntityBlock) iblockdata.getBlock()).newBlockEntity(pos, iblockdata);
     }
 
     @Nullable
+    @Override
     public BlockEntity getBlockEntity(BlockPos pos) {
         return this.getBlockEntity(pos, LevelChunk.EntityCreationType.CHECK);
     }
 
+    @Deprecated @Nullable public final BlockEntity getTileEntityImmediately(BlockPos pos) { return this.getBlockEntity(pos, EntityCreationType.IMMEDIATE); } // Paper - OBFHELPER
     @Nullable
     public BlockEntity getBlockEntity(BlockPos pos, LevelChunk.EntityCreationType creationType) {
-        BlockEntity blockEntity = this.blockEntities.get(pos);
-        if (blockEntity == null) {
-            CompoundTag compoundTag = this.pendingBlockEntities.remove(pos);
-            if (compoundTag != null) {
-                BlockEntity blockEntity2 = this.promotePendingBlockEntity(pos, compoundTag);
-                if (blockEntity2 != null) {
-                    return blockEntity2;
+        // CraftBukkit start
+        BlockEntity tileentity = level.capturedTileEntities.get(pos);
+        if (tileentity == null) {
+            tileentity = (BlockEntity) this.blockEntities.get(pos);
+        }
+        // CraftBukkit end
+
+        if (tileentity == null) {
+            CompoundTag nbttagcompound = (CompoundTag) this.pendingBlockEntities.remove(pos);
+
+            if (nbttagcompound != null) {
+                BlockEntity tileentity1 = this.promotePendingBlockEntity(pos, nbttagcompound);
+
+                if (tileentity1 != null) {
+                    return tileentity1;
                 }
             }
         }
 
-        if (blockEntity == null) {
+        if (tileentity == null) {
             if (creationType == LevelChunk.EntityCreationType.IMMEDIATE) {
-                blockEntity = this.createBlockEntity(pos);
-                if (blockEntity != null) {
-                    this.addAndRegisterBlockEntity(blockEntity);
+                tileentity = this.createBlockEntity(pos);
+                if (tileentity != null) {
+                    this.addAndRegisterBlockEntity(tileentity);
                 }
             }
-        } else if (blockEntity.isRemoved()) {
+        } else if (tileentity.isRemoved()) {
             this.blockEntities.remove(pos);
             return null;
         }
 
-        return blockEntity;
+        return tileentity;
     }
 
     public void addAndRegisterBlockEntity(BlockEntity blockEntity) {
@@ -388,56 +667,87 @@
     }
 
     boolean isTicking(BlockPos pos) {
-        if (!this.level.getWorldBorder().isWithinBounds(pos)) {
-            return false;
-        } else if (!(this.level instanceof ServerLevel)) {
-            return true;
-        } else {
-            return this.getFullStatus().isOrAfter(ChunkHolder.FullChunkStatus.TICKING) && ((ServerLevel)this.level).areEntitiesLoaded(ChunkPos.asLong(pos));
-        }
+        return !this.level.getWorldBorder().isWithinBounds(pos) ? false : (!(this.level instanceof ServerLevel) ? true : this.getFullStatus().isOrAfter(ChunkHolder.FullChunkStatus.TICKING) && ((ServerLevel) this.level).areEntitiesLoaded(ChunkPos.asLong(pos)));
     }
 
+    @Override
     public void setBlockEntity(BlockEntity blockEntity) {
-        BlockPos blockPos = blockEntity.getBlockPos();
-        if (this.getBlockState(blockPos).hasBlockEntity()) {
+        BlockPos blockposition = blockEntity.getBlockPos();
+
+        if (this.getBlockState(blockposition).hasBlockEntity()) {
             blockEntity.setLevel(this.level);
             blockEntity.clearRemoved();
-            BlockEntity blockEntity2 = this.blockEntities.put(blockPos.immutable(), blockEntity);
-            if (blockEntity2 != null && blockEntity2 != blockEntity) {
-                blockEntity2.setRemoved();
+            BlockEntity tileentity1 = (BlockEntity) this.blockEntities.put(blockposition.immutable(), blockEntity);
+
+            if (tileentity1 != null && tileentity1 != blockEntity) {
+                tileentity1.setRemoved();
             }
 
+            // CraftBukkit start
+            // Paper start - Remove invalid mob spawner tile entities
+        } else if (blockEntity instanceof SpawnerBlockEntity && !(getBlockState(blockposition).getBlock() instanceof SpawnerBlock)) {
+            this.removeBlockEntity(blockEntity.getBlockPos());
+            // Paper end
+        } else {
+            // Paper start
+            ServerInternalException e = new ServerInternalException(
+                "Attempted to place a tile entity (" + blockEntity + ") at " + blockEntity.getBlockPos().getX() + ","
+                    + blockEntity.getBlockPos().getY() + "," + blockEntity.getBlockPos().getZ()
+                    + " (" + getBlockState(blockposition) + ") where there was no entity tile!\n" +
+                    "Chunk coordinates: " + (this.chunkPos.x * 16) + "," + (this.chunkPos.z * 16));
+            e.printStackTrace();
+            ServerInternalException.reportInternalException(e);
+
+            if (this.level.paperConfig.removeCorruptTEs) {
+                this.removeBlockEntity(blockEntity.getBlockPos());
+                this.markUnsaved();
+                org.bukkit.Bukkit.getLogger().info("Removing corrupt tile entity");
+            }
+            // Paper end
+            // CraftBukkit end
         }
     }
 
+    @Override
     public void setBlockEntityNbt(CompoundTag nbt) {
         this.pendingBlockEntities.put(new BlockPos(nbt.getInt("x"), nbt.getInt("y"), nbt.getInt("z")), nbt);
     }
 
     @Nullable
+    @Override
     public CompoundTag getBlockEntityNbtForSaving(BlockPos pos) {
-        BlockEntity blockEntity = this.getBlockEntity(pos);
-        if (blockEntity != null && !blockEntity.isRemoved()) {
-            CompoundTag compoundTag = blockEntity.save(new CompoundTag());
-            compoundTag.putBoolean("keepPacked", false);
-            return compoundTag;
+        BlockEntity tileentity = this.getBlockEntity(pos);
+        CompoundTag nbttagcompound;
+
+        if (tileentity != null && !tileentity.isRemoved()) {
+            nbttagcompound = tileentity.save(new CompoundTag());
+            nbttagcompound.putBoolean("keepPacked", false);
+            return nbttagcompound;
         } else {
-            CompoundTag compoundTag2 = this.pendingBlockEntities.get(pos);
-            if (compoundTag2 != null) {
-                compoundTag2 = compoundTag2.copy();
-                compoundTag2.putBoolean("keepPacked", true);
+            nbttagcompound = (CompoundTag) this.pendingBlockEntities.get(pos);
+            if (nbttagcompound != null) {
+                nbttagcompound = nbttagcompound.copy();
+                nbttagcompound.putBoolean("keepPacked", true);
             }
 
-            return compoundTag2;
+            return nbttagcompound;
         }
     }
 
+    @Override
     public void removeBlockEntity(BlockPos pos) {
         if (this.isInLevel()) {
-            BlockEntity blockEntity = this.blockEntities.remove(pos);
-            if (blockEntity != null) {
-                this.removeGameEventListener(blockEntity);
-                blockEntity.setRemoved();
+            BlockEntity tileentity = (BlockEntity) this.blockEntities.remove(pos);
+
+            // CraftBukkit start - SPIGOT-5561: Also remove from pending map
+            if (!this.pendingBlockEntities.isEmpty()) {
+                this.pendingBlockEntities.remove(pos);
+            }
+            // CraftBukkit end
+
+            if (tileentity != null) {
+                this.removeGameEventListener(tileentity);
+                tileentity.setRemoved();
             }
         }
 
@@ -447,13 +757,16 @@
     private <T extends BlockEntity> void removeGameEventListener(T blockEntity) {
         if (!this.level.isClientSide) {
             Block block = blockEntity.getBlockState().getBlock();
+
             if (block instanceof EntityBlock) {
-                GameEventListener gameEventListener = ((EntityBlock)block).getListener(this.level, blockEntity);
-                if (gameEventListener != null) {
+                GameEventListener gameeventlistener = ((EntityBlock) block).getListener(this.level, blockEntity);
+
+                if (gameeventlistener != null) {
                     int i = SectionPos.blockToSectionCoord(blockEntity.getBlockPos().getY());
-                    GameEventDispatcher gameEventDispatcher = this.getEventDispatcher(i);
-                    gameEventDispatcher.unregister(gameEventListener);
-                    if (gameEventDispatcher.isEmpty()) {
+                    GameEventDispatcher gameeventdispatcher = this.getEventDispatcher(i);
+
+                    gameeventdispatcher.unregister(gameeventlistener);
+                    if (gameeventdispatcher.isEmpty()) {
                         this.gameEventDispatcherSections.remove(i);
                     }
                 }
@@ -463,9 +776,10 @@
     }
 
     private void removeBlockEntityTicker(BlockPos pos) {
-        LevelChunk.RebindableTickingBlockEntityWrapper rebindableTickingBlockEntityWrapper = this.tickersInLevel.remove(pos);
-        if (rebindableTickingBlockEntityWrapper != null) {
-            rebindableTickingBlockEntityWrapper.rebind(NULL_TICKER);
+        LevelChunk.RebindableTickingBlockEntityWrapper chunk_c = (LevelChunk.RebindableTickingBlockEntityWrapper) this.tickersInLevel.remove(pos);
+
+        if (chunk_c != null) {
+            chunk_c.rebind(LevelChunk.NULL_TICKER);
         }
 
     }
@@ -478,6 +792,86 @@
 
     }
 
+    // CraftBukkit start
+    public void loadCallback() {
+        // Paper start - neighbour cache
+        int chunkX = this.chunkPos.x;
+        int chunkZ = this.chunkPos.z;
+        ServerChunkCache chunkProvider = this.level.getChunkSource();
+        for (int dx = -NEIGHBOUR_CACHE_RADIUS; dx <= NEIGHBOUR_CACHE_RADIUS; ++dx) {
+            for (int dz = -NEIGHBOUR_CACHE_RADIUS; dz <= NEIGHBOUR_CACHE_RADIUS; ++dz) {
+                LevelChunk neighbour = chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);
+                if (neighbour != null) {
+                    neighbour.setNeighbourLoaded(-dx, -dz, this);
+                    // should be in cached already
+                    this.setNeighbourLoaded(dx, dz, neighbour);
+                }
+            }
+        }
+        this.setNeighbourLoaded(0, 0, this);
+        this.loadedTicketLevel = true;
+        // Paper end - neighbour cache
+        org.bukkit.Server server = this.level.getCraftServer();
+        this.level.getChunkSource().addLoadedChunk(this); // Paper
+        if (server != null) {
+            /*
+             * If it's a new world, the first few chunks are generated inside
+             * the World constructor. We can't reliably alter that, so we have
+             * no way of creating a CraftWorld/CraftServer at that point.
+             */
+            server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(this.bukkitChunk, this.needsDecoration));
+
+            if (this.needsDecoration) {
+                try (co.aikar.timings.Timing ignored = this.level.timings.chunkLoadPopulate.startTiming()) { // Paper
+                this.needsDecoration = false;
+                java.util.Random random = new java.util.Random();
+                random.setSeed(this.level.getSeed());
+                long xRand = random.nextLong() / 2L * 2L + 1L;
+                long zRand = random.nextLong() / 2L * 2L + 1L;
+                random.setSeed((long) this.chunkPos.x * xRand + (long) this.chunkPos.z * zRand ^ this.level.getSeed());
+
+                org.bukkit.World world = this.level.getWorld();
+                if (world != null) {
+                    this.level.populating = true;
+                    try {
+                        for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
+                            populator.populate(world, random, bukkitChunk);
+                        }
+                    } finally {
+                        this.level.populating = false;
+                    }
+                }
+                server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(this.bukkitChunk));
+                } // Paper
+            }
+        }
+    }
+
+    public void unloadCallback() {
+        org.bukkit.Server server = this.level.getCraftServer();
+        org.bukkit.event.world.ChunkUnloadEvent unloadEvent = new org.bukkit.event.world.ChunkUnloadEvent(this.bukkitChunk, this.isUnsaved());
+        server.getPluginManager().callEvent(unloadEvent);
+        // note: saving can be prevented, but not forced if no saving is actually required
+        this.mustNotSave = !unloadEvent.isSaveChunk();
+        this.level.getChunkSource().removeLoadedChunk(this); // Paper
+        // Paper start - neighbour cache
+        int chunkX = this.chunkPos.x;
+        int chunkZ = this.chunkPos.z;
+        ServerChunkCache chunkProvider = this.level.getChunkSource();
+        for (int dx = -NEIGHBOUR_CACHE_RADIUS; dx <= NEIGHBOUR_CACHE_RADIUS; ++dx) {
+            for (int dz = -NEIGHBOUR_CACHE_RADIUS; dz <= NEIGHBOUR_CACHE_RADIUS; ++dz) {
+                LevelChunk neighbour = chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);
+                if (neighbour != null) {
+                    neighbour.setNeighbourUnloaded(-dx, -dz);
+                }
+            }
+        }
+        this.loadedTicketLevel = false;
+        this.resetNeighbours();
+        // Paper end
+    }
+    // CraftBukkit end
+
     public void markUnsaved() {
         this.unsaved = true;
     }
@@ -486,20 +880,23 @@
         return false;
     }
 
+    @Override
     public ChunkPos getPos() {
         return this.chunkPos;
     }
 
-    public void replaceWithPacketData(@Nullable ChunkBiomeContainer biomes, FriendlyByteBuf buf, CompoundTag nbt, BitSet bitSet) {
-        boolean bl = biomes != null;
-        if (bl) {
+    public void replaceWithPacketData(@Nullable ChunkBiomeContainer biomes, FriendlyByteBuf buf, CompoundTag nbt, BitSet bitset) {
+        boolean flag = biomes != null;
+
+        if (flag) {
             this.blockEntities.values().forEach(this::onBlockEntityRemove);
             this.blockEntities.clear();
         } else {
-            this.blockEntities.values().removeIf((blockEntity) -> {
-                int i = this.getSectionIndex(blockEntity.getBlockPos().getY());
-                if (bitSet.get(i)) {
-                    blockEntity.setRemoved();
+            this.blockEntities.values().removeIf((tileentity) -> {
+                int i = this.getSectionIndex(tileentity.getBlockPos().getY());
+
+                if (bitset.get(i)) {
+                    tileentity.setRemoved();
                     return true;
                 } else {
                     return false;
@@ -507,19 +904,20 @@
             });
         }
 
-        for(int i = 0; i < this.sections.length; ++i) {
-            LevelChunkSection levelChunkSection = this.sections[i];
-            if (!bitSet.get(i)) {
-                if (bl && levelChunkSection != EMPTY_SECTION) {
-                    this.sections[i] = EMPTY_SECTION;
+        for (int i = 0; i < this.sections.length; ++i) {
+            LevelChunkSection chunksection = this.sections[i];
+
+            if (!bitset.get(i)) {
+                if (flag && chunksection != LevelChunk.EMPTY_SECTION) {
+                    this.sections[i] = LevelChunk.EMPTY_SECTION;
                 }
             } else {
-                if (levelChunkSection == EMPTY_SECTION) {
-                    levelChunkSection = new LevelChunkSection(this.getSectionYFromSectionIndex(i));
-                    this.sections[i] = levelChunkSection;
+                if (chunksection == LevelChunk.EMPTY_SECTION) {
+                    chunksection = new LevelChunkSection(this.getSectionYFromSectionIndex(i));
+                    this.sections[i] = chunksection;
                 }
 
-                levelChunkSection.read(buf);
+                chunksection.read(buf);
             }
         }
 
@@ -527,10 +925,15 @@
             this.biomes = biomes;
         }
 
-        for(Heightmap.Types types : Heightmap.Types.values()) {
-            String string = types.getSerializationKey();
-            if (nbt.contains(string, 12)) {
-                this.setHeightmap(types, nbt.getLongArray(string));
+        Heightmap.Types[] aheightmap_type = Heightmap.Types.values();
+        int j = aheightmap_type.length;
+
+        for (int k = 0; k < j; ++k) {
+            Heightmap.Types heightmap_type = aheightmap_type[k];
+            String s = heightmap_type.getSerializationKey();
+
+            if (nbt.contains(s, 12)) {
+                this.setHeightmap(heightmap_type, nbt.getLongArray(s));
             }
         }
 
@@ -541,6 +944,7 @@
         this.tickersInLevel.remove(blockEntity.getBlockPos());
     }
 
+    @Override
     public ChunkBiomeContainer getBiomes() {
         return this.biomes;
     }
@@ -553,6 +957,7 @@
         return this.level;
     }
 
+    @Override
     public Collection<Entry<Heightmap.Types, Heightmap>> getHeightmaps() {
         return Collections.unmodifiableSet(this.heightmaps.entrySet());
     }
@@ -561,89 +966,109 @@
         return this.blockEntities;
     }
 
+    @Override
     public CompoundTag getBlockEntityNbt(BlockPos pos) {
-        return this.pendingBlockEntities.get(pos);
+        return (CompoundTag) this.pendingBlockEntities.get(pos);
     }
 
+    @Override
     public Stream<BlockPos> getLights() {
-        return StreamSupport.stream(BlockPos.betweenClosed(this.chunkPos.getMinBlockX(), this.getMinBuildHeight(), this.chunkPos.getMinBlockZ(), this.chunkPos.getMaxBlockX(), this.getMaxBuildHeight() - 1, this.chunkPos.getMaxBlockZ()).spliterator(), false).filter((blockPos) -> {
-            return this.getBlockState(blockPos).getLightEmission() != 0;
+        return StreamSupport.stream(BlockPos.betweenClosed(this.chunkPos.getMinBlockX(), this.getMinBuildHeight(), this.chunkPos.getMinBlockZ(), this.chunkPos.getMaxBlockX(), this.getMaxBuildHeight() - 1, this.chunkPos.getMaxBlockZ()).spliterator(), false).filter((blockposition) -> {
+            return this.getBlockState(blockposition).getLightEmission() != 0;
         });
     }
 
+    @Override
     public TickList<Block> getBlockTicks() {
         return this.blockTicks;
     }
 
+    @Override
     public TickList<Fluid> getLiquidTicks() {
         return this.liquidTicks;
     }
 
+    @Override
     public void setUnsaved(boolean shouldSave) {
         this.unsaved = shouldSave;
     }
 
+    @Override
     public boolean isUnsaved() {
-        return this.unsaved;
+        return this.unsaved && !this.mustNotSave; // CraftBukkit
     }
 
     @Nullable
+    @Override
     public StructureStart<?> getStartForFeature(StructureFeature<?> structure) {
-        return this.structureStarts.get(structure);
+        return (StructureStart) this.structureStarts.get(structure);
     }
 
+    @Override
     public void setStartForFeature(StructureFeature<?> structure, StructureStart<?> start) {
         this.structureStarts.put(structure, start);
     }
 
+    @Override
     public Map<StructureFeature<?>, StructureStart<?>> getAllStarts() {
         return this.structureStarts;
     }
 
+    @Override
     public void setAllStarts(Map<StructureFeature<?>, StructureStart<?>> structureStarts) {
         this.structureStarts.clear();
         this.structureStarts.putAll(structureStarts);
     }
 
+    @Override
     public LongSet getReferencesForFeature(StructureFeature<?> structure) {
-        return this.structuresRefences.computeIfAbsent(structure, (structurex) -> {
+        return (LongSet) this.structuresRefences.computeIfAbsent(structure, (structuregenerator1) -> {
             return new LongOpenHashSet();
         });
     }
 
+    @Override
     public void addReferenceForFeature(StructureFeature<?> structure, long reference) {
-        this.structuresRefences.computeIfAbsent(structure, (structurex) -> {
+        ((LongSet) this.structuresRefences.computeIfAbsent(structure, (structuregenerator1) -> {
             return new LongOpenHashSet();
-        }).add(reference);
+        })).add(reference);
     }
 
+    @Override
     public Map<StructureFeature<?>, LongSet> getAllReferences() {
         return this.structuresRefences;
     }
 
+    @Override
     public void setAllReferences(Map<StructureFeature<?>, LongSet> structureReferences) {
         this.structuresRefences.clear();
         this.structuresRefences.putAll(structureReferences);
     }
 
+    @Override
     public long getInhabitedTime() {
-        return this.inhabitedTime;
+        return this.level.paperConfig.fixedInhabitedTime < 0 ? this.inhabitedTime : this.level.paperConfig.fixedInhabitedTime; // Paper
     }
 
+    @Override
     public void setInhabitedTime(long inhabitedTime) {
         this.inhabitedTime = inhabitedTime;
     }
 
     public void postProcessGeneration() {
-        ChunkPos chunkPos = this.getPos();
+        ChunkPos chunkcoordintpair = this.getPos();
 
-        for(int i = 0; i < this.postProcessing.length; ++i) {
+        for (int i = 0; i < this.postProcessing.length; ++i) {
             if (this.postProcessing[i] != null) {
-                for(Short short_ : this.postProcessing[i]) {
-                    BlockPos blockPos = ProtoChunk.unpackOffsetCoordinates(short_, this.getSectionYFromSectionIndex(i), chunkPos);
-                    BlockState blockState = this.getBlockState(blockPos);
-                    BlockState blockState2 = Block.updateFromNeighbourShapes(blockState, this.level, blockPos);
-                    this.level.setBlock(blockPos, blockState2, 20);
+                ShortListIterator shortlistiterator = this.postProcessing[i].iterator();
+
+                while (shortlistiterator.hasNext()) {
+                    Short oshort = (Short) shortlistiterator.next();
+                    BlockPos blockposition = ProtoChunk.unpackOffsetCoordinates(oshort, this.getSectionYFromSectionIndex(i), chunkcoordintpair);
+                    BlockState iblockdata = this.getBlockState(blockposition);
+                    BlockState iblockdata1 = Block.updateFromNeighbourShapes(iblockdata, (LevelAccessor) this.level, blockposition);
+
+                    this.level.setBlock(blockposition, iblockdata1, 20 | 2); // Paper - We send chunks before they're ticking ready, so we need to notify here
                 }
 
                 this.postProcessing[i].clear();
@@ -651,9 +1076,12 @@
         }
 
         this.unpackTicks();
+        UnmodifiableIterator unmodifiableiterator = ImmutableList.copyOf(this.pendingBlockEntities.keySet()).iterator();
 
-        for(BlockPos blockPos2 : ImmutableList.copyOf(this.pendingBlockEntities.keySet())) {
-            this.getBlockEntity(blockPos2);
+        while (unmodifiableiterator.hasNext()) {
+            BlockPos blockposition1 = (BlockPos) unmodifiableiterator.next();
+
+            this.getBlockEntity(blockposition1);
         }
 
         this.pendingBlockEntities.clear();
@@ -662,97 +1090,105 @@
 
     @Nullable
     private BlockEntity promotePendingBlockEntity(BlockPos pos, CompoundTag nbt) {
-        BlockState blockState = this.getBlockState(pos);
-        BlockEntity blockEntity;
+        BlockState iblockdata = this.getBlockState(pos);
+        BlockEntity tileentity;
+
         if ("DUMMY".equals(nbt.getString("id"))) {
-            if (blockState.hasBlockEntity()) {
-                blockEntity = ((EntityBlock)blockState.getBlock()).newBlockEntity(pos, blockState);
+            if (iblockdata.hasBlockEntity()) {
+                tileentity = ((EntityBlock) iblockdata.getBlock()).newBlockEntity(pos, iblockdata);
             } else {
-                blockEntity = null;
-                LOGGER.warn("Tried to load a DUMMY block entity @ {} but found not block entity block {} at location", pos, blockState);
+                tileentity = null;
+                LevelChunk.LOGGER.warn("Tried to load a DUMMY block entity @ {} but found not block entity block {} at location", pos, iblockdata);
             }
         } else {
-            blockEntity = BlockEntity.loadStatic(pos, blockState, nbt);
+            tileentity = BlockEntity.loadStatic(pos, iblockdata, nbt);
         }
 
-        if (blockEntity != null) {
-            blockEntity.setLevel(this.level);
-            this.addAndRegisterBlockEntity(blockEntity);
+        if (tileentity != null) {
+            tileentity.setLevel(this.level);
+            this.addAndRegisterBlockEntity(tileentity);
         } else {
-            LOGGER.warn("Tried to load a block entity for block {} but failed at location {}", blockState, pos);
+            LevelChunk.LOGGER.warn("Tried to load a block entity for block {} but failed at location {}", iblockdata, pos);
         }
 
-        return blockEntity;
+        return tileentity;
     }
 
+    @Override
     public UpgradeData getUpgradeData() {
         return this.upgradeData;
     }
 
+    @Override
     public ShortList[] getPostProcessing() {
         return this.postProcessing;
     }
 
     public void unpackTicks() {
         if (this.blockTicks instanceof ProtoTickList) {
-            ((ProtoTickList)this.blockTicks).copyOut(this.level.getBlockTicks(), (pos) -> {
-                return this.getBlockState(pos).getBlock();
+            ((ProtoTickList<Block>) this.blockTicks).copyOut(this.level.getBlockTicks(), (blockposition) -> { // CraftBukkit - decompile error
+                return this.getBlockState(blockposition).getBlock();
             });
             this.blockTicks = EmptyTickList.empty();
         } else if (this.blockTicks instanceof ChunkTickList) {
-            ((ChunkTickList)this.blockTicks).copyOut(this.level.getBlockTicks());
+            ((ChunkTickList) this.blockTicks).copyOut(this.level.getBlockTicks());
             this.blockTicks = EmptyTickList.empty();
         }
 
         if (this.liquidTicks instanceof ProtoTickList) {
-            ((ProtoTickList)this.liquidTicks).copyOut(this.level.getLiquidTicks(), (pos) -> {
-                return this.getFluidState(pos).getType();
+            ((ProtoTickList<Fluid>) this.liquidTicks).copyOut(this.level.getLiquidTicks(), (blockposition) -> { // CraftBukkit - decompile error
+                return this.getFluidState(blockposition).getType();
             });
             this.liquidTicks = EmptyTickList.empty();
         } else if (this.liquidTicks instanceof ChunkTickList) {
-            ((ChunkTickList)this.liquidTicks).copyOut(this.level.getLiquidTicks());
+            ((ChunkTickList) this.liquidTicks).copyOut(this.level.getLiquidTicks());
             this.liquidTicks = EmptyTickList.empty();
         }
 
     }
 
     public void packTicks(ServerLevel world) {
-        if (this.blockTicks == EmptyTickList.empty()) {
-            this.blockTicks = new ChunkTickList<>(Registry.BLOCK::getKey, world.getBlockTicks().fetchTicksInChunk(this.chunkPos, true, false), world.getGameTime());
+        if (this.blockTicks == EmptyTickList.<Block>empty()) { // CraftBukkit - decompile error
+            this.blockTicks = new ChunkTickList<>(Registry.BLOCK::getKey, world.getBlockTicks().fetchTicksInChunk(this.chunkPos, true, false), world.getGameTime()); // Paper - decompile fix: inline Registry.BLOCK
             this.setUnsaved(true);
         }
 
-        if (this.liquidTicks == EmptyTickList.empty()) {
-            this.liquidTicks = new ChunkTickList<>(Registry.FLUID::getKey, world.getLiquidTicks().fetchTicksInChunk(this.chunkPos, true, false), world.getGameTime());
+        if (this.liquidTicks == EmptyTickList.<Fluid>empty()) { // CraftBukkit - decompile error
+            this.liquidTicks = new ChunkTickList<>(Registry.FLUID::getKey, world.getLiquidTicks().fetchTicksInChunk(this.chunkPos, true, false), world.getGameTime()); // Paper - decompile fix: inline Registry.FLUID
             this.setUnsaved(true);
         }
 
     }
 
+    @Override
     public int getMinBuildHeight() {
         return this.level.getMinBuildHeight();
     }
 
+    @Override
     public int getHeight() {
         return this.level.getHeight();
     }
 
+    @Override
     public ChunkStatus getStatus() {
         return ChunkStatus.FULL;
     }
 
     public ChunkHolder.FullChunkStatus getFullStatus() {
-        return this.fullStatus == null ? ChunkHolder.FullChunkStatus.BORDER : this.fullStatus.get();
+        return this.fullStatus == null ? ChunkHolder.FullChunkStatus.BORDER : (ChunkHolder.FullChunkStatus) this.fullStatus.get();
     }
 
     public void setFullStatus(Supplier<ChunkHolder.FullChunkStatus> levelTypeProvider) {
         this.fullStatus = levelTypeProvider;
     }
 
+    @Override
     public boolean isLightCorrect() {
         return this.isLightCorrect;
     }
 
+    @Override
     public void setLightCorrect(boolean lightOn) {
         this.isLightCorrect = lightOn;
         this.setUnsaved(true);
@@ -763,20 +1199,23 @@
     }
 
     public void registerAllBlockEntitiesAfterLevelLoad() {
-        this.blockEntities.values().forEach((blockEntity) -> {
-            this.addGameEventListener(blockEntity);
-            this.updateBlockEntityTicker(blockEntity);
+        this.blockEntities.values().forEach((tileentity) -> {
+            this.addGameEventListener(tileentity);
+            this.updateBlockEntityTicker(tileentity);
         });
     }
 
     private <T extends BlockEntity> void addGameEventListener(T blockEntity) {
         if (!this.level.isClientSide) {
             Block block = blockEntity.getBlockState().getBlock();
+
             if (block instanceof EntityBlock) {
-                GameEventListener gameEventListener = ((EntityBlock)block).getListener(this.level, blockEntity);
-                if (gameEventListener != null) {
-                    GameEventDispatcher gameEventDispatcher = this.getEventDispatcher(SectionPos.blockToSectionCoord(blockEntity.getBlockPos().getY()));
-                    gameEventDispatcher.register(gameEventListener);
+                GameEventListener gameeventlistener = ((EntityBlock) block).getListener(this.level, blockEntity);
+
+                if (gameeventlistener != null) {
+                    GameEventDispatcher gameeventdispatcher = this.getEventDispatcher(SectionPos.blockToSectionCoord(blockEntity.getBlockPos().getY()));
+
+                    gameeventdispatcher.register(gameeventlistener);
                 }
             }
 
@@ -784,20 +1223,23 @@
     }
 
     private <T extends BlockEntity> void updateBlockEntityTicker(T blockEntity) {
-        BlockState blockState = blockEntity.getBlockState();
-        BlockEntityTicker<T> blockEntityTicker = blockState.getTicker(this.level, blockEntity.getType());
-        if (blockEntityTicker == null) {
+        BlockState iblockdata = blockEntity.getBlockState();
+        BlockEntityTicker<T> blockentityticker = iblockdata.getTicker(this.level, (BlockEntityType<T>) blockEntity.getType()); // CraftBukkit - decompile error
+
+        if (blockentityticker == null) {
             this.removeBlockEntityTicker(blockEntity.getBlockPos());
         } else {
-            this.tickersInLevel.compute(blockEntity.getBlockPos(), (pos, rebindableTickingBlockEntityWrapper) -> {
-                TickingBlockEntity tickingBlockEntity = this.createTicker(blockEntity, blockEntityTicker);
-                if (rebindableTickingBlockEntityWrapper != null) {
-                    rebindableTickingBlockEntityWrapper.rebind(tickingBlockEntity);
-                    return rebindableTickingBlockEntityWrapper;
+            this.tickersInLevel.compute(blockEntity.getBlockPos(), (blockposition, chunk_c) -> {
+                TickingBlockEntity tickingblockentity = this.createTicker(blockEntity, blockentityticker);
+
+                if (chunk_c != null) {
+                    chunk_c.rebind(tickingblockentity);
+                    return chunk_c;
                 } else if (this.isInLevel()) {
-                    LevelChunk.RebindableTickingBlockEntityWrapper rebindableTickingBlockEntityWrapper2 = new LevelChunk.RebindableTickingBlockEntityWrapper(tickingBlockEntity);
-                    this.level.addBlockEntityTicker(rebindableTickingBlockEntityWrapper2);
-                    return rebindableTickingBlockEntityWrapper2;
+                    LevelChunk.RebindableTickingBlockEntityWrapper chunk_c1 = new LevelChunk.RebindableTickingBlockEntityWrapper(tickingblockentity);
+
+                    this.level.addBlockEntityTicker((TickingBlockEntity) chunk_c1);
+                    return chunk_c1;
                 } else {
                     return null;
                 }
@@ -810,98 +1252,122 @@
         return new LevelChunk.BoundTickingBlockEntity<>(blockEntity, blockEntityTicker);
     }
 
-    class BoundTickingBlockEntity<T extends BlockEntity> implements TickingBlockEntity {
-        private final T blockEntity;
-        private final BlockEntityTicker<T> ticker;
-        private boolean loggedInvalidBlockState;
+    public static enum EntityCreationType {
 
-        BoundTickingBlockEntity(T blockEntity, BlockEntityTicker<T> ticker) {
-            this.blockEntity = blockEntity;
-            this.ticker = ticker;
-        }
+        IMMEDIATE, QUEUED, CHECK;
 
-        public void tick() {
-            if (!this.blockEntity.isRemoved() && this.blockEntity.hasLevel()) {
-                BlockPos blockPos = this.blockEntity.getBlockPos();
-                if (LevelChunk.this.isTicking(blockPos)) {
-                    try {
-                        ProfilerFiller profilerFiller = LevelChunk.this.level.getProfiler();
-                        profilerFiller.push(this::getType);
-                        BlockState blockState = LevelChunk.this.getBlockState(blockPos);
-                        if (this.blockEntity.getType().isValid(blockState)) {
-                            this.ticker.tick(LevelChunk.this.level, this.blockEntity.getBlockPos(), blockState, this.blockEntity);
-                            this.loggedInvalidBlockState = false;
-                        } else if (!this.loggedInvalidBlockState) {
-                            this.loggedInvalidBlockState = true;
-                            LevelChunk.LOGGER.warn("Block entity {} @ {} state {} invalid for ticking:", this::getType, this::getPos, () -> {
-                                return blockState;
-                            });
-                        }
+        private EntityCreationType() {}
+    }
 
-                        profilerFiller.pop();
-                    } catch (Throwable var5) {
-                        CrashReport crashReport = CrashReport.forThrowable(var5, "Ticking block entity");
-                        CrashReportCategory crashReportCategory = crashReport.addCategory("Block entity being ticked");
-                        this.blockEntity.fillCrashReportCategory(crashReportCategory);
-                        throw new ReportedException(crashReport);
-                    }
-                }
-            }
+    private class RebindableTickingBlockEntityWrapper implements TickingBlockEntity {
 
+        private TickingBlockEntity ticker;
+
+        RebindableTickingBlockEntityWrapper(TickingBlockEntity tickingblockentity) {
+            this.ticker = tickingblockentity;
+        }
+
+        void rebind(TickingBlockEntity wrapped) {
+            this.ticker = wrapped;
+        }
+
+        @Override
+        public void tick() {
+            this.ticker.tick();
         }
 
+        @Override
         public boolean isRemoved() {
-            return this.blockEntity.isRemoved();
+            return this.ticker.isRemoved();
         }
 
+        @Override
         public BlockPos getPos() {
-            return this.blockEntity.getBlockPos();
+            return this.ticker.getPos();
         }
 
+        @Override
         public String getType() {
-            return BlockEntityType.getKey(this.blockEntity.getType()).toString();
+            return this.ticker.getType();
         }
 
         public String toString() {
-            return "Level ticker for " + this.getType() + "@" + this.getPos();
+            return this.ticker.toString() + " <wrapped>";
         }
     }
 
-    public static enum EntityCreationType {
-        IMMEDIATE,
-        QUEUED,
-        CHECK;
-    }
-
-    class RebindableTickingBlockEntityWrapper implements TickingBlockEntity {
-        private TickingBlockEntity ticker;
+    private class BoundTickingBlockEntity<T extends BlockEntity> implements TickingBlockEntity {
 
-        RebindableTickingBlockEntityWrapper(TickingBlockEntity wrapped) {
-            this.ticker = wrapped;
-        }
+        private final T blockEntity;
+        private final BlockEntityTicker<T> ticker;
+        private boolean loggedInvalidBlockState;
 
-        void rebind(TickingBlockEntity wrapped) {
-            this.ticker = wrapped;
+        BoundTickingBlockEntity(BlockEntity tileentity, BlockEntityTicker blockentityticker) {
+            this.blockEntity = (T) tileentity; // CraftBukkit - decompile error
+            this.ticker = blockentityticker;
         }
 
+        @Override
         public void tick() {
-            this.ticker.tick();
+            if (!this.blockEntity.isRemoved() && this.blockEntity.hasLevel()) {
+                BlockPos blockposition = this.blockEntity.getBlockPos();
+
+                if (LevelChunk.this.isTicking(blockposition)) {
+                    try {
+                        ProfilerFiller gameprofilerfiller = LevelChunk.this.level.getProfiler();
+
+                        gameprofilerfiller.push(this::getType);
+                        this.blockEntity.tickTimer.startTiming(); // Spigot
+                        BlockState iblockdata = LevelChunk.this.getBlockState(blockposition);
+
+                        if (this.blockEntity.getType().isValid(iblockdata)) {
+                            this.ticker.tick(LevelChunk.this.level, this.blockEntity.getBlockPos(), iblockdata, this.blockEntity);
+                            this.loggedInvalidBlockState = false;
+                        } else if (!this.loggedInvalidBlockState) {
+                            this.loggedInvalidBlockState = true;
+                            LevelChunk.LOGGER.warn("Block entity {} @ {} state {} invalid for ticking:", new org.apache.logging.log4j.util.Supplier[]{this::getType, this::getPos, () -> {
+                                        return iblockdata;
+                                    }}); // CraftBukkit - squelch checkstyle
+                        }
+
+                        gameprofilerfiller.pop();
+                    } catch (Throwable throwable) {
+                        if (throwable instanceof ThreadDeath) throw throwable; // Paper
+                        // Paper start - Prevent tile entity and entity crashes
+                        final String msg = String.format("BlockEntity threw exception at %s:%s,%s,%s", LevelChunk.this.getLevel().getWorld().getName(), this.getPos().getX(), this.getPos().getY(), this.getPos().getZ());
+                        net.minecraft.server.MinecraftServer.LOGGER.error(msg, throwable);
+                        net.minecraft.world.level.chunk.LevelChunk.this.level.getCraftServer().getPluginManager().callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new ServerInternalException(msg, throwable)));
+                        LevelChunk.this.removeBlockEntity(this.getPos());
+                        // Paper end
+                        // Spigot start
+                    } finally {
+                        this.blockEntity.tickTimer.stopTiming();
+                        // Spigot end
+                    }
+                }
+            }
+
         }
 
+        @Override
         public boolean isRemoved() {
-            return this.ticker.isRemoved();
+            return this.blockEntity.isRemoved();
         }
 
+        @Override
         public BlockPos getPos() {
-            return this.ticker.getPos();
+            return this.blockEntity.getBlockPos();
         }
 
+        @Override
         public String getType() {
-            return this.ticker.getType();
+            return BlockEntityType.getKey(this.blockEntity.getType()).toString();
         }
 
         public String toString() {
-            return this.ticker.toString() + " <wrapped>";
+            String s = this.getType();
+
+            return "Level ticker for " + s + "@" + this.getPos();
         }
     }
 }
