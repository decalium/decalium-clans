--- a/net/minecraft/world/level/entity/PersistentEntitySectionManager.java
+++ b/net/minecraft/world/level/entity/PersistentEntitySectionManager.java
@@ -35,7 +35,7 @@
     final LevelCallback<T> callbacks;
     private final EntityPersistentStorage<T> permanentStorage;
     private final EntityLookup<T> visibleEntityStorage;
-    final EntitySectionStorage<T> sectionStorage;
+    public final EntitySectionStorage<T> sectionStorage;
     private final LevelEntityGetter<T> entityGetter;
     private final Long2ObjectMap<Visibility> chunkVisibility = new Long2ObjectOpenHashMap<>();
     private final Long2ObjectMap<PersistentEntitySectionManager.ChunkLoadStatus> chunkLoadStatuses = new Long2ObjectOpenHashMap<>();
@@ -61,7 +61,21 @@
 
     private boolean addEntityUuid(T entity) {
         if (!this.knownUuids.add(entity.getUUID())) {
+            // Paper start
+            if (((Entity) entity).isRemoved()) {
+                stopTracking(entity); // remove the existing entity
+                return false;
+            }
+            // Paper end
             LOGGER.warn("UUID of added entity already exists: {}", (Object)entity);
+            // Paper start
+            if (net.minecraft.world.level.Level.DEBUG_ENTITIES && ((Entity) entity).level.paperConfig.duplicateUUIDMode != com.destroystokyo.paper.PaperWorldConfig.DuplicateUUIDMode.NOTHING) {
+                if (((Entity) entity).addedToWorldStack != null) {
+                    ((Entity) entity).addedToWorldStack.printStackTrace();
+                }
+                net.minecraft.server.level.ServerLevel.getAddToWorldStackTrace((net.minecraft.world.entity.Entity) entity).printStackTrace();
+            }
+            // Paper end
             return false;
         } else {
             return true;
@@ -186,7 +200,7 @@
 
     }
 
-    private boolean storeChunkSections(long chunkPos, Consumer<T> action) {
+    public boolean storeChunkSections(long chunkPos, Consumer<T> action) {
         PersistentEntitySectionManager.ChunkLoadStatus chunkLoadStatus = this.chunkLoadStatuses.get(chunkPos);
         if (chunkLoadStatus == PersistentEntitySectionManager.ChunkLoadStatus.PENDING) {
             return false;
@@ -238,7 +252,7 @@
     }
 
     private void processUnloads() {
-        this.chunksToUnload.removeIf((pos) -> {
+        this.chunksToUnload.removeIf((java.util.function.LongPredicate) (pos) -> { // Paper - decompile fix
             return this.chunkVisibility.get(pos) != Visibility.HIDDEN ? true : this.processChunkUnload(pos);
         });
     }
@@ -250,6 +264,12 @@
                 this.addEntity(entity, true);
             });
             this.chunkLoadStatuses.put(chunkEntities.getPos().toLong(), PersistentEntitySectionManager.ChunkLoadStatus.LOADED);
+            // Paper start - rewrite ServerTickList
+            final net.minecraft.server.level.ServerLevel level = ((net.minecraft.world.level.chunk.storage.EntityStorage) this.permanentStorage).level;
+            if (level.chunkSource.isPositionTickingReady(chunkEntities.getPos().longKey)) {
+                level.onChunkSetTicking(chunkEntities.getPos().x, chunkEntities.getPos().z);
+            }
+            // Paper end
         }
 
     }
@@ -272,7 +292,7 @@
     }
 
     public void autoSave() {
-        this.getAllChunksToSave().forEach((pos) -> {
+        this.getAllChunksToSave().forEach((java.util.function.LongConsumer) (pos) -> { // Paper - decompile fix
             boolean bl = this.chunkVisibility.get(pos) == Visibility.HIDDEN;
             if (bl) {
                 this.processChunkUnload(pos);
@@ -290,7 +310,7 @@
         while(!longSet.isEmpty()) {
             this.permanentStorage.flush(false);
             this.processPendingLoads();
-            longSet.removeIf((pos) -> {
+            longSet.removeIf((java.util.function.LongPredicate) (pos) -> { // Paper - decompile fix
                 boolean bl = this.chunkVisibility.get(pos) == Visibility.HIDDEN;
                 return bl ? this.processChunkUnload(pos) : this.storeChunkSections(pos, (entityAccess) -> {
                 });
@@ -300,6 +320,7 @@
         this.permanentStorage.flush(true);
     }
 
+    @Override
     public void close() throws IOException {
         this.saveAll();
         this.permanentStorage.close();
@@ -312,6 +333,11 @@
     public LevelEntityGetter<T> getEntityGetter() {
         return this.entityGetter;
     }
+    // Paper start
+    public final boolean isPositionTicking(long position) {
+        return this.chunkVisibility.get(position).isTicking();
+    }
+    // Paper end
 
     public boolean isPositionTicking(BlockPos blockPos) {
         return this.chunkVisibility.get(ChunkPos.asLong(blockPos)).isTicking();
@@ -327,7 +353,7 @@
 
     public void dumpSections(Writer writer) throws IOException {
         CsvOutput csvOutput = CsvOutput.builder().addColumn("x").addColumn("y").addColumn("z").addColumn("visibility").addColumn("load_status").addColumn("entity_count").build(writer);
-        this.sectionStorage.getAllChunksWithExistingSections().forEach((chunkPos) -> {
+        this.sectionStorage.getAllChunksWithExistingSections().forEach((java.util.function.LongConsumer) (chunkPos) -> { // Paper - decompile fix
             PersistentEntitySectionManager.ChunkLoadStatus chunkLoadStatus = this.chunkLoadStatuses.get(chunkPos);
             this.sectionStorage.getExistingSectionPositionsInChunk(chunkPos).forEach((sectionPos) -> {
                 EntitySection<T> entitySection = this.sectionStorage.getSection(sectionPos);
@@ -359,6 +385,7 @@
             this.currentSection = entitySection;
         }
 
+        @Override
         public void onMove() {
             BlockPos blockPos = this.entity.blockPosition();
             long l = SectionPos.asLong(blockPos);
@@ -401,6 +428,7 @@
             }
         }
 
+        @Override
         public void onRemove(Entity.RemovalReason reason) {
             if (!this.currentSection.remove(this.entity)) {
                 PersistentEntitySectionManager.LOGGER.warn("Entity {} wasn't found in section {} (destroying due to {})", this.entity, SectionPos.of(this.currentSectionKey), reason);
