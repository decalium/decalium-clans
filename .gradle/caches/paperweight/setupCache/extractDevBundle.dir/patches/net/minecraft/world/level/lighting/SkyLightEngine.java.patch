--- a/net/minecraft/world/level/lighting/SkyLightEngine.java
+++ b/net/minecraft/world/level/lighting/SkyLightEngine.java
@@ -4,53 +4,61 @@
 import net.minecraft.core.Direction;
 import net.minecraft.core.SectionPos;
 import net.minecraft.world.level.LightLayer;
+import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.DataLayer;
 import net.minecraft.world.level.chunk.LightChunkGetter;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
-import org.apache.commons.lang3.mutable.MutableInt;
+import org.bukkit.craftbukkit.libs.org.apache.commons.lang3.mutable.MutableInt;
 
 public final class SkyLightEngine extends LayerLightEngine<SkyLightSectionStorage.SkyDataLayerStorageMap, SkyLightSectionStorage> {
     private static final Direction[] DIRECTIONS = Direction.values();
     private static final Direction[] HORIZONTALS = new Direction[]{Direction.NORTH, Direction.SOUTH, Direction.WEST, Direction.EAST};
+    private final MutableInt mutableInt = new MutableInt(); // Paper
 
     public SkyLightEngine(LightChunkGetter chunkProvider) {
         super(chunkProvider, LightLayer.SKY, new SkyLightSectionStorage(chunkProvider));
     }
 
+    @Override
     protected int computeLevelFromNeighbor(long sourceId, long targetId, int level) {
         if (targetId != Long.MAX_VALUE && sourceId != Long.MAX_VALUE) {
             if (level >= 15) {
                 return level;
             } else {
-                MutableInt mutableInt = new MutableInt();
-                BlockState blockState = this.getStateAndOpacity(targetId, mutableInt);
-                if (mutableInt.getValue() >= 15) {
+                //MutableInt mutableint = new MutableInt(); // Paper - share mutableint, single threaded
+                // Paper start - use x/y/z and optimized block lookup
+                int jx = (int) (targetId >> 38);
+                int jy = (int) ((targetId << 52) >> 52);
+                int jz = (int) ((targetId << 26) >> 38);
+                BlockState blockState = this.getBlockOptimized(jx, jy, jz, mutableInt);
+                int blockedLight = mutableInt.getValue();
+                if (blockedLight >= 15) {
+                    // Paper end
                     return 15;
                 } else {
-                    int i = BlockPos.getX(sourceId);
-                    int j = BlockPos.getY(sourceId);
-                    int k = BlockPos.getZ(sourceId);
-                    int l = BlockPos.getX(targetId);
-                    int m = BlockPos.getY(targetId);
-                    int n = BlockPos.getZ(targetId);
-                    int o = Integer.signum(l - i);
-                    int p = Integer.signum(m - j);
-                    int q = Integer.signum(n - k);
+                    // Paper start - inline math
+                    int i = (int) (sourceId >> 38);
+                    int j = (int) ((sourceId << 52) >> 52);
+                    int k = (int) ((sourceId << 26) >> 38);
+                    boolean bl = i == jx && k == jz;
+                    int o = Integer.signum(jx - i);
+                    int p = Integer.signum(jy - j);
+                    int q = Integer.signum(jz - k);
+                    // Paper end
                     Direction direction = Direction.fromNormal(o, p, q);
                     if (direction == null) {
                         throw new IllegalStateException(String.format("Light was spread in illegal direction %d, %d, %d", o, p, q));
                     } else {
-                        BlockState blockState2 = this.getStateAndOpacity(sourceId, (MutableInt)null);
+                        BlockState blockState2 = sourceId == Long.MAX_VALUE ? net.minecraft.world.level.block.Blocks.AIR.defaultBlockState() : this.getBlockOptimized(i, j, k); // Paper
                         VoxelShape voxelShape = this.getShape(blockState2, sourceId, direction);
                         VoxelShape voxelShape2 = this.getShape(blockState, targetId, direction.getOpposite());
                         if (Shapes.faceShapeOccludes(voxelShape, voxelShape2)) {
                             return 15;
                         } else {
-                            boolean bl = i == l && k == n;
-                            boolean bl2 = bl && j > m;
-                            return bl2 && level == 0 && mutableInt.getValue() == 0 ? 0 : level + Math.max(1, mutableInt.getValue());
+                            boolean bl2 = bl && j > jy; // Paper rename vars to jy from m
+                            return bl2 && level == 0 && blockedLight == 0 ? 0 : level + Math.max(1, blockedLight); // Paper
                         }
                     }
                 }
@@ -60,11 +68,16 @@
         }
     }
 
+    @Override
     protected void checkNeighborsAfterUpdate(long id, int level, boolean decrease) {
-        long l = SectionPos.blockToSection(id);
-        int i = BlockPos.getY(id);
-        int j = SectionPos.sectionRelative(i);
-        int k = SectionPos.blockToSectionCoord(i);
+        // Paper start
+        int baseX = (int) (id >> 38);
+        int baseY = (int) ((id << 52) >> 52);
+        int baseZ = (int) ((id << 26) >> 38);
+        long l = SectionPos.blockPosAsSectionLong(baseX, baseY, baseZ);
+        int j = baseY & 15;
+        int k = baseY >> 4;
+        // Paper end
         int m;
         if (j != 0) {
             m = 0;
@@ -76,14 +89,15 @@
             m = n;
         }
 
-        long p = BlockPos.offset(id, 0, -1 - m * 16, 0);
-        long q = SectionPos.blockToSection(p);
+        int newBaseY = baseY + (-1 - m * 16); // Paper
+        long p = BlockPos.asLong(baseX, newBaseY, baseZ); // Paper
+        long q = SectionPos.blockPosAsSectionLong(baseX, newBaseY, baseZ); // Paper
         if (l == q || this.storage.storingLightForSection(q)) {
             this.checkNeighbor(id, p, level, decrease);
         }
 
-        long r = BlockPos.offset(id, Direction.UP);
-        long s = SectionPos.blockToSection(r);
+        long r = BlockPos.asLong(baseX, baseY + 1, baseZ); // Paper
+        long s = SectionPos.blockPosAsSectionLong(baseX, baseY + 1, baseZ); // Paper
         if (l == s || this.storage.storingLightForSection(s)) {
             this.checkNeighbor(id, r, level, decrease);
         }
@@ -92,8 +106,8 @@
             int t = 0;
 
             while(true) {
-                long u = BlockPos.offset(id, direction.getStepX(), -t, direction.getStepZ());
-                long v = SectionPos.blockToSection(u);
+                long u = BlockPos.asLong(baseX + direction.getStepX(), baseY - t, baseZ + direction.getStepZ()); // Paper
+                long v = SectionPos.blockPosAsSectionLong(baseX + direction.getStepX(), baseY - t, baseZ + direction.getStepZ()); // Paper
                 if (l == v) {
                     this.checkNeighbor(id, u, level, decrease);
                     break;
@@ -113,25 +127,36 @@
 
     }
 
+    @Override
     protected int getComputedLevel(long id, long excludedId, int maxLevel) {
         int i = maxLevel;
-        long l = SectionPos.blockToSection(id);
-        DataLayer dataLayer = this.storage.getDataLayer(l, true);
+        // Paper start
+        int baseX = (int) (id >> 38);
+        int baseY = (int) ((id << 52) >> 52);
+        int baseZ = (int) ((id << 26) >> 38);
+        long l = SectionPos.blockPosAsSectionLong(baseX, baseY, baseZ);
+        DataLayer dataLayer = this.storage.updating.getUpdatingOptimized(l);
+        // Paper end
 
         for(Direction direction : DIRECTIONS) {
-            long m = BlockPos.offset(id, direction);
+            // Paper start
+            int newX = baseX + direction.getStepX();
+            int newY = baseY + direction.getStepY();
+            int newZ = baseZ + direction.getStepZ();
+            long m = BlockPos.asLong(newX, newY, newZ);
             if (m != excludedId) {
-                long n = SectionPos.blockToSection(m);
+                long n = SectionPos.blockPosAsSectionLong(newX, newY, newZ);
+                // Paper end
                 DataLayer dataLayer2;
                 if (l == n) {
                     dataLayer2 = dataLayer;
                 } else {
-                    dataLayer2 = this.storage.getDataLayer(n, true);
+                    dataLayer2 = this.storage.updating.getUpdatingOptimized(n); // Paper
                 }
 
                 int j;
                 if (dataLayer2 != null) {
-                    j = this.getLevel(dataLayer2, m);
+                    j = this.getLevel(dataLayer2, newX, newY, newZ); // Paper
                 } else {
                     if (direction == Direction.DOWN) {
                         continue;
@@ -154,6 +179,7 @@
         return i;
     }
 
+    @Override
     protected void checkNode(long id) {
         this.storage.runAllUpdates();
         long l = SectionPos.blockToSection(id);
@@ -171,6 +197,7 @@
 
     }
 
+    @Override
     public String getDebugData(long sectionPos) {
         return super.getDebugData(sectionPos) + (this.storage.isAboveData(sectionPos) ? "*" : "");
     }
