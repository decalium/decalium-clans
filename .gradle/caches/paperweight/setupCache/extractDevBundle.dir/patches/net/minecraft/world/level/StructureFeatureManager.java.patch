--- a/net/minecraft/world/level/StructureFeatureManager.java
+++ b/net/minecraft/world/level/StructureFeatureManager.java
@@ -1,3 +1,4 @@
+// mc-dev import
 package net.minecraft.world.level;
 
 import com.mojang.datafixers.DataFixUtils;
@@ -5,6 +6,8 @@
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
+import net.minecraft.core.Vec3i;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.WorldGenRegion;
 import net.minecraft.world.level.chunk.ChunkStatus;
 import net.minecraft.world.level.chunk.FeatureAccess;
@@ -13,6 +16,7 @@
 import net.minecraft.world.level.levelgen.structure.StructureStart;
 
 public class StructureFeatureManager {
+
     private final LevelAccessor level;
     private final WorldGenSettings worldGenSettings;
 
@@ -23,22 +27,38 @@
 
     public StructureFeatureManager forWorldGenRegion(WorldGenRegion region) {
         if (region.getLevel() != this.level) {
-            throw new IllegalStateException("Using invalid feature manager (source level: " + region.getLevel() + ", region: " + region);
+            ServerLevel worldserver = region.getLevel();
+
+            throw new IllegalStateException("Using invalid feature manager (source level: " + worldserver + ", region: " + region);
         } else {
             return new StructureFeatureManager(region, this.worldGenSettings);
         }
     }
 
     public Stream<? extends StructureStart<?>> startsForFeature(SectionPos pos, StructureFeature<?> feature) {
-        return this.level.getChunk(pos.x(), pos.z(), ChunkStatus.STRUCTURE_REFERENCES).getReferencesForFeature(feature).stream().map((long_) -> {
-            return SectionPos.of(new ChunkPos(long_), this.level.getMinSection());
-        }).map((posx) -> {
-            return this.getStartForFeature(posx, feature, this.level.getChunk(posx.x(), posx.z(), ChunkStatus.STRUCTURE_STARTS));
-        }).filter((structureStart) -> {
-            return structureStart != null && structureStart.isValid();
+        return this.level.getChunk(pos.x(), pos.z(), ChunkStatus.STRUCTURE_REFERENCES).getReferencesForFeature(feature).stream().map((olong) -> {
+            return SectionPos.of(new ChunkPos(olong), this.level.getMinSection());
+        }).map((sectionposition1) -> {
+            return this.getStartForFeature(sectionposition1, feature, this.level.getChunk(sectionposition1.x(), sectionposition1.z(), ChunkStatus.STRUCTURE_STARTS));
+        }).filter((structurestart) -> {
+            return structurestart != null && structurestart.isValid();
         });
     }
 
+    // Paper start - remove structure streams - based on method above
+    public java.util.List<StructureStart<?>> streamlessStartsForFeature(SectionPos sectionPosition, StructureFeature<?> structureGenerator) {
+        java.util.List<StructureStart<?>> list = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+        for (Long curLong : this.level.getChunk(sectionPosition.x(), sectionPosition.z(), ChunkStatus.STRUCTURE_REFERENCES).getReferencesForFeature(structureGenerator)) {
+            SectionPos sectionPosition1 = SectionPos.of(new ChunkPos(curLong), 0);
+            StructureStart<?> structurestart = getStartForFeature(sectionPosition1, structureGenerator, this.level.getChunk(sectionPosition1.x(), sectionPosition1.z(), ChunkStatus.STRUCTURE_STARTS));
+            if (structurestart != null && structurestart.isValid()) {
+                list.add(structurestart);
+            }
+        }
+        return list;
+    }
+    // Paper end
+
     @Nullable
     public StructureStart<?> getStartForFeature(SectionPos pos, StructureFeature<?> feature, FeatureAccess holder) {
         return holder.getStartForFeature(feature);
@@ -57,10 +77,25 @@
     }
 
     public StructureStart<?> getStructureAt(BlockPos pos, boolean matchChildren, StructureFeature<?> feature) {
-        return DataFixUtils.orElse(this.startsForFeature(SectionPos.of(pos), feature).filter((structureStart) -> {
-            return matchChildren ? structureStart.getPieces().stream().anyMatch((piece) -> {
-                return piece.getBoundingBox().isInside(pos);
-            }) : structureStart.getBoundingBox().isInside(pos);
-        }).findFirst(), StructureStart.INVALID_START);
+        // Paper start - remove structure streams
+        for (StructureStart<?> structureStart : streamlessStartsForFeature(SectionPos.of(pos), feature)) {
+            if (matchChildren) {
+                for (net.minecraft.world.level.levelgen.structure.StructurePiece piece : structureStart.getPieces()) {
+                    if (piece.getBoundingBox().isInside(pos)) {
+                        return structureStart;
+                    }
+                }
+            } else if (structureStart.getBoundingBox().isInside(pos)) {
+                return structureStart;
+            }
+        }
+        return StructureStart.INVALID_START;
+        // Paper end
     }
+
+    // Spigot start
+    public Level getWorld() {
+        return this.level.getMinecraftWorld();
+    }
+    // Spigot end
 }
