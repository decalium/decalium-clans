--- a/net/minecraft/world/level/storage/loot/entries/LootPoolSingletonContainer.java
+++ b/net/minecraft/world/level/storage/loot/entries/LootPoolSingletonContainer.java
@@ -16,7 +16,7 @@
 import net.minecraft.world.level.storage.loot.functions.LootItemFunction;
 import net.minecraft.world.level.storage.loot.functions.LootItemFunctions;
 import net.minecraft.world.level.storage.loot.predicates.LootItemCondition;
-import org.apache.commons.lang3.ArrayUtils;
+import org.bukkit.craftbukkit.libs.org.apache.commons.lang3.ArrayUtils;
 
 public abstract class LootPoolSingletonContainer extends LootPoolEntryContainer {
     public static final int DEFAULT_WEIGHT = 1;
@@ -26,6 +26,7 @@
     protected final LootItemFunction[] functions;
     final BiFunction<ItemStack, LootContext, ItemStack> compositeFunction;
     private final LootPoolEntry entry = new LootPoolSingletonContainer.EntryBase() {
+        @Override
         public void createItemStack(Consumer<ItemStack> lootConsumer, LootContext context) {
             LootPoolSingletonContainer.this.createItemStack(LootItemFunction.decorate(LootPoolSingletonContainer.this.compositeFunction, lootConsumer, context), context);
         }
@@ -39,6 +40,7 @@
         this.compositeFunction = LootItemFunctions.compose(functions);
     }
 
+    @Override
     public void validate(ValidationContext reporter) {
         super.validate(reporter);
 
@@ -50,6 +52,7 @@
 
     protected abstract void createItemStack(Consumer<ItemStack> lootConsumer, LootContext context);
 
+    @Override
     public boolean expand(LootContext context, Consumer<LootPoolEntry> choiceConsumer) {
         if (this.canRun(context)) {
             choiceConsumer.accept(this.entry);
@@ -68,6 +71,7 @@
         protected int quality = 0;
         private final List<LootItemFunction> functions = Lists.newArrayList();
 
+        @Override
         public T apply(LootItemFunction.Builder builder) {
             this.functions.add(builder.build());
             return this.getThis();
@@ -95,20 +99,49 @@
             this.constructor = factory;
         }
 
+        @Override
         protected LootPoolSingletonContainer.DummyBuilder getThis() {
             return this;
         }
 
+        @Override
         public LootPoolEntryContainer build() {
             return this.constructor.build(this.weight, this.quality, this.getConditions(), this.getFunctions());
         }
     }
 
     protected abstract class EntryBase implements LootPoolEntry {
+        @Override
         public int getWeight(float luck) {
-            return Math.max(Mth.floor((float)LootPoolSingletonContainer.this.weight + (float)LootPoolSingletonContainer.this.quality * luck), 0);
+            // Paper start - Offer an alternative loot formula to refactor how luck bonus applies
+            // SEE: https://luckformula.emc.gs for details and data
+            if (LootPoolSingletonContainer.this.lastLuck != null && LootPoolSingletonContainer.this.lastLuck == luck) {
+                return lastWeight;
+            }
+            // This is vanilla
+            float qualityModifer = (float) LootPoolSingletonContainer.this.quality * luck;
+            double baseWeight = (LootPoolSingletonContainer.this.weight + qualityModifer);
+            if (com.destroystokyo.paper.PaperConfig.useAlternativeLuckFormula) {
+                // Random boost to avoid losing precision in the final int cast on return
+                final int weightBoost = 100;
+                baseWeight *= weightBoost;
+                // If we have vanilla 1, bump that down to 0 so nothing is is impacted
+                // vanilla 3 = 300, 200 basis = impact 2%
+                // =($B2*(($B2-100)/100/100))
+                double impacted = baseWeight * ((baseWeight - weightBoost) / weightBoost / 100);
+                // =($B$7/100)
+                float luckModifier = Math.min(100, luck * 10) / 100;
+                // =B2 - (C2 *($B$7/100))
+                baseWeight = Math.ceil(baseWeight - (impacted * luckModifier));
+            }
+            LootPoolSingletonContainer.this.lastLuck = luck;
+            LootPoolSingletonContainer.this.lastWeight = (int) Math.max(Math.floor(baseWeight), 0);
+            return lastWeight;
         }
     }
+    private Float lastLuck = null;
+    private int lastWeight = 0;
+    // Paper end
 
     @FunctionalInterface
     protected interface EntryConstructor {
@@ -116,6 +149,7 @@
     }
 
     public abstract static class Serializer<T extends LootPoolSingletonContainer> extends LootPoolEntryContainer.Serializer<T> {
+        @Override
         public void serializeCustom(JsonObject json, T entry, JsonSerializationContext context) {
             if (entry.weight != 1) {
                 json.addProperty("weight", entry.weight);
@@ -131,6 +165,7 @@
 
         }
 
+        @Override
         public final T deserializeCustom(JsonObject jsonObject, JsonDeserializationContext jsonDeserializationContext, LootItemCondition[] lootItemConditions) {
             int i = GsonHelper.getAsInt(jsonObject, "weight", 1);
             int j = GsonHelper.getAsInt(jsonObject, "quality", 0);
