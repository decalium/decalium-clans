--- a/net/minecraft/server/level/DistanceManager.java
+++ b/net/minecraft/server/level/DistanceManager.java
@@ -9,11 +9,11 @@
 import it.unimi.dsi.fastutil.longs.Long2IntMaps;
 import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ObjectSet;
@@ -21,6 +21,8 @@
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
+import java.util.Iterator;
+import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
@@ -35,16 +37,26 @@
 import org.apache.logging.log4j.Logger;
 
 public abstract class DistanceManager {
+
     static final Logger LOGGER = LogManager.getLogger();
     private static final int ENTITY_TICKING_RANGE = 2;
     static final int PLAYER_TICKET_LEVEL = 33 + ChunkStatus.getDistance(ChunkStatus.FULL) - 2;
     private static final int INITIAL_TICKET_LIST_CAPACITY = 4;
-    final Long2ObjectMap<ObjectSet<ServerPlayer>> playersPerChunk = new Long2ObjectOpenHashMap<>();
-    final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap<>();
+    final Long2ObjectMap<ObjectSet<ServerPlayer>> playersPerChunk = new Long2ObjectOpenHashMap();
+    public final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap();
     private final DistanceManager.ChunkTicketTracker ticketTracker = new DistanceManager.ChunkTicketTracker();
-    private final DistanceManager.FixedPlayerDistanceChunkTracker naturalSpawnChunkCounter = new DistanceManager.FixedPlayerDistanceChunkTracker(8);
+    public static final int MOB_SPAWN_RANGE = 8; // private final ChunkMapDistance.b f = new ChunkMapDistance.b(8); // Paper - no longer used
     private final DistanceManager.PlayerTicketTracker playerTicketManager = new DistanceManager.PlayerTicketTracker(33);
-    final Set<ChunkHolder> chunksToUpdateFutures = Sets.newHashSet();
+    // Paper start use a queue, but still keep unique requirement
+    public final java.util.Queue<ChunkHolder> pendingChunkUpdates = new java.util.ArrayDeque<ChunkHolder>() {
+        @Override
+        public boolean add(ChunkHolder o) {
+            if (o.isUpdateQueued) return true;
+            o.isUpdateQueued = true;
+            return super.add(o);
+        }
+    };
+    // Paper end
     final ChunkTaskPriorityQueueSorter ticketThrottler;
     final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> ticketThrottlerInput;
     final ProcessorHandle<ChunkTaskPriorityQueueSorter.Release> ticketThrottlerReleaser;
@@ -52,36 +64,42 @@
     final Executor mainThreadExecutor;
     private long ticketTickCounter;
 
+    ChunkMap chunkMap; // Paper
+
     protected DistanceManager(Executor workerExecutor, Executor mainThreadExecutor) {
-        ProcessorHandle<Runnable> processorHandle = ProcessorHandle.of("player ticket throttler", mainThreadExecutor::execute);
-        ChunkTaskPriorityQueueSorter chunkTaskPriorityQueueSorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(processorHandle), workerExecutor, 4);
-        this.ticketThrottler = chunkTaskPriorityQueueSorter;
-        this.ticketThrottlerInput = chunkTaskPriorityQueueSorter.getProcessor(processorHandle, true);
-        this.ticketThrottlerReleaser = chunkTaskPriorityQueueSorter.getReleaseProcessor(processorHandle);
+        Objects.requireNonNull(mainThreadExecutor);
+        ProcessorHandle<Runnable> mailbox = ProcessorHandle.of("player ticket throttler", mainThreadExecutor::execute);
+        ChunkTaskPriorityQueueSorter chunktaskqueuesorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(mailbox), workerExecutor, 4);
+
+        this.ticketThrottler = chunktaskqueuesorter;
+        this.ticketThrottlerInput = chunktaskqueuesorter.getProcessor(mailbox, true);
+        this.ticketThrottlerReleaser = chunktaskqueuesorter.getReleaseProcessor(mailbox);
         this.mainThreadExecutor = mainThreadExecutor;
     }
 
     protected void purgeStaleTickets() {
         ++this.ticketTickCounter;
-        ObjectIterator<Entry<SortedArraySet<Ticket<?>>>> objectIterator = this.tickets.long2ObjectEntrySet().fastIterator();
+        ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
 
-        while(objectIterator.hasNext()) {
-            Entry<SortedArraySet<Ticket<?>>> entry = objectIterator.next();
-            if (entry.getValue().removeIf((ticket) -> {
+        while (objectiterator.hasNext()) {
+            Entry<SortedArraySet<Ticket<?>>> entry = (Entry) objectiterator.next();
+
+            if ((entry.getValue()).removeIf((ticket) -> { // CraftBukkit - decompile error
                 return ticket.timedOut(this.ticketTickCounter);
             })) {
-                this.ticketTracker.update(entry.getLongKey(), getTicketLevelAt(entry.getValue()), false);
+                this.ticketTracker.update(entry.getLongKey(), DistanceManager.getTicketLevelAt((SortedArraySet) entry.getValue()), false);
             }
 
-            if (entry.getValue().isEmpty()) {
-                objectIterator.remove();
+            if (((SortedArraySet) entry.getValue()).isEmpty()) {
+                objectiterator.remove();
             }
         }
 
     }
 
-    private static int getTicketLevelAt(SortedArraySet<Ticket<?>> sortedArraySet) {
-        return !sortedArraySet.isEmpty() ? sortedArraySet.first().getTicketLevel() : ChunkMap.MAX_CHUNK_DISTANCE + 1;
+    private static int getTicketLevelAt(SortedArraySet<Ticket<?>> arraysetsorted) {
+        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::getLowestTicketLevel"); // Paper
+        return !arraysetsorted.isEmpty() ? ((Ticket) arraysetsorted.first()).getTicketLevel() : ChunkMap.MAX_CHUNK_DISTANCE + 1;
     }
 
     protected abstract boolean isChunkToRemove(long pos);
@@ -90,41 +108,52 @@
     protected abstract ChunkHolder getChunk(long pos);
 
     @Nullable
-    protected abstract ChunkHolder updateChunkScheduling(long pos, int level, @Nullable ChunkHolder holder, int i);
+    protected abstract ChunkHolder updateChunkScheduling(long pos, int level, @Nullable ChunkHolder holder, int k);
 
-    public boolean runAllUpdates(ChunkMap chunkMap) {
-        this.naturalSpawnChunkCounter.runAllUpdates();
+    public boolean runAllUpdates(ChunkMap playerchunkmap) {
+        //this.f.a(); // Paper - no longer used
+        org.spigotmc.AsyncCatcher.catchOp("DistanceManagerTick"); // Paper
         this.playerTicketManager.runAllUpdates();
         int i = Integer.MAX_VALUE - this.ticketTracker.runDistanceUpdates(Integer.MAX_VALUE);
-        boolean bl = i != 0;
-        if (bl) {
+        boolean flag = i != 0;
+
+        if (flag) {
+            ;
         }
 
-        if (!this.chunksToUpdateFutures.isEmpty()) {
-            this.chunksToUpdateFutures.forEach((chunkHolderx) -> {
-                chunkHolderx.updateFutures(chunkMap, this.mainThreadExecutor);
-            });
-            this.chunksToUpdateFutures.clear();
+        // Paper start
+        if (!this.pendingChunkUpdates.isEmpty()) {
+            this.pollingPendingChunkUpdates = true; try { // Paper - Chunk priority
+            while(!this.pendingChunkUpdates.isEmpty()) {
+                ChunkHolder remove = this.pendingChunkUpdates.remove();
+                remove.isUpdateQueued = false;
+                remove.updateFutures(playerchunkmap, this.mainThreadExecutor);
+            }
+            } finally { this.pollingPendingChunkUpdates = false; } // Paper - Chunk priority
+            // Paper end
             return true;
         } else {
             if (!this.ticketsToRelease.isEmpty()) {
-                LongIterator longIterator = this.ticketsToRelease.iterator();
+                LongIterator longiterator = this.ticketsToRelease.iterator();
 
-                while(longIterator.hasNext()) {
-                    long l = longIterator.nextLong();
-                    if (this.getTickets(l).stream().anyMatch((ticket) -> {
+                while (longiterator.hasNext()) {
+                    long j = longiterator.nextLong();
+
+                    if (this.getTickets(j).stream().anyMatch((ticket) -> {
                         return ticket.getType() == TicketType.PLAYER;
                     })) {
-                        ChunkHolder chunkHolder = chunkMap.getUpdatingChunkIfPresent(l);
-                        if (chunkHolder == null) {
+                        ChunkHolder playerchunk = playerchunkmap.getUpdatingChunkIfPresent(j);
+
+                        if (playerchunk == null) {
                             throw new IllegalStateException();
                         }
 
-                        CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completableFuture = chunkHolder.getEntityTickingChunkFuture();
-                        completableFuture.thenAccept((either) -> {
+                        CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture = playerchunk.getEntityTickingChunkFuture();
+
+                        completablefuture.thenAccept((either) -> {
                             this.mainThreadExecutor.execute(() -> {
                                 this.ticketThrottlerReleaser.tell(ChunkTaskPriorityQueueSorter.release(() -> {
-                                }, l, false));
+                                }, j, false));
                             });
                         });
                     }
@@ -133,40 +162,89 @@
                 this.ticketsToRelease.clear();
             }
 
-            return bl;
+            return flag;
         }
     }
+    boolean pollingPendingChunkUpdates = false; // Paper - Chunk priority
 
-    void addTicket(long position, Ticket<?> ticket) {
-        SortedArraySet<Ticket<?>> sortedArraySet = this.getTickets(position);
-        int i = getTicketLevelAt(sortedArraySet);
-        Ticket<?> ticket2 = sortedArraySet.addOrGet(ticket);
-        ticket2.setCreatedTick(this.ticketTickCounter);
-        if (ticket.getTicketLevel() < i) {
-            this.ticketTracker.update(position, ticket.getTicketLevel(), true);
+    boolean addTicket(long i, Ticket<?> ticket) { // CraftBukkit - void -> boolean
+        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::addTicket"); // Paper
+        SortedArraySet<Ticket<?>> arraysetsorted = this.getTickets(i);
+        int j = DistanceManager.getTicketLevelAt(arraysetsorted);
+        Ticket<?> ticket1 = (Ticket) arraysetsorted.addOrGet(ticket); // CraftBukkit - decompile error
+
+        ticket1.setCreatedTick(this.ticketTickCounter);
+        if (ticket.getTicketLevel() < j) {
+            this.ticketTracker.update(i, ticket.getTicketLevel(), true);
         }
 
+        return ticket == ticket1; // CraftBukkit
     }
 
-    void removeTicket(long pos, Ticket<?> ticket) {
-        SortedArraySet<Ticket<?>> sortedArraySet = this.getTickets(pos);
-        if (sortedArraySet.remove(ticket)) {
+    boolean removeTicket(long i, Ticket<?> ticket) { // CraftBukkit - void -> boolean
+        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::removeTicket"); // Paper
+        SortedArraySet<Ticket<?>> arraysetsorted = this.getTickets(i);
+        int oldLevel = getTicketLevelAt(arraysetsorted); // Paper
+
+        boolean removed = false; // CraftBukkit
+        if (arraysetsorted.remove(ticket)) {
+            removed = true; // CraftBukkit
+            // Paper start - delay chunk unloads for player tickets
+            long delayChunkUnloadsBy = chunkMap.level.paperConfig.delayChunkUnloadsBy;
+            if (ticket.getType() == TicketType.PLAYER && delayChunkUnloadsBy > 0) {
+                boolean hasPlayer = false;
+                for (Ticket<?> ticket1 : arraysetsorted) {
+                    if (ticket1.getType() == TicketType.PLAYER) {
+                        hasPlayer = true;
+                        break;
+                    }
+                }
+                ChunkHolder playerChunk = chunkMap.getUpdatingChunkIfPresent(i);
+                if (!hasPlayer && playerChunk != null && playerChunk.isFullChunkReady()) {
+                    Ticket<Long> delayUnload = new Ticket<Long>(TicketType.DELAY_UNLOAD, 33, i);
+                    delayUnload.delayUnloadBy = delayChunkUnloadsBy;
+                    delayUnload.setCreatedTick(this.ticketTickCounter);
+                    arraysetsorted.remove(delayUnload);
+                    // refresh ticket
+                    arraysetsorted.add(delayUnload);
+                }
+            }
+            // Paper end
         }
 
-        if (sortedArraySet.isEmpty()) {
-            this.tickets.remove(pos);
+        if (arraysetsorted.isEmpty()) {
+            this.tickets.remove(i);
         }
 
-        this.ticketTracker.update(pos, getTicketLevelAt(sortedArraySet), false);
+        // Paper start - Chunk priority
+        int newLevel = getTicketLevelAt(arraysetsorted);
+        if (newLevel > oldLevel) {
+            this.ticketTracker.update(i, newLevel, false);
+        }
+        // Paper end
+        return removed; // CraftBukkit
     }
 
     public <T> void addTicket(TicketType<T> type, ChunkPos pos, int level, T argument) {
-        this.addTicket(pos.toLong(), new Ticket<>(type, level, argument));
+        // CraftBukkit start
+        this.addTicketAtLevel(type, pos, level, argument);
+    }
+
+    public <T> boolean addTicketAtLevel(TicketType<T> ticketType, ChunkPos chunkcoordintpair, int level, T identifier) {
+        return this.addTicket(chunkcoordintpair.toLong(), new Ticket<>(ticketType, level, identifier));
+        // CraftBukkit end
     }
 
     public <T> void removeTicket(TicketType<T> type, ChunkPos pos, int level, T argument) {
-        Ticket<T> ticket = new Ticket<>(type, level, argument);
-        this.removeTicket(pos.toLong(), ticket);
+        // CraftBukkit start
+        this.removeTicketAtLevel(type, pos, level, argument);
+    }
+
+    public <T> boolean removeTicketAtLevel(TicketType<T> ticketType, ChunkPos chunkcoordintpair, int level, T identifier) {
+        Ticket<T> ticket = new Ticket<>(ticketType, level, identifier);
+
+        return this.removeTicket(chunkcoordintpair.toLong(), ticket);
+        // CraftBukkit end
     }
 
     public <T> void addRegionTicket(TicketType<T> type, ChunkPos pos, int radius, T argument) {
@@ -175,17 +253,149 @@
 
     public <T> void removeRegionTicket(TicketType<T> type, ChunkPos pos, int radius, T argument) {
         Ticket<T> ticket = new Ticket<>(type, 33 - radius, argument);
+
         this.removeTicket(pos.toLong(), ticket);
     }
 
     private SortedArraySet<Ticket<?>> getTickets(long position) {
-        return this.tickets.computeIfAbsent(position, (l) -> {
+        return (SortedArraySet) this.tickets.computeIfAbsent(position, (j) -> {
             return SortedArraySet.create(4);
         });
     }
 
+    // Paper start - Chunk priority
+    public static final int PRIORITY_TICKET_LEVEL = ChunkMap.MAX_CHUNK_DISTANCE;
+    public static final int URGENT_PRIORITY = 29;
+    public boolean delayDistanceManagerTick = false;
+    public boolean markUrgent(ChunkPos coords) {
+        return addPriorityTicket(coords, TicketType.URGENT, URGENT_PRIORITY);
+    }
+    public boolean markHighPriority(ChunkPos coords, int priority) {
+        priority = Math.min(URGENT_PRIORITY - 1, Math.max(1, priority));
+        return addPriorityTicket(coords, TicketType.PRIORITY, priority);
+    }
+
+    public void markAreaHighPriority(ChunkPos center, int priority, int radius) {
+        delayDistanceManagerTick = true;
+        priority = Math.min(URGENT_PRIORITY - 1, Math.max(1, priority));
+        int finalPriority = priority;
+        net.minecraft.server.MCUtil.getSpiralOutChunks(center.getWorldPosition(), radius).forEach(coords -> {
+            addPriorityTicket(coords, TicketType.PRIORITY, finalPriority);
+        });
+        delayDistanceManagerTick = false;
+        chunkMap.level.getChunkSource().runDistanceManagerUpdates();
+    }
+
+    public void clearAreaPriorityTickets(ChunkPos center, int radius) {
+        delayDistanceManagerTick = true;
+        net.minecraft.server.MCUtil.getSpiralOutChunks(center.getWorldPosition(), radius).forEach(coords -> {
+            this.removeTicket(coords.toLong(), new Ticket<ChunkPos>(TicketType.PRIORITY, PRIORITY_TICKET_LEVEL, coords));
+        });
+        delayDistanceManagerTick = false;
+        chunkMap.level.getChunkSource().runDistanceManagerUpdates();
+    }
+
+    private boolean hasPlayerTicket(ChunkPos coords, int level) {
+        SortedArraySet<Ticket<?>> tickets = this.tickets.get(coords.toLong());
+        if (tickets == null || tickets.isEmpty()) {
+            return false;
+        }
+        for (Ticket<?> ticket : tickets) {
+            if (ticket.getType() == TicketType.PLAYER && ticket.getTicketLevel() == level) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private boolean addPriorityTicket(ChunkPos coords, TicketType<ChunkPos> ticketType, int priority) {
+        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::addPriorityTicket");
+        long pair = coords.toLong();
+        ChunkHolder chunk = chunkMap.getUpdatingChunkIfPresent(pair);
+        boolean needsTicket = chunkMap.playerViewDistanceNoTickMap.getObjectsInRange(pair) != null && !hasPlayerTicket(coords, 33);
+
+        if (needsTicket) {
+            Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, 33, coords);
+            this.ticketsToRelease.add(pair);
+            addTicket(pair, ticket);
+        }
+        if ((chunk != null && chunk.isFullChunkReady())) {
+            if (needsTicket) {
+                chunkMap.level.getChunkSource().runDistanceManagerUpdates();
+            }
+            return needsTicket;
+        }
+
+        boolean success;
+        if (!(success = updatePriorityTicket(coords, ticketType, priority))) {
+            Ticket<ChunkPos> ticket = new Ticket<ChunkPos>(ticketType, PRIORITY_TICKET_LEVEL, coords);
+            ticket.priority = priority;
+            success = this.addTicket(pair, ticket);
+        } else {
+            if (chunk == null) {
+                chunk = chunkMap.getUpdatingChunkIfPresent(pair);
+            }
+            chunkMap.queueHolderUpdate(chunk);
+        }
+
+        //chunkMap.world.getWorld().spawnParticle(priority <= 15 ? org.bukkit.Particle.EXPLOSION_HUGE : org.bukkit.Particle.EXPLOSION_NORMAL, chunkMap.world.getWorld().getPlayers(), null, coords.x << 4, 70, coords.z << 4, 2, 0, 0, 0, 1, null, true);
+
+        chunkMap.level.getChunkSource().runDistanceManagerUpdates();
+
+        return success;
+    }
+
+    private boolean updatePriorityTicket(ChunkPos coords, TicketType<ChunkPos> type, int priority) {
+        SortedArraySet<Ticket<?>> tickets = this.tickets.get(coords.toLong());
+        if (tickets == null) {
+            return false;
+        }
+        for (Ticket<?> ticket : tickets) {
+            if (ticket.getType() == type) {
+                // We only support increasing, not decreasing, too complicated
+                ticket.setCreatedTick(this.ticketTickCounter);
+                ticket.priority = Math.max(ticket.priority, priority);
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    public int getChunkPriority(ChunkPos coords) {
+        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::getChunkPriority");
+        SortedArraySet<Ticket<?>> tickets = this.tickets.get(coords.toLong());
+        if (tickets == null) {
+            return 0;
+        }
+        for (Ticket<?> ticket : tickets) {
+            if (ticket.getType() == TicketType.URGENT) {
+                return URGENT_PRIORITY;
+            }
+        }
+        for (Ticket<?> ticket : tickets) {
+            if (ticket.getType() == TicketType.PRIORITY && ticket.priority > 0) {
+                return ticket.priority;
+            }
+        }
+        return 0;
+    }
+
+    public void clearPriorityTickets(ChunkPos coords) {
+        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::clearPriority");
+        this.removeTicket(coords.toLong(), new Ticket<ChunkPos>(TicketType.PRIORITY, PRIORITY_TICKET_LEVEL, coords));
+    }
+
+    public void clearUrgent(ChunkPos coords) {
+        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::clearUrgent");
+        this.removeTicket(coords.toLong(), new Ticket<ChunkPos>(TicketType.URGENT, PRIORITY_TICKET_LEVEL, coords));
+    }
+    // Paper end
+
     protected void updateChunkForced(ChunkPos pos, boolean forced) {
         Ticket<ChunkPos> ticket = new Ticket<>(TicketType.FORCED, 31, pos);
+
         if (forced) {
             this.addTicket(pos.toLong(), ticket);
         } else {
@@ -195,117 +405,154 @@
     }
 
     public void addPlayer(SectionPos pos, ServerPlayer player) {
-        long l = pos.chunk().toLong();
-        this.playersPerChunk.computeIfAbsent(l, (lx) -> {
+        long i = pos.chunk().toLong();
+
+        ((ObjectSet) this.playersPerChunk.computeIfAbsent(i, (j) -> {
             return new ObjectOpenHashSet();
-        }).add(player);
-        this.naturalSpawnChunkCounter.update(l, 0, true);
-        this.playerTicketManager.update(l, 0, true);
+        })).add(player);
+        //this.f.update(i, 0, true); // Paper - no longer used
+        this.playerTicketManager.update(i, 0, true);
     }
 
     public void removePlayer(SectionPos pos, ServerPlayer player) {
-        long l = pos.chunk().toLong();
-        ObjectSet<ServerPlayer> objectSet = this.playersPerChunk.get(l);
-        objectSet.remove(player);
-        if (objectSet.isEmpty()) {
-            this.playersPerChunk.remove(l);
-            this.naturalSpawnChunkCounter.update(l, Integer.MAX_VALUE, false);
-            this.playerTicketManager.update(l, Integer.MAX_VALUE, false);
+        long i = pos.chunk().toLong();
+        ObjectSet<ServerPlayer> objectset = (ObjectSet) this.playersPerChunk.get(i);
+        if (objectset == null) return; // CraftBukkit - SPIGOT-6208
+
+        if (objectset != null) objectset.remove(player); // Paper - some state corruption happens here, don't crash, clean up gracefully.
+        if (objectset == null || objectset.isEmpty()) { // Paper
+            this.playersPerChunk.remove(i);
+            //this.f.update(i, Integer.MAX_VALUE, false); // Paper - no longer used
+            this.playerTicketManager.update(i, Integer.MAX_VALUE, false);
         }
 
     }
 
     protected String getTicketDebugString(long pos) {
-        SortedArraySet<Ticket<?>> sortedArraySet = this.tickets.get(pos);
-        String string2;
-        if (sortedArraySet != null && !sortedArraySet.isEmpty()) {
-            string2 = sortedArraySet.first().toString();
+        SortedArraySet<Ticket<?>> arraysetsorted = (SortedArraySet) this.tickets.get(pos);
+        String s;
+
+        if (arraysetsorted != null && !arraysetsorted.isEmpty()) {
+            s = ((Ticket) arraysetsorted.first()).toString();
         } else {
-            string2 = "no_ticket";
+            s = "no_ticket";
         }
 
-        return string2;
+        return s;
     }
 
-    protected void updatePlayerTickets(int viewDistance) {
-        this.playerTicketManager.updateViewDistance(viewDistance);
+    protected void setNoTickViewDistance(int i) { // Paper - force abi breakage on usage change
+        this.playerTicketManager.updateViewDistance(i);
     }
 
     public int getNaturalSpawnChunkCount() {
-        this.naturalSpawnChunkCounter.runAllUpdates();
-        return this.naturalSpawnChunkCounter.chunks.size();
+        // Paper start - use distance map to implement
+        // note: this is the spawn chunk count
+        return this.chunkMap.playerChunkTickRangeMap.size();
+        // Paper end - use distance map to implement
     }
 
-    public boolean hasPlayersNearby(long l) {
-        this.naturalSpawnChunkCounter.runAllUpdates();
-        return this.naturalSpawnChunkCounter.chunks.containsKey(l);
+    public boolean hasPlayersNearby(long i) {
+        // Paper start - use distance map to implement
+        // note: this is the is spawn chunk method
+        return this.chunkMap.playerChunkTickRangeMap.getObjectsInRange(i) != null;
+        // Paper end - use distance map to implement
     }
 
     public String getDebugStatus() {
         return this.ticketThrottler.getDebugStatus();
     }
 
-    private void dumpTickets(String string) {
+    private void dumpTickets(String s) {
         try {
-            FileOutputStream fileOutputStream = new FileOutputStream(new File(string));
+            FileOutputStream fileoutputstream = new FileOutputStream(new File(s));
 
             try {
-                for(Entry<SortedArraySet<Ticket<?>>> entry : this.tickets.long2ObjectEntrySet()) {
-                    ChunkPos chunkPos = new ChunkPos(entry.getLongKey());
+                ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().iterator();
 
-                    for(Ticket<?> ticket : entry.getValue()) {
-                        fileOutputStream.write((chunkPos.x + "\t" + chunkPos.z + "\t" + ticket.getType() + "\t" + ticket.getTicketLevel() + "\t\n").getBytes(StandardCharsets.UTF_8));
+                while (objectiterator.hasNext()) {
+                    Entry<SortedArraySet<Ticket<?>>> entry = (Entry) objectiterator.next();
+                    ChunkPos chunkcoordintpair = new ChunkPos(entry.getLongKey());
+                    Iterator iterator = ((SortedArraySet) entry.getValue()).iterator();
+
+                    while (iterator.hasNext()) {
+                        Ticket<?> ticket = (Ticket) iterator.next();
+
+                        fileoutputstream.write((chunkcoordintpair.x + "\t" + chunkcoordintpair.z + "\t" + ticket.getType() + "\t" + ticket.getTicketLevel() + "\t\n").getBytes(StandardCharsets.UTF_8));
                     }
                 }
-            } catch (Throwable var9) {
+            } catch (Throwable throwable) {
                 try {
-                    fileOutputStream.close();
-                } catch (Throwable var8) {
-                    var9.addSuppressed(var8);
+                    fileoutputstream.close();
+                } catch (Throwable throwable1) {
+                    throwable.addSuppressed(throwable1);
                 }
 
-                throw var9;
+                throw throwable;
             }
 
-            fileOutputStream.close();
-        } catch (IOException var10) {
-            LOGGER.error(var10);
+            fileoutputstream.close();
+        } catch (IOException ioexception) {
+            DistanceManager.LOGGER.error(ioexception);
         }
 
     }
 
-    class ChunkTicketTracker extends ChunkTracker {
+    // CraftBukkit start
+    public <T> void removeAllTicketsFor(TicketType<T> ticketType, int ticketLevel, T ticketIdentifier) {
+        Ticket<T> target = new Ticket<>(ticketType, ticketLevel, ticketIdentifier);
+
+        for (java.util.Iterator<Entry<SortedArraySet<Ticket<?>>>> iterator = this.tickets.long2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
+            Entry<SortedArraySet<Ticket<?>>> entry = iterator.next();
+            SortedArraySet<Ticket<?>> tickets = entry.getValue();
+            if (tickets.remove(target)) {
+                // copied from removeTicket
+                this.ticketTracker.update(entry.getLongKey(), DistanceManager.getTicketLevelAt(tickets), false);
+
+                // can't use entry after it's removed
+                if (tickets.isEmpty()) {
+                    iterator.remove();
+                }
+            }
+        }
+    }
+    // CraftBukkit end
+
+    private class ChunkTicketTracker extends ChunkTracker {
+
         public ChunkTicketTracker() {
             super(ChunkMap.MAX_CHUNK_DISTANCE + 2, 16, 256);
         }
 
+        @Override
         protected int getLevelFromSource(long id) {
-            SortedArraySet<Ticket<?>> sortedArraySet = DistanceManager.this.tickets.get(id);
-            if (sortedArraySet == null) {
-                return Integer.MAX_VALUE;
-            } else {
-                return sortedArraySet.isEmpty() ? Integer.MAX_VALUE : sortedArraySet.first().getTicketLevel();
-            }
+            SortedArraySet<Ticket<?>> arraysetsorted = (SortedArraySet) DistanceManager.this.tickets.get(id);
+
+            return arraysetsorted == null ? Integer.MAX_VALUE : (arraysetsorted.isEmpty() ? Integer.MAX_VALUE : ((Ticket) arraysetsorted.first()).getTicketLevel());
         }
 
+        @Override
         protected int getLevel(long id) {
             if (!DistanceManager.this.isChunkToRemove(id)) {
-                ChunkHolder chunkHolder = DistanceManager.this.getChunk(id);
-                if (chunkHolder != null) {
-                    return chunkHolder.getTicketLevel();
+                ChunkHolder playerchunk = DistanceManager.this.getChunk(id);
+
+                if (playerchunk != null) {
+                    return playerchunk.getTicketLevel();
                 }
             }
 
             return ChunkMap.MAX_CHUNK_DISTANCE + 1;
         }
 
+        @Override
         protected void setLevel(long id, int level) {
-            ChunkHolder chunkHolder = DistanceManager.this.getChunk(id);
-            int i = chunkHolder == null ? ChunkMap.MAX_CHUNK_DISTANCE + 1 : chunkHolder.getTicketLevel();
-            if (i != level) {
-                chunkHolder = DistanceManager.this.updateChunkScheduling(id, level, chunkHolder, i);
-                if (chunkHolder != null) {
-                    DistanceManager.this.chunksToUpdateFutures.add(chunkHolder);
+            ChunkHolder playerchunk = DistanceManager.this.getChunk(id);
+            int k = playerchunk == null ? ChunkMap.MAX_CHUNK_DISTANCE + 1 : playerchunk.getTicketLevel();
+
+            if (k != level) {
+                playerchunk = DistanceManager.this.updateChunkScheduling(id, level, playerchunk, k);
+                if (playerchunk != null) {
+                    DistanceManager.this.pendingChunkUpdates.add(playerchunk);
                 }
 
             }
@@ -316,122 +563,164 @@
         }
     }
 
-    class FixedPlayerDistanceChunkTracker extends ChunkTracker {
+    private class FixedPlayerDistanceChunkTracker extends ChunkTracker {
+
         protected final Long2ByteMap chunks = new Long2ByteOpenHashMap();
         protected final int maxDistance;
 
-        protected FixedPlayerDistanceChunkTracker(int maxDistance) {
-            super(maxDistance + 2, 16, 256);
-            this.maxDistance = maxDistance;
-            this.chunks.defaultReturnValue((byte)(maxDistance + 2));
+        protected FixedPlayerDistanceChunkTracker(int i) {
+            super(i + 2, 16, 256);
+            this.maxDistance = i;
+            this.chunks.defaultReturnValue((byte) (i + 2));
         }
 
+        @Override
         protected int getLevel(long id) {
             return this.chunks.get(id);
         }
 
+        @Override
         protected void setLevel(long id, int level) {
-            byte b;
+            byte b0;
+
             if (level > this.maxDistance) {
-                b = this.chunks.remove(id);
+                b0 = this.chunks.remove(id);
             } else {
-                b = this.chunks.put(id, (byte)level);
+                b0 = this.chunks.put(id, (byte) level);
             }
 
-            this.onLevelChange(id, b, level);
+            this.onLevelChange(id, b0, level);
         }
 
-        protected void onLevelChange(long pos, int oldDistance, int distance) {
-        }
+        protected void onLevelChange(long pos, int oldDistance, int distance) {}
 
+        @Override
         protected int getLevelFromSource(long id) {
             return this.havePlayer(id) ? 0 : Integer.MAX_VALUE;
         }
 
         private boolean havePlayer(long chunkPos) {
-            ObjectSet<ServerPlayer> objectSet = DistanceManager.this.playersPerChunk.get(chunkPos);
-            return objectSet != null && !objectSet.isEmpty();
+            ObjectSet<ServerPlayer> objectset = (ObjectSet) DistanceManager.this.playersPerChunk.get(chunkPos);
+
+            return objectset != null && !objectset.isEmpty();
         }
 
         public void runAllUpdates() {
             this.runUpdates(Integer.MAX_VALUE);
         }
 
-        private void dumpChunks(String string) {
+        private void dumpChunks(String s) {
             try {
-                FileOutputStream fileOutputStream = new FileOutputStream(new File(string));
+                FileOutputStream fileoutputstream = new FileOutputStream(new File(s));
 
                 try {
-                    for(it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry entry : this.chunks.long2ByteEntrySet()) {
-                        ChunkPos chunkPos = new ChunkPos(entry.getLongKey());
-                        String string2 = Byte.toString(entry.getByteValue());
-                        fileOutputStream.write((chunkPos.x + "\t" + chunkPos.z + "\t" + string2 + "\n").getBytes(StandardCharsets.UTF_8));
+                    ObjectIterator objectiterator = this.chunks.long2ByteEntrySet().iterator();
+
+                    while (objectiterator.hasNext()) {
+                        it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
+                        ChunkPos chunkcoordintpair = new ChunkPos(it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey());
+                        String s1 = Byte.toString(it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue());
+
+                        fileoutputstream.write((chunkcoordintpair.x + "\t" + chunkcoordintpair.z + "\t" + s1 + "\n").getBytes(StandardCharsets.UTF_8));
                     }
-                } catch (Throwable var8) {
+                } catch (Throwable throwable) {
                     try {
-                        fileOutputStream.close();
-                    } catch (Throwable var7) {
-                        var8.addSuppressed(var7);
+                        fileoutputstream.close();
+                    } catch (Throwable throwable1) {
+                        throwable.addSuppressed(throwable1);
                     }
 
-                    throw var8;
+                    throw throwable;
                 }
 
-                fileOutputStream.close();
-            } catch (IOException var9) {
-                DistanceManager.LOGGER.error(var9);
+                fileoutputstream.close();
+            } catch (IOException ioexception) {
+                DistanceManager.LOGGER.error(ioexception);
             }
 
         }
     }
 
-    class PlayerTicketTracker extends DistanceManager.FixedPlayerDistanceChunkTracker {
-        private int viewDistance;
+    private class PlayerTicketTracker extends DistanceManager.FixedPlayerDistanceChunkTracker {
+
+        private int viewDistance = 0;
         private final Long2IntMap queueLevels = Long2IntMaps.synchronize(new Long2IntOpenHashMap());
         private final LongSet toUpdate = new LongOpenHashSet();
 
         protected PlayerTicketTracker(int i) {
             super(i);
-            this.viewDistance = 0;
             this.queueLevels.defaultReturnValue(i + 2);
         }
 
+        @Override
         protected void onLevelChange(long pos, int oldDistance, int distance) {
             this.toUpdate.add(pos);
         }
 
         public void updateViewDistance(int watchDistance) {
-            for(it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry entry : this.chunks.long2ByteEntrySet()) {
-                byte b = entry.getByteValue();
-                long l = entry.getLongKey();
-                this.onLevelChange(l, b, this.haveTicketFor(b), b <= watchDistance - 2);
+            ObjectIterator objectiterator = this.chunks.long2ByteEntrySet().iterator();
+            // Paper start - set the view distance before scheduling chunk loads/unloads
+            int lastViewDistance = this.viewDistance;
+            this.viewDistance = watchDistance;
+            // Paper end
+
+            while (objectiterator.hasNext()) {
+                it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
+                byte b0 = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue();
+                long j = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey();
+
+                this.onLevelChange(j, b0, b0 <= lastViewDistance - 2, this.haveTicketFor(b0)); // Paper
             }
 
-            this.viewDistance = watchDistance;
+            // this.viewDistance = watchDistance; // Paper - view distance is now set further up
         }
 
         private void onLevelChange(long pos, int distance, boolean oldWithinViewDistance, boolean withinViewDistance) {
             if (oldWithinViewDistance != withinViewDistance) {
-                Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, DistanceManager.PLAYER_TICKET_LEVEL, new ChunkPos(pos));
+                ChunkPos coords = new ChunkPos(pos); // Paper - reuse variable
+                Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, 33, coords); // Paper - no-tick view distance
+
                 if (withinViewDistance) {
+                    scheduleChunkLoad(pos, net.minecraft.server.MinecraftServer.currentTick, distance, (priority) -> { // Paper - smarter ticket delay based on frustum and distance
+                    // Paper start - recheck its still valid if not cancel
+                    if (!isChunkInRange(pos)) {
+                        DistanceManager.this.ticketThrottlerReleaser.tell(ChunkTaskPriorityQueueSorter.release(() -> {
+                            DistanceManager.this.mainThreadExecutor.execute(() -> {
+                                DistanceManager.this.removeTicket(pos, ticket);
+                                DistanceManager.this.clearPriorityTickets(coords);
+                            });
+                        }, pos, false));
+                        return;
+                    }
+                    // abort early if we got a ticket already
+                    if (hasPlayerTicket(coords, 33)) return;
+                    // skip player ticket throttle for near chunks
+                    if (priority <= 3) {
+                        DistanceManager.this.addTicket(pos, ticket);
+                        DistanceManager.this.ticketsToRelease.add(pos);
+                        return;
+                    }
+                    // Paper end
                     DistanceManager.this.ticketThrottlerInput.tell(ChunkTaskPriorityQueueSorter.message(() -> {
                         DistanceManager.this.mainThreadExecutor.execute(() -> {
-                            if (this.haveTicketFor(this.getLevel(pos))) {
+                            if (isChunkInRange(pos)) { if (!hasPlayerTicket(coords, 33)) { // Paper - high priority might of already added it
                                 DistanceManager.this.addTicket(pos, ticket);
                                 DistanceManager.this.ticketsToRelease.add(pos);
-                            } else {
+                            }} else { // Paper
                                 DistanceManager.this.ticketThrottlerReleaser.tell(ChunkTaskPriorityQueueSorter.release(() -> {
                                 }, pos, false));
                             }
 
                         });
                     }, pos, () -> {
-                        return distance;
+                        return Math.min(ChunkMap.MAX_CHUNK_DISTANCE, priority); // Paper - Chunk priority
                     }));
+                    }); // Paper
                 } else {
                     DistanceManager.this.ticketThrottlerReleaser.tell(ChunkTaskPriorityQueueSorter.release(() -> {
                         DistanceManager.this.mainThreadExecutor.execute(() -> {
                             DistanceManager.this.removeTicket(pos, ticket);
+                            DistanceManager.this.clearPriorityTickets(coords); // Paper - Chunk priority
                         });
                     }, pos, true));
                 }
@@ -439,27 +728,29 @@
 
         }
 
+        @Override
         public void runAllUpdates() {
             super.runAllUpdates();
             if (!this.toUpdate.isEmpty()) {
-                LongIterator longIterator = this.toUpdate.iterator();
+                LongIterator longiterator = this.toUpdate.iterator();
 
-                while(longIterator.hasNext()) {
-                    long l = longIterator.nextLong();
-                    int i = this.queueLevels.get(l);
-                    int j = this.getLevel(l);
-                    if (i != j) {
-                        DistanceManager.this.ticketThrottler.onLevelChange(new ChunkPos(l), () -> {
-                            return this.queueLevels.get(l);
-                        }, j, (ix) -> {
-                            if (ix >= this.queueLevels.defaultReturnValue()) {
-                                this.queueLevels.remove(l);
+                while (longiterator.hasNext()) {
+                    long i = longiterator.nextLong();
+                    int j = this.queueLevels.get(i);
+                    int k = this.getLevel(i);
+
+                    if (j != k) {
+                        DistanceManager.this.ticketThrottler.onLevelChange(new ChunkPos(i), () -> {
+                            return this.queueLevels.get(i);
+                        }, k, (l) -> {
+                            if (l >= this.queueLevels.defaultReturnValue()) {
+                                this.queueLevels.remove(i);
                             } else {
-                                this.queueLevels.put(l, ix);
+                                this.queueLevels.put(i, l);
                             }
 
                         });
-                        this.onLevelChange(l, j, this.haveTicketFor(i), this.haveTicketFor(j));
+                        this.onLevelChange(i, k, this.haveTicketFor(j), this.haveTicketFor(k));
                     }
                 }
 
@@ -471,5 +762,100 @@
         private boolean haveTicketFor(int distance) {
             return distance <= this.viewDistance - 2;
         }
+
+        // Paper start - smart scheduling of player tickets
+        private boolean isChunkInRange(long i) {
+            return this.haveTicketFor(this.getLevel(i));
+        }
+        public void scheduleChunkLoad(long i, long startTick, int initialDistance, java.util.function.Consumer<Integer> task) {
+            long elapsed = net.minecraft.server.MinecraftServer.currentTick - startTick;
+            ChunkPos chunkPos = new ChunkPos(i);
+            ChunkHolder updatingChunk = chunkMap.getUpdatingChunkIfPresent(i);
+            if ((updatingChunk != null && updatingChunk.isFullChunkReady()) || !isChunkInRange(i) || getChunkPriority(chunkPos) > 0) { // Copied from above
+                // no longer needed
+                task.accept(1);
+                return;
+            }
+
+            int desireDelay = 0;
+            double minDist = Double.MAX_VALUE;
+            com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = chunkMap.playerViewDistanceNoTickMap.getObjectsInRange(i);
+            if (elapsed == 0 && initialDistance <= 4) {
+                // Aim for no delay on initial 6 chunk radius tickets save on performance of the below code to only > 6
+                minDist = initialDistance;
+            } else if (players != null) {
+                Object[] backingSet = players.getBackingSet();
+
+                net.minecraft.core.BlockPos blockPos = chunkPos.getWorldPosition();
+
+                boolean isFront = false;
+                net.minecraft.core.BlockPos.MutableBlockPos pos = new net.minecraft.core.BlockPos.MutableBlockPos();
+                for (int index = 0, len = backingSet.length; index < len; ++index) {
+                    if (!(backingSet[index] instanceof ServerPlayer)) {
+                        continue;
+                    }
+                    ServerPlayer player = (ServerPlayer) backingSet[index];
+
+                    ChunkPos pointInFront = player.getChunkInFront(5);
+                    pos.set(pointInFront.x << 4, 0, pointInFront.z << 4);
+                    double frontDist = net.minecraft.server.MCUtil.distanceSq(pos, blockPos);
+
+                    pos.set(player.getX(), 0, player.getZ());
+                    double center = net.minecraft.server.MCUtil.distanceSq(pos, blockPos);
+
+                    double dist = Math.min(frontDist, center);
+                    if (!isFront) {
+                        ChunkPos pointInBack = player.getChunkInFront(-7);
+                        pos.set(pointInBack.x << 4, 0, pointInBack.z << 4);
+                        double backDist = net.minecraft.server.MCUtil.distanceSq(pos, blockPos);
+                        if (frontDist < backDist) {
+                            isFront = true;
+                        }
+                    }
+                    if (dist < minDist) {
+                        minDist = dist;
+                    }
+                }
+                if (minDist == Double.MAX_VALUE) {
+                    minDist = 15;
+                } else {
+                    minDist = Math.sqrt(minDist) / 16;
+                }
+                if (minDist > 4) {
+                    int desiredTimeDelayMax = isFront ?
+                        (minDist < 10 ? 7 : 15) : // Front
+                        (minDist < 10 ? 15 : 45); // Back
+                    desireDelay += (desiredTimeDelayMax * 20) * (minDist / 32);
+                }
+            } else {
+                minDist = initialDistance;
+                desireDelay = 1;
+            }
+            long delay = desireDelay - elapsed;
+            if (delay <= 0 && minDist > 4 && minDist < Double.MAX_VALUE) {
+                boolean hasAnyNeighbor = false;
+                for (int x = -1; x <= 1; x++) {
+                    for (int z = -1; z <= 1; z++) {
+                        if (x == 0 && z == 0) continue;
+                        long pair = ChunkPos.asLong(chunkPos.x + x, chunkPos.z + z);
+                        ChunkHolder neighbor = chunkMap.getUpdatingChunkIfPresent(pair);
+                        ChunkStatus current = neighbor != null ? neighbor.getChunkHolderStatus() : null;
+                        if (current != null && current.isOrAfter(ChunkStatus.LIGHT)) {
+                            hasAnyNeighbor = true;
+                        }
+                    }
+                }
+                if (!hasAnyNeighbor) {
+                    delay += 20;
+                }
+            }
+            if (delay <= 0) {
+                task.accept((int) minDist);
+            } else {
+                int taskDelay = (int) Math.min(delay, minDist >= 10 ? 40 : (minDist < 6 ? 5 : 20));
+                net.minecraft.server.MCUtil.scheduleTask(taskDelay, () -> scheduleChunkLoad(i, startTick, initialDistance, task), "Player Ticket Delayer");
+            }
+        }
+        // Paper end
     }
 }
