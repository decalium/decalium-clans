--- a/net/minecraft/world/level/block/state/properties/IntegerProperty.java
+++ b/net/minecraft/world/level/block/state/properties/IntegerProperty.java
@@ -7,10 +7,17 @@
 import java.util.Set;
 
 public class IntegerProperty extends Property<Integer> {
+
     private final ImmutableSet<Integer> values;
+    // CraftBukkit start
+    public final int min;
+    public final int max;
 
     protected IntegerProperty(String name, int min, int max) {
         super(name, Integer.class);
+        this.min = min;
+        this.max = max;
+        // CraftBukkit end
         if (min < 0) {
             throw new IllegalArgumentException("Min value of " + name + " must be 0 or greater");
         } else if (max <= min) {
@@ -18,29 +25,32 @@
         } else {
             Set<Integer> set = Sets.newHashSet();
 
-            for(int i = min; i <= max; ++i) {
-                set.add(i);
+            for (int k = min; k <= max; ++k) {
+                set.add(k);
             }
 
             this.values = ImmutableSet.copyOf(set);
         }
     }
 
+    @Override
     public Collection<Integer> getPossibleValues() {
         return this.values;
     }
 
-    public boolean equals(Object object) {
+    public boolean equals_unused(Object object) { // Paper
         if (this == object) {
             return true;
         } else if (object instanceof IntegerProperty && super.equals(object)) {
-            IntegerProperty integerProperty = (IntegerProperty)object;
-            return this.values.equals(integerProperty.values);
+            IntegerProperty blockstateinteger = (IntegerProperty) object;
+
+            return this.values.equals(blockstateinteger.values);
         } else {
             return false;
         }
     }
 
+    @Override
     public int generateHashCode() {
         return 31 * super.generateHashCode() + this.values.hashCode();
     }
@@ -49,11 +59,13 @@
         return new IntegerProperty(name, min, max);
     }
 
+    @Override
     public Optional<Integer> getValue(String name) {
         try {
             Integer integer = Integer.valueOf(name);
+
             return this.values.contains(integer) ? Optional.of(integer) : Optional.empty();
-        } catch (NumberFormatException var3) {
+        } catch (NumberFormatException numberformatexception) {
             return Optional.empty();
         }
     }
