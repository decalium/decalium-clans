--- a/net/minecraft/world/level/chunk/DataLayer.java
+++ b/net/minecraft/world/level/chunk/DataLayer.java
@@ -1,24 +1,86 @@
+// mc-dev import
 package net.minecraft.world.level.chunk;
 
 import javax.annotation.Nullable;
 import net.minecraft.Util;
 import net.minecraft.util.VisibleForDebug;
 
-public final class DataLayer {
+public class DataLayer {
+
     public static final int LAYER_COUNT = 16;
     public static final int LAYER_SIZE = 128;
     public static final int SIZE = 2048;
     private static final int NIBBLE_SIZE = 4;
     @Nullable
     protected byte[] data;
+    // Paper start
+    public static final DataLayer EMPTY_NIBBLE_ARRAY = new DataLayer() {
+        @Override
+        public byte[] getData() {
+            throw new IllegalStateException();
+        }
+    };
+    public long lightCacheKey = Long.MIN_VALUE;
+    public static byte[] EMPTY_NIBBLE = new byte[2048];
+    private static final int nibbleBucketSizeMultiplier = Integer.getInteger("Paper.nibbleBucketSize", 3072);
+    private static final int maxPoolSize = Integer.getInteger("Paper.maxNibblePoolSize", (int) Math.min(6, Math.max(1, Runtime.getRuntime().maxMemory() / 1024 / 1024 / 1024)) * (nibbleBucketSizeMultiplier * 8));
+    public static final com.destroystokyo.paper.util.pooled.PooledObjects<byte[]> BYTE_2048 = new com.destroystokyo.paper.util.pooled.PooledObjects<>(() -> new byte[2048], maxPoolSize);
+    public static void releaseBytes(byte[] bytes) {
+        if (bytes != null && bytes != EMPTY_NIBBLE && bytes.length == 2048) {
+            System.arraycopy(EMPTY_NIBBLE, 0, bytes, 0, 2048);
+            BYTE_2048.release(bytes);
+        }
+    }
 
-    public DataLayer() {
+    public DataLayer markPoolSafe(byte[] bytes) {
+        if (bytes != EMPTY_NIBBLE) this.data = bytes;
+        return markPoolSafe();
     }
+    public DataLayer markPoolSafe() {
+        poolSafe = true;
+        return this;
+    }
+    public byte[] getIfSet() {
+        return this.data != null ? this.data : EMPTY_NIBBLE;
+    }
+    public byte[] getCloneIfSet() {
+        if (data == null) {
+            return EMPTY_NIBBLE;
+        }
+        byte[] ret = BYTE_2048.acquire();
+        System.arraycopy(getIfSet(), 0, ret, 0, 2048);
+        return ret;
+    }
+
+    public DataLayer cloneAndSet(byte[] bytes) {
+        if (bytes != null && bytes != EMPTY_NIBBLE) {
+            this.data = BYTE_2048.acquire();
+            System.arraycopy(bytes, 0, this.data, 0, 2048);
+        }
+        return this;
+    }
+    boolean poolSafe = false;
+    public java.lang.Runnable cleaner;
+    private void registerCleaner() {
+        if (!poolSafe) {
+            cleaner = net.minecraft.server.MCUtil.registerCleaner(this, this.data, DataLayer::releaseBytes);
+        } else {
+            cleaner = net.minecraft.server.MCUtil.once(() -> DataLayer.releaseBytes(this.data));
+        }
+    }
+    public DataLayer() {}
 
     public DataLayer(byte[] bytes) {
+        // Paper start
+        this(bytes, false);
+    }
+    public DataLayer(byte[] bytes, boolean isSafe) {
         this.data = bytes;
+        if (!isSafe) this.data = getCloneIfSet(); // Paper - clone for safety
+        registerCleaner();
+        // Paper end
         if (bytes.length != 2048) {
-            throw (IllegalArgumentException)Util.pauseInIde(new IllegalArgumentException("DataLayer should be 2048 bytes not: " + bytes.length));
+            throw (IllegalArgumentException) Util.pauseInIde((Throwable) (new IllegalArgumentException("DataLayer should be 2048 bytes not: " + bytes.length)));
         }
     }
 
@@ -27,11 +89,11 @@
     }
 
     public int get(int x, int y, int z) {
-        return this.get(getIndex(x, y, z));
+        return this.get(DataLayer.getIndex(x, y, z));
     }
 
     public void set(int x, int y, int z, int value) {
-        this.set(getIndex(x, y, z), value);
+        this.set(DataLayer.getIndex(x, y, z), value);
     }
 
     private static int getIndex(int i, int x, int y) {
@@ -42,22 +104,25 @@
         if (this.data == null) {
             return 0;
         } else {
-            int i = getByteIndex(index);
-            int j = getNibbleIndex(index);
-            return this.data[i] >> 4 * j & 15;
+            int j = DataLayer.getByteIndex(index);
+            int k = DataLayer.getNibbleIndex(index);
+
+            return this.data[j] >> 4 * k & 15;
         }
     }
 
     private void set(int index, int value) {
         if (this.data == null) {
-            this.data = new byte[2048];
+            this.data = BYTE_2048.acquire(); // Paper
+            registerCleaner();// Paper
         }
 
-        int i = getByteIndex(index);
-        int j = getNibbleIndex(index);
-        int k = ~(15 << 4 * j);
-        int l = (value & 15) << 4 * j;
-        this.data[i] = (byte)(this.data[i] & k | l);
+        int k = DataLayer.getByteIndex(index);
+        int l = DataLayer.getNibbleIndex(index);
+        int i1 = ~(15 << 4 * l);
+        int j1 = (value & 15) << 4 * l;
+
+        this.data[k] = (byte) (this.data[k] & i1 | j1);
     }
 
     private static int getNibbleIndex(int i) {
@@ -71,44 +136,64 @@
     public byte[] getData() {
         if (this.data == null) {
             this.data = new byte[2048];
+        } else { // Paper start
+            // Accessor may need this object past garbage collection so need to clone it and return pooled value
+            // If we know its safe for pre GC access, use asBytesPoolSafe(). If you just need read, use getIfSet()
+            Runnable cleaner = this.cleaner;
+            if (cleaner != null) {
+                this.data = this.data.clone();
+                cleaner.run(); // release the previously pooled value
+                this.cleaner = null;
+            }
         }
+        // Paper end
 
         return this.data;
     }
 
+    @javax.annotation.Nonnull
+    public byte[] asBytesPoolSafe() {
+        if (this.data == null) {
+            this.data = BYTE_2048.acquire(); // Paper
+            registerCleaner(); // Paper
+        }
+
+        return this.data;
+    }
+    // Paper end
     public DataLayer copy() {
-        return this.data == null ? new DataLayer() : new DataLayer((byte[])this.data.clone());
+        return this.data == null ? new DataLayer() : new DataLayer(this.data); // Paper - clone in ctor
     }
 
     public String toString() {
-        StringBuilder stringBuilder = new StringBuilder();
+        StringBuilder stringbuilder = new StringBuilder();
 
-        for(int i = 0; i < 4096; ++i) {
-            stringBuilder.append(Integer.toHexString(this.get(i)));
+        for (int i = 0; i < 4096; ++i) {
+            stringbuilder.append(Integer.toHexString(this.get(i)));
             if ((i & 15) == 15) {
-                stringBuilder.append("\n");
+                stringbuilder.append("\n");
             }
 
             if ((i & 255) == 255) {
-                stringBuilder.append("\n");
+                stringbuilder.append("\n");
             }
         }
 
-        return stringBuilder.toString();
+        return stringbuilder.toString();
     }
 
     @VisibleForDebug
     public String layerToString(int i) {
-        StringBuilder stringBuilder = new StringBuilder();
+        StringBuilder stringbuilder = new StringBuilder();
 
-        for(int j = 0; j < 256; ++j) {
-            stringBuilder.append(Integer.toHexString(this.get(j)));
+        for (int j = 0; j < 256; ++j) {
+            stringbuilder.append(Integer.toHexString(this.get(j)));
             if ((j & 15) == 15) {
-                stringBuilder.append("\n");
+                stringbuilder.append("\n");
             }
         }
 
-        return stringBuilder.toString();
+        return stringbuilder.toString();
     }
 
     public boolean isEmpty() {
