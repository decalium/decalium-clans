--- a/net/minecraft/commands/arguments/blocks/BlockStateParser.java
+++ b/net/minecraft/commands/arguments/blocks/BlockStateParser.java
@@ -1,6 +1,7 @@
 package net.minecraft.commands.arguments.blocks;
 
 import com.google.common.collect.Maps;
+import com.google.common.collect.UnmodifiableIterator;
 import com.mojang.brigadier.StringReader;
 import com.mojang.brigadier.exceptions.CommandSyntaxException;
 import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
@@ -9,10 +10,11 @@
 import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
 import com.mojang.brigadier.suggestion.Suggestions;
 import com.mojang.brigadier.suggestion.SuggestionsBuilder;
+import java.util.Iterator;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Optional;
 import java.util.Map.Entry;
+import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
 import java.util.function.BiFunction;
 import javax.annotation.Nullable;
@@ -30,21 +32,22 @@
 import net.minecraft.world.level.block.state.properties.Property;
 
 public class BlockStateParser {
+
     public static final SimpleCommandExceptionType ERROR_NO_TAGS_ALLOWED = new SimpleCommandExceptionType(new TranslatableComponent("argument.block.tag.disallowed"));
     public static final DynamicCommandExceptionType ERROR_UNKNOWN_BLOCK = new DynamicCommandExceptionType((object) -> {
-        return new TranslatableComponent("argument.block.id.invalid", object);
+        return new TranslatableComponent("argument.block.id.invalid", new Object[]{object});
     });
-    public static final Dynamic2CommandExceptionType ERROR_UNKNOWN_PROPERTY = new Dynamic2CommandExceptionType((object, object2) -> {
-        return new TranslatableComponent("argument.block.property.unknown", object, object2);
+    public static final Dynamic2CommandExceptionType ERROR_UNKNOWN_PROPERTY = new Dynamic2CommandExceptionType((object, object1) -> {
+        return new TranslatableComponent("argument.block.property.unknown", new Object[]{object, object1});
     });
-    public static final Dynamic2CommandExceptionType ERROR_DUPLICATE_PROPERTY = new Dynamic2CommandExceptionType((object, object2) -> {
-        return new TranslatableComponent("argument.block.property.duplicate", object2, object);
+    public static final Dynamic2CommandExceptionType ERROR_DUPLICATE_PROPERTY = new Dynamic2CommandExceptionType((object, object1) -> {
+        return new TranslatableComponent("argument.block.property.duplicate", new Object[]{object1, object});
     });
-    public static final Dynamic3CommandExceptionType ERROR_INVALID_VALUE = new Dynamic3CommandExceptionType((object, object2, object3) -> {
-        return new TranslatableComponent("argument.block.property.invalid", object, object3, object2);
+    public static final Dynamic3CommandExceptionType ERROR_INVALID_VALUE = new Dynamic3CommandExceptionType((object, object1, object2) -> {
+        return new TranslatableComponent("argument.block.property.invalid", new Object[]{object, object2, object1});
     });
-    public static final Dynamic2CommandExceptionType ERROR_EXPECTED_VALUE = new Dynamic2CommandExceptionType((object, object2) -> {
-        return new TranslatableComponent("argument.block.property.novalue", object, object2);
+    public static final Dynamic2CommandExceptionType ERROR_EXPECTED_VALUE = new Dynamic2CommandExceptionType((object, object1) -> {
+        return new TranslatableComponent("argument.block.property.novalue", new Object[]{object, object1});
     });
     public static final SimpleCommandExceptionType ERROR_EXPECTED_END_OF_PROPERTIES = new SimpleCommandExceptionType(new TranslatableComponent("argument.block.property.unclosed"));
     private static final char SYNTAX_START_PROPERTIES = '[';
@@ -53,23 +56,24 @@
     private static final char SYNTAX_EQUALS = '=';
     private static final char SYNTAX_PROPERTY_SEPARATOR = ',';
     private static final char SYNTAX_TAG = '#';
-    private static final BiFunction<SuggestionsBuilder, TagCollection<Block>, CompletableFuture<Suggestions>> SUGGEST_NOTHING = (suggestionsBuilder, tagCollection) -> {
-        return suggestionsBuilder.buildFuture();
+    private static final BiFunction<SuggestionsBuilder, TagCollection<Block>, CompletableFuture<Suggestions>> SUGGEST_NOTHING = (suggestionsbuilder, tags) -> {
+        return suggestionsbuilder.buildFuture();
     };
     private final StringReader reader;
     private final boolean forTesting;
-    private final Map<Property<?>, Comparable<?>> properties = Maps.newHashMap();
+    private final Map<Property<?>, Comparable<?>> properties = Maps.newLinkedHashMap(); // CraftBukkit - stable
     private final Map<String, String> vagueProperties = Maps.newHashMap();
-    private ResourceLocation id = new ResourceLocation("");
+    public ResourceLocation id = new ResourceLocation("");
     private StateDefinition<Block, BlockState> definition;
     private BlockState state;
     @Nullable
     private CompoundTag nbt;
     private ResourceLocation tag = new ResourceLocation("");
     private int tagCursor;
-    private BiFunction<SuggestionsBuilder, TagCollection<Block>, CompletableFuture<Suggestions>> suggestions = SUGGEST_NOTHING;
+    private BiFunction<SuggestionsBuilder, TagCollection<Block>, CompletableFuture<Suggestions>> suggestions;
 
     public BlockStateParser(StringReader reader, boolean allowTag) {
+        this.suggestions = BlockStateParser.SUGGEST_NOTHING;
         this.reader = reader;
         this.forTesting = allowTag;
     }
@@ -112,75 +116,92 @@
         }
 
         if (allowNbt && this.reader.canRead() && this.reader.peek() == '{') {
-            this.suggestions = SUGGEST_NOTHING;
+            this.suggestions = BlockStateParser.SUGGEST_NOTHING;
             this.readNbt();
         }
 
         return this;
     }
 
-    private CompletableFuture<Suggestions> suggestPropertyNameOrEnd(SuggestionsBuilder suggestionsBuilder, TagCollection<Block> tagCollection) {
-        if (suggestionsBuilder.getRemaining().isEmpty()) {
-            suggestionsBuilder.suggest(String.valueOf(']'));
+    private CompletableFuture<Suggestions> suggestPropertyNameOrEnd(SuggestionsBuilder suggestionsbuilder, TagCollection<Block> tags) {
+        if (suggestionsbuilder.getRemaining().isEmpty()) {
+            suggestionsbuilder.suggest(String.valueOf(']'));
         }
 
-        return this.suggestPropertyName(suggestionsBuilder, tagCollection);
+        return this.suggestPropertyName(suggestionsbuilder, tags);
     }
 
-    private CompletableFuture<Suggestions> suggestVaguePropertyNameOrEnd(SuggestionsBuilder suggestionsBuilder, TagCollection<Block> tagCollection) {
-        if (suggestionsBuilder.getRemaining().isEmpty()) {
-            suggestionsBuilder.suggest(String.valueOf(']'));
+    private CompletableFuture<Suggestions> suggestVaguePropertyNameOrEnd(SuggestionsBuilder suggestionsbuilder, TagCollection<Block> tags) {
+        if (suggestionsbuilder.getRemaining().isEmpty()) {
+            suggestionsbuilder.suggest(String.valueOf(']'));
         }
 
-        return this.suggestVaguePropertyName(suggestionsBuilder, tagCollection);
+        return this.suggestVaguePropertyName(suggestionsbuilder, tags);
     }
 
-    private CompletableFuture<Suggestions> suggestPropertyName(SuggestionsBuilder suggestionsBuilder, TagCollection<Block> tagCollection) {
-        String string = suggestionsBuilder.getRemaining().toLowerCase(Locale.ROOT);
+    private CompletableFuture<Suggestions> suggestPropertyName(SuggestionsBuilder suggestionsbuilder, TagCollection<Block> tags) {
+        String s = suggestionsbuilder.getRemaining().toLowerCase(Locale.ROOT);
+        Iterator iterator = this.state.getProperties().iterator();
 
-        for(Property<?> property : this.state.getProperties()) {
-            if (!this.properties.containsKey(property) && property.getName().startsWith(string)) {
-                suggestionsBuilder.suggest(property.getName() + "=");
+        while (iterator.hasNext()) {
+            Property<?> iblockstate = (Property) iterator.next();
+
+            if (!this.properties.containsKey(iblockstate) && iblockstate.getName().startsWith(s)) {
+                suggestionsbuilder.suggest(iblockstate.getName() + "=");
             }
         }
 
-        return suggestionsBuilder.buildFuture();
+        return suggestionsbuilder.buildFuture();
     }
 
-    private CompletableFuture<Suggestions> suggestVaguePropertyName(SuggestionsBuilder suggestionsBuilder, TagCollection<Block> tagCollection) {
-        String string = suggestionsBuilder.getRemaining().toLowerCase(Locale.ROOT);
+    private CompletableFuture<Suggestions> suggestVaguePropertyName(SuggestionsBuilder suggestionsbuilder, TagCollection<Block> tags) {
+        String s = suggestionsbuilder.getRemaining().toLowerCase(Locale.ROOT);
+
         if (this.tag != null && !this.tag.getPath().isEmpty()) {
-            Tag<Block> tag = tagCollection.getTag(this.tag);
+            Tag<Block> tag = tags.getTag(this.tag);
+
             if (tag != null) {
-                for(Block block : tag.getValues()) {
-                    for(Property<?> property : block.getStateDefinition().getProperties()) {
-                        if (!this.vagueProperties.containsKey(property.getName()) && property.getName().startsWith(string)) {
-                            suggestionsBuilder.suggest(property.getName() + "=");
+                Iterator iterator = tag.getValues().iterator();
+
+                while (iterator.hasNext()) {
+                    Block block = (Block) iterator.next();
+                    Iterator iterator1 = block.getStateDefinition().getProperties().iterator();
+
+                    while (iterator1.hasNext()) {
+                        Property<?> iblockstate = (Property) iterator1.next();
+
+                        if (!this.vagueProperties.containsKey(iblockstate.getName()) && iblockstate.getName().startsWith(s)) {
+                            suggestionsbuilder.suggest(iblockstate.getName() + "=");
                         }
                     }
                 }
             }
         }
 
-        return suggestionsBuilder.buildFuture();
+        return suggestionsbuilder.buildFuture();
     }
 
-    private CompletableFuture<Suggestions> suggestOpenNbt(SuggestionsBuilder suggestionsBuilder, TagCollection<Block> tagCollection) {
-        if (suggestionsBuilder.getRemaining().isEmpty() && this.hasBlockEntity(tagCollection)) {
-            suggestionsBuilder.suggest(String.valueOf('{'));
+    private CompletableFuture<Suggestions> suggestOpenNbt(SuggestionsBuilder suggestionsbuilder, TagCollection<Block> tags) {
+        if (suggestionsbuilder.getRemaining().isEmpty() && this.hasBlockEntity(tags)) {
+            suggestionsbuilder.suggest(String.valueOf('{'));
         }
 
-        return suggestionsBuilder.buildFuture();
+        return suggestionsbuilder.buildFuture();
     }
 
-    private boolean hasBlockEntity(TagCollection<Block> tagCollection) {
+    private boolean hasBlockEntity(TagCollection<Block> tags) {
         if (this.state != null) {
             return this.state.hasBlockEntity();
         } else {
             if (this.tag != null) {
-                Tag<Block> tag = tagCollection.getTag(this.tag);
+                Tag<Block> tag = tags.getTag(this.tag);
+
                 if (tag != null) {
-                    for(Block block : tag.getValues()) {
+                    Iterator iterator = tag.getValues().iterator();
+
+                    while (iterator.hasNext()) {
+                        Block block = (Block) iterator.next();
+
                         if (block.defaultBlockState().hasBlockEntity()) {
                             return true;
                         }
@@ -192,53 +213,67 @@
         }
     }
 
-    private CompletableFuture<Suggestions> suggestEquals(SuggestionsBuilder suggestionsBuilder, TagCollection<Block> tagCollection) {
-        if (suggestionsBuilder.getRemaining().isEmpty()) {
-            suggestionsBuilder.suggest(String.valueOf('='));
+    private CompletableFuture<Suggestions> suggestEquals(SuggestionsBuilder suggestionsbuilder, TagCollection<Block> tags) {
+        if (suggestionsbuilder.getRemaining().isEmpty()) {
+            suggestionsbuilder.suggest(String.valueOf('='));
         }
 
-        return suggestionsBuilder.buildFuture();
+        return suggestionsbuilder.buildFuture();
     }
 
-    private CompletableFuture<Suggestions> suggestNextPropertyOrEnd(SuggestionsBuilder suggestionsBuilder, TagCollection<Block> tagCollection) {
-        if (suggestionsBuilder.getRemaining().isEmpty()) {
-            suggestionsBuilder.suggest(String.valueOf(']'));
+    private CompletableFuture<Suggestions> suggestNextPropertyOrEnd(SuggestionsBuilder suggestionsbuilder, TagCollection<Block> tags) {
+        if (suggestionsbuilder.getRemaining().isEmpty()) {
+            suggestionsbuilder.suggest(String.valueOf(']'));
         }
 
-        if (suggestionsBuilder.getRemaining().isEmpty() && this.properties.size() < this.state.getProperties().size()) {
-            suggestionsBuilder.suggest(String.valueOf(','));
+        if (suggestionsbuilder.getRemaining().isEmpty() && this.properties.size() < this.state.getProperties().size()) {
+            suggestionsbuilder.suggest(String.valueOf(','));
         }
 
-        return suggestionsBuilder.buildFuture();
+        return suggestionsbuilder.buildFuture();
     }
 
-    private static <T extends Comparable<T>> SuggestionsBuilder addSuggestions(SuggestionsBuilder suggestionsBuilder, Property<T> property) {
-        for(T comparable : property.getPossibleValues()) {
-            if (comparable instanceof Integer) {
-                suggestionsBuilder.suggest(comparable);
+    private static <T extends Comparable<T>> SuggestionsBuilder addSuggestions(SuggestionsBuilder suggestionsbuilder, Property<T> iblockstate) {
+        Iterator iterator = iblockstate.getPossibleValues().iterator();
+
+        while (iterator.hasNext()) {
+            T t0 = (T) iterator.next(); // CraftBukkit - decompile error
+
+            if (t0 instanceof Integer) {
+                suggestionsbuilder.suggest((Integer) t0);
             } else {
-                suggestionsBuilder.suggest(property.getName(comparable));
+                suggestionsbuilder.suggest(iblockstate.getName(t0));
             }
         }
 
-        return suggestionsBuilder;
+        return suggestionsbuilder;
     }
 
-    private CompletableFuture<Suggestions> suggestVaguePropertyValue(SuggestionsBuilder suggestionsBuilder, TagCollection<Block> tagCollection, String string) {
-        boolean bl = false;
+    private CompletableFuture<Suggestions> suggestVaguePropertyValue(SuggestionsBuilder suggestionsbuilder, TagCollection<Block> tags, String s) {
+        boolean flag = false;
+
         if (this.tag != null && !this.tag.getPath().isEmpty()) {
-            Tag<Block> tag = tagCollection.getTag(this.tag);
+            Tag<Block> tag = tags.getTag(this.tag);
+
             if (tag != null) {
-                for(Block block : tag.getValues()) {
-                    Property<?> property = block.getStateDefinition().getProperty(string);
-                    if (property != null) {
-                        addSuggestions(suggestionsBuilder, property);
+                Iterator iterator = tag.getValues().iterator();
+
+                while (iterator.hasNext()) {
+                    Block block = (Block) iterator.next();
+                    Property<?> iblockstate = block.getStateDefinition().getProperty(s);
+
+                    if (iblockstate != null) {
+                        BlockStateParser.addSuggestions(suggestionsbuilder, iblockstate);
                     }
 
-                    if (!bl) {
-                        for(Property<?> property2 : block.getStateDefinition().getProperties()) {
-                            if (!this.vagueProperties.containsKey(property2.getName())) {
-                                bl = true;
+                    if (!flag) {
+                        Iterator iterator1 = block.getStateDefinition().getProperties().iterator();
+
+                        while (iterator1.hasNext()) {
+                            Property<?> iblockstate1 = (Property) iterator1.next();
+
+                            if (!this.vagueProperties.containsKey(iblockstate1.getName())) {
+                                flag = true;
                                 break;
                             }
                         }
@@ -247,83 +282,89 @@
             }
         }
 
-        if (bl) {
-            suggestionsBuilder.suggest(String.valueOf(','));
+        if (flag) {
+            suggestionsbuilder.suggest(String.valueOf(','));
         }
 
-        suggestionsBuilder.suggest(String.valueOf(']'));
-        return suggestionsBuilder.buildFuture();
+        suggestionsbuilder.suggest(String.valueOf(']'));
+        return suggestionsbuilder.buildFuture();
     }
 
-    private CompletableFuture<Suggestions> suggestOpenVaguePropertiesOrNbt(SuggestionsBuilder suggestionsBuilder, TagCollection<Block> tagCollection) {
-        if (suggestionsBuilder.getRemaining().isEmpty()) {
-            Tag<Block> tag = tagCollection.getTag(this.tag);
+    private CompletableFuture<Suggestions> suggestOpenVaguePropertiesOrNbt(SuggestionsBuilder suggestionsbuilder, TagCollection<Block> tags) {
+        if (suggestionsbuilder.getRemaining().isEmpty()) {
+            Tag<Block> tag = tags.getTag(this.tag);
+
             if (tag != null) {
-                boolean bl = false;
-                boolean bl2 = false;
+                boolean flag = false;
+                boolean flag1 = false;
+                Iterator iterator = tag.getValues().iterator();
 
-                for(Block block : tag.getValues()) {
-                    bl |= !block.getStateDefinition().getProperties().isEmpty();
-                    bl2 |= block.defaultBlockState().hasBlockEntity();
-                    if (bl && bl2) {
+                while (iterator.hasNext()) {
+                    Block block = (Block) iterator.next();
+
+                    flag |= !block.getStateDefinition().getProperties().isEmpty();
+                    flag1 |= block.defaultBlockState().hasBlockEntity();
+                    if (flag && flag1) {
                         break;
                     }
                 }
 
-                if (bl) {
-                    suggestionsBuilder.suggest(String.valueOf('['));
+                if (flag) {
+                    suggestionsbuilder.suggest(String.valueOf('['));
                 }
 
-                if (bl2) {
-                    suggestionsBuilder.suggest(String.valueOf('{'));
+                if (flag1) {
+                    suggestionsbuilder.suggest(String.valueOf('{'));
                 }
             }
         }
 
-        return this.suggestTag(suggestionsBuilder, tagCollection);
+        return this.suggestTag(suggestionsbuilder, tags);
     }
 
-    private CompletableFuture<Suggestions> suggestOpenPropertiesOrNbt(SuggestionsBuilder suggestionsBuilder, TagCollection<Block> tagCollection) {
-        if (suggestionsBuilder.getRemaining().isEmpty()) {
+    private CompletableFuture<Suggestions> suggestOpenPropertiesOrNbt(SuggestionsBuilder suggestionsbuilder, TagCollection<Block> tags) {
+        if (suggestionsbuilder.getRemaining().isEmpty()) {
             if (!this.state.getBlock().getStateDefinition().getProperties().isEmpty()) {
-                suggestionsBuilder.suggest(String.valueOf('['));
+                suggestionsbuilder.suggest(String.valueOf('['));
             }
 
             if (this.state.hasBlockEntity()) {
-                suggestionsBuilder.suggest(String.valueOf('{'));
+                suggestionsbuilder.suggest(String.valueOf('{'));
             }
         }
 
-        return suggestionsBuilder.buildFuture();
+        return suggestionsbuilder.buildFuture();
     }
 
-    private CompletableFuture<Suggestions> suggestTag(SuggestionsBuilder suggestionsBuilder, TagCollection<Block> tagCollection) {
-        return SharedSuggestionProvider.suggestResource(tagCollection.getAvailableTags(), suggestionsBuilder.createOffset(this.tagCursor).add(suggestionsBuilder));
+    private CompletableFuture<Suggestions> suggestTag(SuggestionsBuilder suggestionsbuilder, TagCollection<Block> tags) {
+        return SharedSuggestionProvider.suggestResource((Iterable) tags.getAvailableTags(), suggestionsbuilder.createOffset(this.tagCursor).add(suggestionsbuilder));
     }
 
-    private CompletableFuture<Suggestions> suggestBlockIdOrTag(SuggestionsBuilder suggestionsBuilder, TagCollection<Block> tagCollection) {
+    private CompletableFuture<Suggestions> suggestBlockIdOrTag(SuggestionsBuilder suggestionsbuilder, TagCollection<Block> tags) {
         if (this.forTesting) {
-            SharedSuggestionProvider.suggestResource(tagCollection.getAvailableTags(), suggestionsBuilder, String.valueOf('#'));
+            SharedSuggestionProvider.suggestResource((Iterable) tags.getAvailableTags(), suggestionsbuilder, String.valueOf('#'));
         }
 
-        SharedSuggestionProvider.suggestResource(Registry.BLOCK.keySet(), suggestionsBuilder);
-        return suggestionsBuilder.buildFuture();
+        SharedSuggestionProvider.suggestResource((Iterable) Registry.BLOCK.keySet(), suggestionsbuilder);
+        return suggestionsbuilder.buildFuture();
     }
 
     public void readBlock() throws CommandSyntaxException {
         int i = this.reader.getCursor();
+
         this.id = ResourceLocation.read(this.reader);
-        Block block = Registry.BLOCK.getOptional(this.id).orElseThrow(() -> {
+        Block block = (Block) Registry.BLOCK.getOptional(this.id).orElseThrow(() -> {
             this.reader.setCursor(i);
-            return ERROR_UNKNOWN_BLOCK.createWithContext(this.reader, this.id.toString());
+            return BlockStateParser.ERROR_UNKNOWN_BLOCK.createWithContext(this.reader, this.id.toString());
         });
+
         this.definition = block.getStateDefinition();
         this.state = block.defaultBlockState();
     }
 
     public void readTag() throws CommandSyntaxException {
         if (!this.forTesting) {
-            throw ERROR_NO_TAGS_ALLOWED.create();
+            throw BlockStateParser.ERROR_NO_TAGS_ALLOWED.create();
         } else {
             this.suggestions = this::suggestTag;
             this.reader.expect('#');
@@ -337,35 +378,37 @@
         this.suggestions = this::suggestPropertyNameOrEnd;
         this.reader.skipWhitespace();
 
-        while(true) {
+        while (true) {
             if (this.reader.canRead() && this.reader.peek() != ']') {
                 this.reader.skipWhitespace();
                 int i = this.reader.getCursor();
-                String string = this.reader.readString();
-                Property<?> property = this.definition.getProperty(string);
-                if (property == null) {
+                String s = this.reader.readString();
+                Property<?> iblockstate = this.definition.getProperty(s);
+
+                if (iblockstate == null) {
                     this.reader.setCursor(i);
-                    throw ERROR_UNKNOWN_PROPERTY.createWithContext(this.reader, this.id.toString(), string);
+                    throw BlockStateParser.ERROR_UNKNOWN_PROPERTY.createWithContext(this.reader, this.id.toString(), s);
                 }
 
-                if (this.properties.containsKey(property)) {
+                if (this.properties.containsKey(iblockstate)) {
                     this.reader.setCursor(i);
-                    throw ERROR_DUPLICATE_PROPERTY.createWithContext(this.reader, this.id.toString(), string);
+                    throw BlockStateParser.ERROR_DUPLICATE_PROPERTY.createWithContext(this.reader, this.id.toString(), s);
                 }
 
                 this.reader.skipWhitespace();
                 this.suggestions = this::suggestEquals;
                 if (!this.reader.canRead() || this.reader.peek() != '=') {
-                    throw ERROR_EXPECTED_VALUE.createWithContext(this.reader, this.id.toString(), string);
+                    throw BlockStateParser.ERROR_EXPECTED_VALUE.createWithContext(this.reader, this.id.toString(), s);
                 }
 
                 this.reader.skip();
                 this.reader.skipWhitespace();
-                this.suggestions = (suggestionsBuilder, tagCollection) -> {
-                    return addSuggestions(suggestionsBuilder, property).buildFuture();
+                this.suggestions = (suggestionsbuilder, tags) -> {
+                    return BlockStateParser.addSuggestions(suggestionsbuilder, iblockstate).buildFuture();
                 };
                 int j = this.reader.getCursor();
-                this.setValue(property, this.reader.readString(), j);
+
+                this.setValue(iblockstate, this.reader.readString(), j);
                 this.suggestions = this::suggestNextPropertyOrEnd;
                 this.reader.skipWhitespace();
                 if (!this.reader.canRead()) {
@@ -379,7 +422,7 @@
                 }
 
                 if (this.reader.peek() != ']') {
-                    throw ERROR_EXPECTED_END_OF_PROPERTIES.createWithContext(this.reader);
+                    throw BlockStateParser.ERROR_EXPECTED_END_OF_PROPERTIES.createWithContext(this.reader);
                 }
             }
 
@@ -388,7 +431,7 @@
                 return;
             }
 
-            throw ERROR_EXPECTED_END_OF_PROPERTIES.createWithContext(this.reader);
+            throw BlockStateParser.ERROR_EXPECTED_END_OF_PROPERTIES.createWithContext(this.reader);
         }
     }
 
@@ -396,32 +439,35 @@
         this.reader.skip();
         this.suggestions = this::suggestVaguePropertyNameOrEnd;
         int i = -1;
+
         this.reader.skipWhitespace();
 
-        while(true) {
+        while (true) {
             if (this.reader.canRead() && this.reader.peek() != ']') {
                 this.reader.skipWhitespace();
                 int j = this.reader.getCursor();
-                String string = this.reader.readString();
-                if (this.vagueProperties.containsKey(string)) {
+                String s = this.reader.readString();
+
+                if (this.vagueProperties.containsKey(s)) {
                     this.reader.setCursor(j);
-                    throw ERROR_DUPLICATE_PROPERTY.createWithContext(this.reader, this.id.toString(), string);
+                    throw BlockStateParser.ERROR_DUPLICATE_PROPERTY.createWithContext(this.reader, this.id.toString(), s);
                 }
 
                 this.reader.skipWhitespace();
                 if (!this.reader.canRead() || this.reader.peek() != '=') {
                     this.reader.setCursor(j);
-                    throw ERROR_EXPECTED_VALUE.createWithContext(this.reader, this.id.toString(), string);
+                    throw BlockStateParser.ERROR_EXPECTED_VALUE.createWithContext(this.reader, this.id.toString(), s);
                 }
 
                 this.reader.skip();
                 this.reader.skipWhitespace();
-                this.suggestions = (suggestionsBuilder, tagCollection) -> {
-                    return this.suggestVaguePropertyValue(suggestionsBuilder, tagCollection, string);
+                this.suggestions = (suggestionsbuilder, tags) -> {
+                    return this.suggestVaguePropertyValue(suggestionsbuilder, tags, s);
                 };
                 i = this.reader.getCursor();
-                String string2 = this.reader.readString();
-                this.vagueProperties.put(string, string2);
+                String s1 = this.reader.readString();
+
+                this.vagueProperties.put(s, s1);
                 this.reader.skipWhitespace();
                 if (!this.reader.canRead()) {
                     continue;
@@ -435,7 +481,7 @@
                 }
 
                 if (this.reader.peek() != ']') {
-                    throw ERROR_EXPECTED_END_OF_PROPERTIES.createWithContext(this.reader);
+                    throw BlockStateParser.ERROR_EXPECTED_END_OF_PROPERTIES.createWithContext(this.reader);
                 }
             }
 
@@ -448,7 +494,7 @@
                 this.reader.setCursor(i);
             }
 
-            throw ERROR_EXPECTED_END_OF_PROPERTIES.createWithContext(this.reader);
+            throw BlockStateParser.ERROR_EXPECTED_END_OF_PROPERTIES.createWithContext(this.reader);
         }
     }
 
@@ -456,46 +502,49 @@
         this.nbt = (new TagParser(this.reader)).readStruct();
     }
 
-    private <T extends Comparable<T>> void setValue(Property<T> property, String string, int i) throws CommandSyntaxException {
-        Optional<T> optional = property.getValue(string);
+    private <T extends Comparable<T>> void setValue(Property<T> iblockstate, String s, int i) throws CommandSyntaxException {
+        Optional<T> optional = iblockstate.getValue(s);
+
         if (optional.isPresent()) {
-            this.state = this.state.setValue(property, optional.get());
-            this.properties.put(property, optional.get());
+            this.state = (BlockState) this.state.setValue(iblockstate, (T) optional.get()); // CraftBukkit - decompile error
+            this.properties.put(iblockstate, (Comparable) optional.get());
         } else {
             this.reader.setCursor(i);
-            throw ERROR_INVALID_VALUE.createWithContext(this.reader, this.id.toString(), property.getName(), string);
+            throw BlockStateParser.ERROR_INVALID_VALUE.createWithContext(this.reader, this.id.toString(), iblockstate.getName(), s);
         }
     }
 
-    public static String serialize(BlockState blockState) {
-        StringBuilder stringBuilder = new StringBuilder(Registry.BLOCK.getKey(blockState.getBlock()).toString());
-        if (!blockState.getProperties().isEmpty()) {
-            stringBuilder.append('[');
-            boolean bl = false;
+    public static String serialize(BlockState iblockdata) {
+        StringBuilder stringbuilder = new StringBuilder(Registry.BLOCK.getKey(iblockdata.getBlock()).toString());
 
-            for(Entry<Property<?>, Comparable<?>> entry : blockState.getValues().entrySet()) {
-                if (bl) {
-                    stringBuilder.append(',');
+        if (!iblockdata.getProperties().isEmpty()) {
+            stringbuilder.append('[');
+            boolean flag = false;
+
+            for (UnmodifiableIterator unmodifiableiterator = iblockdata.getValues().entrySet().iterator(); unmodifiableiterator.hasNext(); flag = true) {
+                Entry<Property<?>, Comparable<?>> entry = (Entry) unmodifiableiterator.next();
+
+                if (flag) {
+                    stringbuilder.append(',');
                 }
 
-                appendProperty(stringBuilder, entry.getKey(), entry.getValue());
-                bl = true;
+                BlockStateParser.appendProperty(stringbuilder, (Property) entry.getKey(), (Comparable) entry.getValue());
             }
 
-            stringBuilder.append(']');
+            stringbuilder.append(']');
         }
 
-        return stringBuilder.toString();
+        return stringbuilder.toString();
     }
 
-    private static <T extends Comparable<T>> void appendProperty(StringBuilder stringBuilder, Property<T> property, Comparable<?> comparable) {
-        stringBuilder.append(property.getName());
-        stringBuilder.append('=');
-        stringBuilder.append(property.getName((T)comparable));
+    private static <T extends Comparable<T>> void appendProperty(StringBuilder stringbuilder, Property<T> iblockstate, Comparable<?> comparable) {
+        stringbuilder.append(iblockstate.getName());
+        stringbuilder.append('=');
+        stringbuilder.append(iblockstate.getName((T) comparable)); // CraftBukkit - decompile error
     }
 
-    public CompletableFuture<Suggestions> fillSuggestions(SuggestionsBuilder suggestionsBuilder, TagCollection<Block> tagCollection) {
-        return this.suggestions.apply(suggestionsBuilder.createOffset(this.reader.getCursor()), tagCollection);
+    public CompletableFuture<Suggestions> fillSuggestions(SuggestionsBuilder suggestionsbuilder, TagCollection<Block> tags) {
+        return (CompletableFuture) this.suggestions.apply(suggestionsbuilder.createOffset(this.reader.getCursor()), tags);
     }
 
     public Map<String, String> getVagueProperties() {
