--- a/net/minecraft/world/entity/monster/Pillager.java
+++ b/net/minecraft/world/entity/monster/Pillager.java
@@ -55,16 +55,18 @@
 import net.minecraft.world.level.block.state.BlockState;
 
 public class Pillager extends AbstractIllager implements CrossbowAttackMob, InventoryCarrier {
+
     private static final EntityDataAccessor<Boolean> IS_CHARGING_CROSSBOW = SynchedEntityData.defineId(Pillager.class, EntityDataSerializers.BOOLEAN);
     private static final int INVENTORY_SIZE = 5;
     private static final int SLOT_OFFSET = 300;
     private static final float CROSSBOW_POWER = 1.6F;
-    private final SimpleContainer inventory = new SimpleContainer(5);
+    public final SimpleContainer inventory = new SimpleContainer(5);
 
     public Pillager(EntityType<? extends Pillager> type, Level world) {
         super(type, world);
     }
 
+    @Override
     protected void registerGoals() {
         super.registerGoals();
         this.goalSelector.addGoal(0, new FloatGoal(this));
@@ -73,154 +75,169 @@
         this.goalSelector.addGoal(8, new RandomStrollGoal(this, 0.6D));
         this.goalSelector.addGoal(9, new LookAtPlayerGoal(this, Player.class, 15.0F, 1.0F));
         this.goalSelector.addGoal(10, new LookAtPlayerGoal(this, Mob.class, 15.0F));
-        this.targetSelector.addGoal(1, (new HurtByTargetGoal(this, Raider.class)).setAlertOthers());
+        this.targetSelector.addGoal(1, (new HurtByTargetGoal(this, new Class[]{Raider.class})).setAlertOthers(new Class[0])); // CraftBukkit - decompile error
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, IronGolem.class, true));
     }
 
     public static AttributeSupplier.Builder createAttributes() {
-        return Monster.createMonsterAttributes().add(Attributes.MOVEMENT_SPEED, (double)0.35F).add(Attributes.MAX_HEALTH, 24.0D).add(Attributes.ATTACK_DAMAGE, 5.0D).add(Attributes.FOLLOW_RANGE, 32.0D);
+        return Monster.createMonsterAttributes().add(Attributes.MOVEMENT_SPEED, 0.3499999940395355D).add(Attributes.MAX_HEALTH, 24.0D).add(Attributes.ATTACK_DAMAGE, 5.0D).add(Attributes.FOLLOW_RANGE, 32.0D);
     }
 
+    @Override
     protected void defineSynchedData() {
         super.defineSynchedData();
-        this.entityData.define(IS_CHARGING_CROSSBOW, false);
+        this.entityData.define(Pillager.IS_CHARGING_CROSSBOW, false);
     }
 
+    @Override
     public boolean canFireProjectileWeapon(ProjectileWeaponItem weapon) {
         return weapon == Items.CROSSBOW;
     }
 
     public boolean isChargingCrossbow() {
-        return this.entityData.get(IS_CHARGING_CROSSBOW);
+        return (Boolean) this.entityData.get(Pillager.IS_CHARGING_CROSSBOW);
     }
 
+    @Override
     public void setChargingCrossbow(boolean charging) {
-        this.entityData.set(IS_CHARGING_CROSSBOW, charging);
+        this.entityData.set(Pillager.IS_CHARGING_CROSSBOW, charging);
     }
 
+    @Override
     public void onCrossbowAttackPerformed() {
         this.noActionTime = 0;
     }
 
+    @Override
     public void addAdditionalSaveData(CompoundTag nbt) {
         super.addAdditionalSaveData(nbt);
-        ListTag listTag = new ListTag();
+        ListTag nbttaglist = new ListTag();
 
-        for(int i = 0; i < this.inventory.getContainerSize(); ++i) {
-            ItemStack itemStack = this.inventory.getItem(i);
-            if (!itemStack.isEmpty()) {
-                listTag.add(itemStack.save(new CompoundTag()));
+        for (int i = 0; i < this.inventory.getContainerSize(); ++i) {
+            ItemStack itemstack = this.inventory.getItem(i);
+
+            if (!itemstack.isEmpty()) {
+                nbttaglist.add(itemstack.save(new CompoundTag()));
             }
         }
 
-        nbt.put("Inventory", listTag);
+        nbt.put("Inventory", nbttaglist);
     }
 
+    @Override
     public AbstractIllager.IllagerArmPose getArmPose() {
-        if (this.isChargingCrossbow()) {
-            return AbstractIllager.IllagerArmPose.CROSSBOW_CHARGE;
-        } else if (this.isHolding(Items.CROSSBOW)) {
-            return AbstractIllager.IllagerArmPose.CROSSBOW_HOLD;
-        } else {
-            return this.isAggressive() ? AbstractIllager.IllagerArmPose.ATTACKING : AbstractIllager.IllagerArmPose.NEUTRAL;
-        }
+        return this.isChargingCrossbow() ? AbstractIllager.IllagerArmPose.CROSSBOW_CHARGE : (this.isHolding(Items.CROSSBOW) ? AbstractIllager.IllagerArmPose.CROSSBOW_HOLD : (this.isAggressive() ? AbstractIllager.IllagerArmPose.ATTACKING : AbstractIllager.IllagerArmPose.NEUTRAL));
     }
 
+    @Override
     public void readAdditionalSaveData(CompoundTag nbt) {
         super.readAdditionalSaveData(nbt);
-        ListTag listTag = nbt.getList("Inventory", 10);
+        ListTag nbttaglist = nbt.getList("Inventory", 10);
 
-        for(int i = 0; i < listTag.size(); ++i) {
-            ItemStack itemStack = ItemStack.of(listTag.getCompound(i));
-            if (!itemStack.isEmpty()) {
-                this.inventory.addItem(itemStack);
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            ItemStack itemstack = ItemStack.of(nbttaglist.getCompound(i));
+
+            if (!itemstack.isEmpty()) {
+                this.inventory.addItem(itemstack);
             }
         }
 
         this.setCanPickUpLoot(true);
     }
 
+    @Override
     public float getWalkTargetValue(BlockPos pos, LevelReader world) {
-        BlockState blockState = world.getBlockState(pos.below());
-        return !blockState.is(Blocks.GRASS_BLOCK) && !blockState.is(Blocks.SAND) ? 0.5F - world.getBrightness(pos) : 10.0F;
+        BlockState iblockdata = world.getBlockState(pos.below());
+
+        return !iblockdata.is(Blocks.GRASS_BLOCK) && !iblockdata.is(Blocks.SAND) ? 0.5F - world.getBrightness(pos) : 10.0F;
     }
 
+    @Override
     public int getMaxSpawnClusterSize() {
         return 1;
     }
 
     @Nullable
+    @Override
     public SpawnGroupData finalizeSpawn(ServerLevelAccessor world, DifficultyInstance difficulty, MobSpawnType spawnReason, @Nullable SpawnGroupData entityData, @Nullable CompoundTag entityNbt) {
         this.populateDefaultEquipmentSlots(difficulty);
         this.populateDefaultEquipmentEnchantments(difficulty);
         return super.finalizeSpawn(world, difficulty, spawnReason, entityData, entityNbt);
     }
 
+    @Override
     protected void populateDefaultEquipmentSlots(DifficultyInstance difficulty) {
         this.setItemSlot(EquipmentSlot.MAINHAND, new ItemStack(Items.CROSSBOW));
     }
 
+    @Override
     protected void enchantSpawnedWeapon(float power) {
         super.enchantSpawnedWeapon(power);
         if (this.random.nextInt(300) == 0) {
-            ItemStack itemStack = this.getMainHandItem();
-            if (itemStack.is(Items.CROSSBOW)) {
-                Map<Enchantment, Integer> map = EnchantmentHelper.getEnchantments(itemStack);
+            ItemStack itemstack = this.getMainHandItem();
+
+            if (itemstack.is(Items.CROSSBOW)) {
+                Map<Enchantment, Integer> map = EnchantmentHelper.getEnchantments(itemstack);
+
                 map.putIfAbsent(Enchantments.PIERCING, 1);
-                EnchantmentHelper.setEnchantments(map, itemStack);
-                this.setItemSlot(EquipmentSlot.MAINHAND, itemStack);
+                EnchantmentHelper.setEnchantments(map, itemstack);
+                this.setItemSlot(EquipmentSlot.MAINHAND, itemstack);
             }
         }
 
     }
 
+    @Override
     public boolean isAlliedTo(Entity other) {
-        if (super.isAlliedTo(other)) {
-            return true;
-        } else if (other instanceof LivingEntity && ((LivingEntity)other).getMobType() == MobType.ILLAGER) {
-            return this.getTeam() == null && other.getTeam() == null;
-        } else {
-            return false;
-        }
+        return super.isAlliedTo(other) ? true : (other instanceof LivingEntity && ((LivingEntity) other).getMobType() == MobType.ILLAGER ? this.getTeam() == null && other.getTeam() == null : false);
     }
 
+    @Override
     protected SoundEvent getAmbientSound() {
         return SoundEvents.PILLAGER_AMBIENT;
     }
 
+    @Override
     protected SoundEvent getDeathSound() {
         return SoundEvents.PILLAGER_DEATH;
     }
 
+    @Override
     protected SoundEvent getHurtSound(DamageSource source) {
         return SoundEvents.PILLAGER_HURT;
     }
 
+    @Override
     public void performRangedAttack(LivingEntity target, float pullProgress) {
         this.performCrossbowAttack(this, 1.6F);
     }
 
+    @Override
     public void shootCrossbowProjectile(LivingEntity target, ItemStack crossbow, Projectile projectile, float multiShotSpray) {
         this.shootCrossbowProjectile(this, target, projectile, multiShotSpray, 1.6F);
     }
 
+    @Override
     public Container getInventory() {
         return this.inventory;
     }
 
+    @Override
     protected void pickUpItem(ItemEntity item) {
-        ItemStack itemStack = item.getItem();
-        if (itemStack.getItem() instanceof BannerItem) {
+        ItemStack itemstack = item.getItem();
+
+        if (itemstack.getItem() instanceof BannerItem) {
             super.pickUpItem(item);
-        } else if (this.wantsItem(itemStack)) {
+        } else if (this.wantsItem(itemstack)) {
             this.onItemPickup(item);
-            ItemStack itemStack2 = this.inventory.addItem(itemStack);
-            if (itemStack2.isEmpty()) {
+            ItemStack itemstack1 = this.inventory.addItem(itemstack);
+
+            if (itemstack1.isEmpty()) {
                 item.discard();
             } else {
-                itemStack.setCount(itemStack2.getCount());
+                itemstack.setCount(itemstack1.getCount());
             }
         }
 
@@ -230,17 +247,22 @@
         return this.hasActiveRaid() && stack.is(Items.WHITE_BANNER);
     }
 
+    @Override
     public SlotAccess getSlot(int mappedIndex) {
-        int i = mappedIndex - 300;
-        return i >= 0 && i < this.inventory.getContainerSize() ? SlotAccess.forContainer(this.inventory, i) : super.getSlot(mappedIndex);
+        int j = mappedIndex - 300;
+
+        return j >= 0 && j < this.inventory.getContainerSize() ? SlotAccess.forContainer(this.inventory, j) : super.getSlot(mappedIndex);
     }
 
+    @Override
     public void applyRaidBuffs(int wave, boolean unused) {
         Raid raid = this.getCurrentRaid();
-        boolean bl = this.random.nextFloat() <= raid.getEnchantOdds();
-        if (bl) {
-            ItemStack itemStack = new ItemStack(Items.CROSSBOW);
+        boolean flag1 = this.random.nextFloat() <= raid.getEnchantOdds();
+
+        if (flag1) {
+            ItemStack itemstack = new ItemStack(Items.CROSSBOW);
             Map<Enchantment, Integer> map = Maps.newHashMap();
+
             if (wave > raid.getNumGroups(Difficulty.NORMAL)) {
                 map.put(Enchantments.QUICK_CHARGE, 2);
             } else if (wave > raid.getNumGroups(Difficulty.EASY)) {
@@ -248,12 +270,13 @@
             }
 
             map.put(Enchantments.MULTISHOT, 1);
-            EnchantmentHelper.setEnchantments(map, itemStack);
-            this.setItemSlot(EquipmentSlot.MAINHAND, itemStack);
+            EnchantmentHelper.setEnchantments((Map) map, itemstack);
+            this.setItemSlot(EquipmentSlot.MAINHAND, itemstack);
         }
 
     }
 
+    @Override
     public SoundEvent getCelebrateSound() {
         return SoundEvents.PILLAGER_CELEBRATE;
     }
