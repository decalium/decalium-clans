--- a/net/minecraft/world/level/dimension/end/EndDragonFight.java
+++ b/net/minecraft/world/level/dimension/end/EndDragonFight.java
@@ -66,8 +66,8 @@
     private static final int GATEWAY_DISTANCE = 96;
     public static final int DRAGON_SPAWN_Y = 128;
     private static final Predicate<Entity> VALID_PLAYER = EntitySelector.ENTITY_STILL_ALIVE.and(EntitySelector.withinDistance(0.0D, 128.0D, 0.0D, 192.0D));
-    private final ServerBossEvent dragonEvent = (ServerBossEvent)(new ServerBossEvent(new TranslatableComponent("entity.minecraft.ender_dragon"), BossEvent.BossBarColor.PINK, BossEvent.BossBarOverlay.PROGRESS)).setPlayBossMusic(true).setCreateWorldFog(true);
-    private final ServerLevel level;
+    public final ServerBossEvent dragonEvent = (ServerBossEvent)(new ServerBossEvent(new TranslatableComponent("entity.minecraft.ender_dragon"), BossEvent.BossBarColor.PINK, BossEvent.BossBarOverlay.PROGRESS)).setPlayBossMusic(true).setCreateWorldFog(true);
+    public final ServerLevel level;
     private final List<Integer> gateways = Lists.newArrayList();
     private final BlockPattern exitPortalPattern;
     private int ticksSinceDragonSeen;
@@ -76,14 +76,18 @@
     private int ticksSinceLastPlayerScan;
     private boolean dragonKilled;
     private boolean previouslyKilled;
-    private UUID dragonUUID;
+    public UUID dragonUUID;
     private boolean needsStateScanning = true;
-    private BlockPos portalLocation;
-    private DragonRespawnAnimation respawnStage;
+    public BlockPos portalLocation;
+    public DragonRespawnAnimation respawnStage;
     private int respawnTime;
     private List<EndCrystal> respawnCrystals;
 
     public EndDragonFight(ServerLevel world, long gatewaysSeed, CompoundTag nbt) {
+        // Paper start
+        this.needsStateScanning = world.paperConfig.scanForLegacyEnderDragon;
+        if (!this.needsStateScanning) this.dragonKilled = true;
+        // Paper end
         this.level = world;
         if (nbt.contains("NeedsStateScanning")) {
             this.needsStateScanning = nbt.getBoolean("NeedsStateScanning");
@@ -208,7 +212,7 @@
             this.dragonUUID = enderDragon.getUUID();
             LOGGER.info("Found that there's a dragon still alive ({})", (Object)enderDragon);
             this.dragonKilled = false;
-            if (!bl) {
+            if (!bl && this.level.paperConfig.shouldRemoveDragon) {
                 LOGGER.info("But we didn't have a portal, let's remove it.");
                 enderDragon.discard();
                 this.dragonUUID = null;
@@ -233,7 +237,7 @@
 
     }
 
-    protected void setRespawnStage(DragonRespawnAnimation spawnState) {
+    public void setRespawnStage(DragonRespawnAnimation spawnState) {
         if (this.respawnStage == null) {
             throw new IllegalStateException("Dragon respawn isn't in progress, can't skip ahead in the animation.");
         } else {
@@ -270,7 +274,7 @@
     }
 
     @Nullable
-    private BlockPattern.BlockPatternMatch findExitPortal() {
+    public BlockPattern.BlockPatternMatch findExitPortal() {
         for(int i = -8; i <= 8; ++i) {
             for(int j = -8; j <= 8; ++j) {
                 LevelChunk levelChunk = this.level.getChunk(i, j);
@@ -359,9 +363,24 @@
             this.dragonEvent.setVisible(false);
             this.spawnExitPortal(true);
             this.spawnNewGateway();
-            if (!this.previouslyKilled) {
-                this.level.setBlockAndUpdate(this.level.getHeightmapPos(Heightmap.Types.MOTION_BLOCKING, EndPodiumFeature.END_PODIUM_LOCATION), Blocks.DRAGON_EGG.defaultBlockState());
+            // Paper start - DragonEggFormEvent
+            BlockPos eggPosition = this.level.getHeightmapPos(Heightmap.Types.MOTION_BLOCKING, EndPodiumFeature.END_PODIUM_LOCATION);
+            org.bukkit.craftbukkit.v1_17_R1.block.CraftBlock eggBlock = org.bukkit.craftbukkit.v1_17_R1.block.CraftBlock.at(this.level, eggPosition);
+            org.bukkit.craftbukkit.v1_17_R1.block.CraftBlockState eggState = new org.bukkit.craftbukkit.v1_17_R1.block.CraftBlockState(eggBlock);
+            eggState.setData(Blocks.DRAGON_EGG.defaultBlockState());
+            io.papermc.paper.event.block.DragonEggFormEvent eggEvent = new io.papermc.paper.event.block.DragonEggFormEvent(eggBlock, eggState,
+                    new org.bukkit.craftbukkit.v1_17_R1.boss.CraftDragonBattle(this));
+            // Paper end - DragonEggFormEvent
+            if (this.level.paperConfig.enderDragonsDeathAlwaysPlacesDragonEgg || !this.previouslyKilled) { // Paper - always place dragon egg
+                // Paper start - DragonEggFormEvent
+                //this.world.setTypeUpdate(this.world.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING, WorldGenEndTrophy.a), Blocks.DRAGON_EGG.getBlockData());
+            } else {
+                eggEvent.setCancelled(true);
+            }
+            if (eggEvent.callEvent()) {
+                eggEvent.getNewState().update(true);
             }
+            // Paper end - DragonEggFormEvent
 
             this.previouslyKilled = true;
             this.dragonKilled = true;
@@ -383,7 +402,7 @@
         Features.END_GATEWAY_DELAYED.place(this.level, this.level.getChunkSource().getGenerator(), new Random(), pos);
     }
 
-    private void spawnExitPortal(boolean previouslyKilled) {
+    public void spawnExitPortal(boolean previouslyKilled) {
         EndPodiumFeature endPodiumFeature = new EndPodiumFeature(previouslyKilled);
         if (this.portalLocation == null) {
             for(this.portalLocation = this.level.getHeightmapPos(Heightmap.Types.MOTION_BLOCKING_NO_LEAVES, EndPodiumFeature.END_PODIUM_LOCATION).below(); this.level.getBlockState(this.portalLocation).is(Blocks.BEDROCK) && this.portalLocation.getY() > this.level.getSeaLevel(); this.portalLocation = this.portalLocation.below()) {
@@ -400,6 +419,7 @@
         enderDragon.moveTo(0.0D, 128.0D, 0.0D, this.level.random.nextFloat() * 360.0F, 0.0F);
         this.level.addFreshEntity(enderDragon);
         this.dragonUUID = enderDragon.getUUID();
+        this.resetSpikeCrystals(); // Paper
         return enderDragon;
     }
 
