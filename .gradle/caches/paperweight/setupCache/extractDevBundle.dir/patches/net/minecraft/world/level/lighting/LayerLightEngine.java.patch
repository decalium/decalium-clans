--- a/net/minecraft/world/level/lighting/LayerLightEngine.java
+++ b/net/minecraft/world/level/lighting/LayerLightEngine.java
@@ -10,11 +10,12 @@
 import net.minecraft.world.level.LightLayer;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.DataLayer;
 import net.minecraft.world.level.chunk.LightChunkGetter;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
-import org.apache.commons.lang3.mutable.MutableInt;
+import org.bukkit.craftbukkit.libs.org.apache.commons.lang3.mutable.MutableInt;
 
 public abstract class LayerLightEngine<M extends DataLayerStorageMap<M>, S extends LayerLightSectionStorage<M>> extends DynamicGraphMinFixedPoint implements LayerLightEventListener {
     public static final long SELF_SOURCE = Long.MAX_VALUE;
@@ -26,8 +27,35 @@
     protected final BlockPos.MutableBlockPos pos = new BlockPos.MutableBlockPos();
     private static final int CACHE_SIZE = 2;
     private final long[] lastChunkPos = new long[2];
-    private final BlockGetter[] lastChunk = new BlockGetter[2];
+    private final ChunkAccess[] lastChunk = new ChunkAccess[2]; // Paper
 
+    // Paper start - see fully commented out method below (look for Bedrock)
+    // optimized method with less branching for when scenarios arent needed.
+    // avoid using mutable version if can
+    protected final BlockState getBlockOptimized(int x, int y, int z, MutableInt mutableint) {
+        ChunkAccess iblockaccess = this.getChunk(x >> 4, z >> 4);
+
+        if (iblockaccess == null) {
+            mutableint.setValue(16);
+            return Blocks.BEDROCK.defaultBlockState();
+        } else {
+            this.pos.set(x, y, z);
+            BlockState iblockdata = iblockaccess.getType(x, y, z);
+            mutableint.setValue(iblockdata.getLightBlock(this.chunkSource.getLevel(), this.pos));
+            return iblockdata.canOcclude() && iblockdata.useShapeForLightOcclusion() ? iblockdata : Blocks.AIR.defaultBlockState();
+        }
+    }
+    protected final BlockState getBlockOptimized(int x, int y, int z) {
+        ChunkAccess iblockaccess = this.getChunk(x >> 4, z >> 4);
+
+        if (iblockaccess == null) {
+            return Blocks.BEDROCK.defaultBlockState();
+        } else {
+            BlockState iblockdata = iblockaccess.getType(x, y, z);
+            return iblockdata.canOcclude() && iblockdata.useShapeForLightOcclusion() ? iblockdata : Blocks.AIR.defaultBlockState();
+        }
+    }
+    // Paper end
     public LayerLightEngine(LightChunkGetter chunkProvider, LightLayer type, S lightStorage) {
         super(16, 256, 8192);
         this.chunkSource = chunkProvider;
@@ -36,6 +64,7 @@
         this.clearCache();
     }
 
+    @Override
     protected void checkNode(long id) {
         this.storage.runAllUpdates();
         if (this.storage.storingLightForSection(SectionPos.blockToSection(id))) {
@@ -45,7 +74,7 @@
     }
 
     @Nullable
-    private BlockGetter getChunk(int chunkX, int chunkZ) {
+    private ChunkAccess getChunk(int chunkX, int chunkZ) { // Paper
         long l = ChunkPos.asLong(chunkX, chunkZ);
 
         for(int i = 0; i < 2; ++i) {
@@ -54,7 +83,7 @@
             }
         }
 
-        BlockGetter blockGetter = this.chunkSource.getChunkForLighting(chunkX, chunkZ);
+        ChunkAccess blockGetter = (ChunkAccess) this.chunkSource.getChunkForLighting(chunkX, chunkZ); // Paper
 
         for(int j = 1; j > 0; --j) {
             this.lastChunkPos[j] = this.lastChunkPos[j - 1];
@@ -71,35 +100,37 @@
         Arrays.fill(this.lastChunk, (Object)null);
     }
 
-    protected BlockState getStateAndOpacity(long pos, @Nullable MutableInt mutableInt) {
-        if (pos == Long.MAX_VALUE) {
-            if (mutableInt != null) {
-                mutableInt.setValue(0);
-            }
-
-            return Blocks.AIR.defaultBlockState();
-        } else {
-            int i = SectionPos.blockToSectionCoord(BlockPos.getX(pos));
-            int j = SectionPos.blockToSectionCoord(BlockPos.getZ(pos));
-            BlockGetter blockGetter = this.getChunk(i, j);
-            if (blockGetter == null) {
-                if (mutableInt != null) {
-                    mutableInt.setValue(16);
-                }
-
-                return Blocks.BEDROCK.defaultBlockState();
-            } else {
-                this.pos.set(pos);
-                BlockState blockState = blockGetter.getBlockState(this.pos);
-                boolean bl = blockState.canOcclude() && blockState.useShapeForLightOcclusion();
-                if (mutableInt != null) {
-                    mutableInt.setValue(blockState.getLightBlock(this.chunkSource.getLevel(), this.pos));
-                }
-
-                return bl ? blockState : Blocks.AIR.defaultBlockState();
-            }
-        }
-    }
+    // Paper start - comment out, see getBlockOptimized
+    // protected BlockState getStateAndOpacity(long pos, @Nullable MutableInt mutableInt) {
+    //     if (pos == Long.MAX_VALUE) {
+    //         if (mutableInt != null) {
+    //             mutableInt.setValue(0);
+    //         }
+    //
+    //         return Blocks.AIR.defaultBlockState();
+    //     } else {
+    //         int i = SectionPos.blockToSectionCoord(BlockPos.getX(pos));
+    //         int j = SectionPos.blockToSectionCoord(BlockPos.getZ(pos));
+    //         BlockGetter blockGetter = this.getChunk(i, j);
+    //         if (blockGetter == null) {
+    //             if (mutableInt != null) {
+    //                 mutableInt.setValue(16);
+    //             }
+    //
+    //             return Blocks.BEDROCK.defaultBlockState();
+    //         } else {
+    //             this.pos.set(pos);
+    //             BlockState blockState = blockGetter.getBlockState(this.pos);
+    //             boolean bl = blockState.canOcclude() && blockState.useShapeForLightOcclusion();
+    //             if (mutableInt != null) {
+    //                 mutableInt.setValue(blockState.getLightBlock(this.chunkSource.getLevel(), this.pos));
+    //             }
+    //
+    //             return bl ? blockState : Blocks.AIR.defaultBlockState();
+    //         }
+    //     }
+    // }
+    // Paper end
 
     protected VoxelShape getShape(BlockState world, long pos, Direction facing) {
         return world.canOcclude() ? world.getFaceOcclusionShape(this.chunkSource.getLevel(), this.pos.set(pos), facing) : Shapes.empty();
@@ -117,34 +148,42 @@
         }
     }
 
+    @Override
     protected boolean isSource(long id) {
         return id == Long.MAX_VALUE;
     }
 
+    @Override
     protected int getComputedLevel(long id, long excludedId, int maxLevel) {
         return 0;
     }
 
+    @Override
     protected int getLevel(long id) {
         return id == Long.MAX_VALUE ? 0 : 15 - this.storage.getStoredLevel(id);
     }
 
+    protected int getLevel(DataLayer section, int x, int y, int z) { return 15 - section.get(x & 15, y & 15, z & 15); } // Paper - x/y/z version of below
     protected int getLevel(DataLayer section, long blockPos) {
-        return 15 - section.get(SectionPos.sectionRelative(BlockPos.getX(blockPos)), SectionPos.sectionRelative(BlockPos.getY(blockPos)), SectionPos.sectionRelative(BlockPos.getZ(blockPos)));
+        return 15 - section.get((int) (blockPos >> 38) & 15, (int) ((blockPos << 52) >> 52) & 15, (int) ((blockPos << 26) >> 38) & 15); // Paper
     }
 
+    @Override
     protected void setLevel(long id, int level) {
         this.storage.setStoredLevel(id, Math.min(15, 15 - level));
     }
 
+    @Override
     protected int computeLevelFromNeighbor(long sourceId, long targetId, int level) {
         return 0;
     }
 
+    @Override
     public boolean hasLightWork() {
         return this.hasWork() || this.storage.hasWork() || this.storage.hasInconsistencies();
     }
 
+    @Override
     public int runUpdates(int i, boolean bl, boolean bl2) {
         if (!this.runningLightUpdates) {
             if (this.storage.hasWork()) {
@@ -176,10 +215,12 @@
     }
 
     @Nullable
+    @Override
     public DataLayer getDataLayerData(SectionPos pos) {
         return this.storage.getDataLayerData(pos.asLong());
     }
 
+    @Override
     public int getLightValue(BlockPos pos) {
         return this.storage.getLightValue(pos.asLong());
     }
@@ -188,6 +229,7 @@
         return "" + this.storage.getLevel(sectionPos);
     }
 
+    @Override
     public void checkBlock(BlockPos pos) {
         long l = pos.asLong();
         this.checkNode(l);
@@ -198,13 +240,16 @@
 
     }
 
+    @Override
     public void onBlockEmissionIncrease(BlockPos pos, int level) {
     }
 
+    @Override
     public void updateSectionStatus(SectionPos pos, boolean notReady) {
         this.storage.updateSectionStatus(pos.asLong(), notReady);
     }
 
+    @Override
     public void enableLightSources(ChunkPos chunkPos, boolean bl) {
         long l = SectionPos.getZeroNode(SectionPos.asLong(chunkPos.x, 0, chunkPos.z));
         this.storage.enableLightSources(l, bl);
