--- a/net/minecraft/util/datafix/fixes/ChunkToProtochunkFix.java
+++ b/net/minecraft/util/datafix/fixes/ChunkToProtochunkFix.java
@@ -25,6 +25,7 @@
         super(outputSchema, changesType);
     }
 
+    @Override
     public TypeRewriteRule makeRule() {
         Type<?> type = this.getInputSchema().getType(References.CHUNK);
         Type<?> type2 = this.getOutputSchema().getType(References.CHUNK);
@@ -35,17 +36,26 @@
         OpticFinder<?> opticFinder2 = DSL.fieldFinder("TileTicks", type5);
         return TypeRewriteRule.seq(this.fixTypeEverywhereTyped("ChunkToProtoChunkFix", type, this.getOutputSchema().getType(References.CHUNK), (typed) -> {
             return typed.updateTyped(opticFinder, type4, (typedx) -> {
-                Optional<? extends Stream<? extends Dynamic<?>>> optional = typedx.getOptionalTyped(opticFinder2).flatMap((typed) -> {
-                    return typed.write().result();
+                Optional<? extends Stream<? extends Dynamic<?>>> optional = typedx.getOptionalTyped(opticFinder2).flatMap((it) -> { // Paper - remap fix
+                    return it.write().result(); // Paper - remap fix
                 }).flatMap((dynamicx) -> {
                     return dynamicx.asStreamOpt().result();
                 });
                 Dynamic<?> dynamic = typedx.get(DSL.remainderFinder());
-                boolean bl = dynamic.get("TerrainPopulated").asBoolean(false) && (!dynamic.get("LightPopulated").asNumber().result().isPresent() || dynamic.get("LightPopulated").asBoolean(false));
-                dynamic = dynamic.set("Status", dynamic.createString(bl ? "mobs_spawned" : "empty"));
+                // Paper start - fix incorrect status conversion
+                // Vanilla is setting chunks to incorrect status here, they should be using at minimum carved.
+                // for populated chunks, it should be at minimum decorated
+                // and for lit and populated, mobs_spawned is correct (technically mobs_spawned should be for populated,
+                // but if it's not lit then it can't be set above lit)
+                final boolean terrainPopulated = dynamic.get("TerrainPopulated").asBoolean(false);
+                final boolean lightPopulated = dynamic.get("LightPopulated").asBoolean(false) || dynamic.get("LightPopulated").asNumber().result().isPresent();
+                final String newStatus = !terrainPopulated ? "carved" : (lightPopulated ? "mobs_spawned" : "decorated");
+
+                dynamic = dynamic.set("Status", dynamic.createString(newStatus));
+                // Paper end - fix incorrect status conversion
                 dynamic = dynamic.set("hasLegacyStructureData", dynamic.createBoolean(true));
                 Dynamic<?> dynamic3;
-                if (bl) {
+                if (true) { // Paper - fix incorrect status conversion
                     Optional<ByteBuffer> optional2 = dynamic.get("Biomes").asByteBufferOpt().result();
                     if (optional2.isPresent()) {
                         ByteBuffer byteBuffer = optional2.get();
