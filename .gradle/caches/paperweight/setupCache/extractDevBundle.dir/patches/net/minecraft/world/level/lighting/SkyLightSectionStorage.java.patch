--- a/net/minecraft/world/level/lighting/SkyLightSectionStorage.java
+++ b/net/minecraft/world/level/lighting/SkyLightSectionStorage.java
@@ -21,18 +21,25 @@
     private volatile boolean hasSourceInconsistencies;
 
     protected SkyLightSectionStorage(LightChunkGetter chunkProvider) {
-        super(LightLayer.SKY, chunkProvider, new SkyLightSectionStorage.SkyDataLayerStorageMap(new Long2ObjectOpenHashMap<>(), new Long2IntOpenHashMap(), Integer.MAX_VALUE));
+        super(LightLayer.SKY, chunkProvider, new SkyLightSectionStorage.SkyDataLayerStorageMap(new com.destroystokyo.paper.util.map.QueuedChangesMapLong2Object<>(), new com.destroystokyo.paper.util.map.QueuedChangesMapLong2Int(), Integer.MAX_VALUE, false)); // Paper - avoid copying light data
     }
 
+    @Override
     protected int getLightValue(long blockPos) {
         return this.getLightValue(blockPos, false);
     }
 
     protected int getLightValue(long l, boolean bl) {
-        long m = SectionPos.blockToSection(l);
+        // Paper start
+        int baseX = (int) (l >> 38);
+        int baseY = (int) ((l << 52) >> 52);
+        int baseZ = (int) ((l << 26) >> 38);
+        long m = SectionPos.blockPosAsSectionLong(baseX, baseY, baseZ);
+        // Paper end
         int i = SectionPos.y(m);
-        SkyLightSectionStorage.SkyDataLayerStorageMap skyDataLayerStorageMap = bl ? this.updatingSectionData : this.visibleSectionData;
-        int j = skyDataLayerStorageMap.topSections.get(SectionPos.getZeroNode(m));
+        synchronized (this.visibleUpdateLock) { // Paper - avoid copying light data
+        SkyLightSectionStorage.SkyDataLayerStorageMap skyDataLayerStorageMap = (SkyLightSectionStorage.SkyDataLayerStorageMap) this.e_visible; // Paper - avoid copying light data - must be after lock acquire
+        int j = skyDataLayerStorageMap.otherData.getVisibleAsync(SectionPos.getZeroNode(m)); // Paper - avoid copying light data
         if (j != skyDataLayerStorageMap.currentLowestY && i < j) {
             DataLayer dataLayer = this.getDataLayer(skyDataLayerStorageMap, m);
             if (dataLayer == null) {
@@ -47,23 +54,25 @@
                 }
             }
 
-            return dataLayer.get(SectionPos.sectionRelative(BlockPos.getX(l)), SectionPos.sectionRelative(BlockPos.getY(l)), SectionPos.sectionRelative(BlockPos.getZ(l)));
+            return dataLayer.get(baseX & 15, (int) ((l << 52) >> 52) & 15, (int) baseZ & 15);
         } else {
             return bl && !this.lightOnInSection(m) ? 0 : 15;
         }
+        } // Paper - avoid copying light data
     }
 
+    @Override
     protected void onNodeAdded(long sectionPos) {
         int i = SectionPos.y(sectionPos);
         if ((this.updatingSectionData).currentLowestY > i) {
             (this.updatingSectionData).currentLowestY = i;
-            (this.updatingSectionData).topSections.defaultReturnValue((this.updatingSectionData).currentLowestY);
+            (this.updatingSectionData).otherData.queueDefaultReturnValue((this.updatingSectionData).currentLowestY); // Paper - avoid copying light data
         }
 
         long l = SectionPos.getZeroNode(sectionPos);
-        int j = (this.updatingSectionData).topSections.get(l);
+        int j = (this.updatingSectionData).otherData.getUpdating(l); // Paper - avoid copying light data
         if (j < i + 1) {
-            (this.updatingSectionData).topSections.put(l, i + 1);
+            (this.updatingSectionData).otherData.queueUpdate(l, i + 1); // Paper - avoid copying light data
             if (this.columnsWithSkySources.contains(l)) {
                 this.queueAddSource(sectionPos);
                 if (j > (this.updatingSectionData).currentLowestY) {
@@ -91,6 +100,7 @@
         this.hasSourceInconsistencies = !this.sectionsToAddSourcesTo.isEmpty() || !this.sectionsToRemoveSourcesFrom.isEmpty();
     }
 
+    @Override
     protected void onNodeRemoved(long sectionPos) {
         long l = SectionPos.getZeroNode(sectionPos);
         boolean bl = this.columnsWithSkySources.contains(l);
@@ -99,19 +109,19 @@
         }
 
         int i = SectionPos.y(sectionPos);
-        if ((this.updatingSectionData).topSections.get(l) == i + 1) {
+        if ((this.updatingSectionData).otherData.getUpdating(l) == i + 1) { // Paper - avoid copying light data
             long m;
             for(m = sectionPos; !this.storingLightForSection(m) && this.hasSectionsBelow(i); m = SectionPos.offset(m, Direction.DOWN)) {
                 --i;
             }
 
             if (this.storingLightForSection(m)) {
-                (this.updatingSectionData).topSections.put(l, i + 1);
+                (this.updatingSectionData).otherData.queueUpdate(l, i + 1); // Paper - avoid copying light data
                 if (bl) {
                     this.queueAddSource(m);
                 }
             } else {
-                (this.updatingSectionData).topSections.remove(l);
+                (this.updatingSectionData).otherData.queueRemove(l); // Paper - avoid copying light data
             }
         }
 
@@ -121,10 +131,11 @@
 
     }
 
+    @Override
     protected void enableLightSources(long columnPos, boolean enabled) {
         this.runAllUpdates();
         if (enabled && this.columnsWithSkySources.add(columnPos)) {
-            int i = (this.updatingSectionData).topSections.get(columnPos);
+            int i = (this.updatingSectionData).otherData.getUpdating(columnPos); // Paper - avoid copying light data
             if (i != (this.updatingSectionData).currentLowestY) {
                 long l = SectionPos.asLong(SectionPos.x(columnPos), i - 1, SectionPos.z(columnPos));
                 this.queueAddSource(l);
@@ -136,33 +147,35 @@
 
     }
 
+    @Override
     protected boolean hasInconsistencies() {
         return super.hasInconsistencies() || this.hasSourceInconsistencies;
     }
 
+    @Override
     protected DataLayer createDataLayer(long sectionPos) {
         DataLayer dataLayer = this.queuedSections.get(sectionPos);
         if (dataLayer != null) {
             return dataLayer;
         } else {
             long l = SectionPos.offset(sectionPos, Direction.UP);
-            int i = (this.updatingSectionData).topSections.get(SectionPos.getZeroNode(sectionPos));
+            int i = (this.updatingSectionData).otherData.getUpdating(SectionPos.getZeroNode(sectionPos)); // Paper - avoid copying light data
             if (i != (this.updatingSectionData).currentLowestY && SectionPos.y(l) < i) {
                 DataLayer dataLayer2;
-                while((dataLayer2 = this.getDataLayer(l, true)) == null) {
+                while((dataLayer2 = this.updating.getUpdatingOptimized(l)) == null) { // Paper
                     l = SectionPos.offset(l, Direction.UP);
                 }
 
                 return repeatFirstLayer(dataLayer2);
             } else {
-                return new DataLayer();
+                return new DataLayer().markPoolSafe(); // Paper - mark pool use as safe (no auto cleaner)
             }
         }
     }
 
     private static DataLayer repeatFirstLayer(DataLayer source) {
         if (source.isEmpty()) {
-            return new DataLayer();
+            return new DataLayer().markPoolSafe(); // Paper - mark pool use as safe (no auto cleaner)
         } else {
             byte[] bs = source.getData();
             byte[] cs = new byte[2048];
@@ -171,15 +184,19 @@
                 System.arraycopy(bs, 0, cs, i * 128, 128);
             }
 
-            return new DataLayer(cs);
+            return new DataLayer(cs).markPoolSafe(cs); // Paper - mark pool use as safe (no auto cleaner)
         }
     }
 
+    @Override
     protected void markNewInconsistencies(LayerLightEngine<SkyLightSectionStorage.SkyDataLayerStorageMap, ?> lightProvider, boolean doSkylight, boolean skipEdgeLightPropagation) {
         super.markNewInconsistencies(lightProvider, doSkylight, skipEdgeLightPropagation);
         if (doSkylight) {
             if (!this.sectionsToAddSourcesTo.isEmpty()) {
                 for(long l : this.sectionsToAddSourcesTo) {
+                    int baseX = (int) (l >> 42) << 4; // Paper
+                    int baseY = (int) (l << 44 >> 44) << 4; // Paper
+                    int baseZ = (int) (l << 22 >> 42) << 4; // Paper
                     int i = this.getLevel(l);
                     if (i != 2 && !this.sectionsToRemoveSourcesFrom.contains(l) && this.sectionsWithSources.add(l)) {
                         if (i == 1) {
@@ -188,13 +205,15 @@
                                 this.updatingSectionData.copyDataLayer(l);
                             }
 
-                            Arrays.fill(this.getDataLayer(l, true).getData(), (byte)-1);
-                            int j = SectionPos.sectionToBlockCoord(SectionPos.x(l));
-                            int k = SectionPos.sectionToBlockCoord(SectionPos.y(l));
-                            int m = SectionPos.sectionToBlockCoord(SectionPos.z(l));
+                            // Paper start
+                            Arrays.fill(this.updating.getUpdatingOptimized(l).asBytesPoolSafe(), (byte)-1); // Paper - use optimized
+                            int j = baseX;
+                            int k = baseY;
+                            int m = baseZ;
+                            // Paper end
 
                             for(Direction direction : HORIZONTALS) {
-                                long n = SectionPos.offset(l, direction);
+                                long n = SectionPos.getAdjacentFromBlockPos(baseX, baseY, baseZ, direction); // Paper
                                 if ((this.sectionsToRemoveSourcesFrom.contains(n) || !this.sectionsWithSources.contains(n) && !this.sectionsToAddSourcesTo.contains(n)) && this.storingLightForSection(n)) {
                                     for(int o = 0; o < 16; ++o) {
                                         for(int p = 0; p < 16; ++p) {
@@ -226,15 +245,15 @@
 
                             for(int y = 0; y < 16; ++y) {
                                 for(int z = 0; z < 16; ++z) {
-                                    long aa = BlockPos.asLong(SectionPos.sectionToBlockCoord(SectionPos.x(l), y), SectionPos.sectionToBlockCoord(SectionPos.y(l)), SectionPos.sectionToBlockCoord(SectionPos.z(l), z));
-                                    long ab = BlockPos.asLong(SectionPos.sectionToBlockCoord(SectionPos.x(l), y), SectionPos.sectionToBlockCoord(SectionPos.y(l)) - 1, SectionPos.sectionToBlockCoord(SectionPos.z(l), z));
+                                    long aa = BlockPos.asLong(baseX + y, baseY, baseZ + z); // Paper
+                                    long ab = BlockPos.asLong(baseX + y, baseY - 1, baseZ + z); // Paper
                                     lightProvider.checkEdge(aa, ab, lightProvider.computeLevelFromNeighbor(aa, ab, 0), true);
                                 }
                             }
                         } else {
                             for(int ac = 0; ac < 16; ++ac) {
                                 for(int ad = 0; ad < 16; ++ad) {
-                                    long ae = BlockPos.asLong(SectionPos.sectionToBlockCoord(SectionPos.x(l), ac), SectionPos.sectionToBlockCoord(SectionPos.y(l), 15), SectionPos.sectionToBlockCoord(SectionPos.z(l), ad));
+                                    long ae = BlockPos.asLong(baseX + ac, baseY + 16 - 1, baseZ + ad); // Paper
                                     lightProvider.checkEdge(Long.MAX_VALUE, ae, 0, true);
                                 }
                             }
@@ -246,10 +265,13 @@
             this.sectionsToAddSourcesTo.clear();
             if (!this.sectionsToRemoveSourcesFrom.isEmpty()) {
                 for(long af : this.sectionsToRemoveSourcesFrom) {
+                    int baseX = (int) (af >> 42) << 4; // Paper
+                    int baseY = (int) (af << 44 >> 44) << 4; // Paper
+                    int baseZ = (int) (af << 22 >> 42) << 4; // Paper
                     if (this.sectionsWithSources.remove(af) && this.storingLightForSection(af)) {
                         for(int ag = 0; ag < 16; ++ag) {
                             for(int ah = 0; ah < 16; ++ah) {
-                                long ai = BlockPos.asLong(SectionPos.sectionToBlockCoord(SectionPos.x(af), ag), SectionPos.sectionToBlockCoord(SectionPos.y(af), 15), SectionPos.sectionToBlockCoord(SectionPos.z(af), ah));
+                                long ai = BlockPos.asLong(baseX + ag, baseY + 16 - 1, baseZ + ah); // Paper
                                 lightProvider.checkEdge(Long.MAX_VALUE, ai, 15, false);
                             }
                         }
@@ -268,7 +290,7 @@
 
     protected boolean isAboveData(long sectionPos) {
         long l = SectionPos.getZeroNode(sectionPos);
-        int i = (this.updatingSectionData).topSections.get(l);
+        int i = (this.updatingSectionData).otherData.getUpdating(l); // Paper - avoid copying light data
         return i == (this.updatingSectionData).currentLowestY || SectionPos.y(sectionPos) >= i;
     }
 
@@ -279,17 +301,21 @@
 
     protected static final class SkyDataLayerStorageMap extends DataLayerStorageMap<SkyLightSectionStorage.SkyDataLayerStorageMap> {
         int currentLowestY;
-        final Long2IntOpenHashMap topSections;
+        private final com.destroystokyo.paper.util.map.QueuedChangesMapLong2Int otherData; // Paper - avoid copying light data
 
-        public SkyDataLayerStorageMap(Long2ObjectOpenHashMap<DataLayer> arrays, Long2IntOpenHashMap columnToTopSection, int minSectionY) {
-            super(arrays);
-            this.topSections = columnToTopSection;
-            columnToTopSection.defaultReturnValue(minSectionY);
+        // Paper start - avoid copying light data
+        public SkyDataLayerStorageMap(com.destroystokyo.paper.util.map.QueuedChangesMapLong2Object<DataLayer> arrays, com.destroystokyo.paper.util.map.QueuedChangesMapLong2Int columnToTopSection, int minSectionY, boolean isVisible) {
+            super(arrays, isVisible);
+            this.otherData = columnToTopSection;
+            otherData.queueDefaultReturnValue(minSectionY);
+            // Paper end
             this.currentLowestY = minSectionY;
         }
 
+        @Override
         public SkyLightSectionStorage.SkyDataLayerStorageMap copy() {
-            return new SkyLightSectionStorage.SkyDataLayerStorageMap(this.map.clone(), this.topSections.clone(), this.currentLowestY);
+            this.otherData.performUpdatesLockMap(); // Paper - avoid copying light data
+            return new SkyLightSectionStorage.SkyDataLayerStorageMap(this.data, this.otherData, this.currentLowestY, true); // Paper - avoid copying light data
         }
     }
 }
