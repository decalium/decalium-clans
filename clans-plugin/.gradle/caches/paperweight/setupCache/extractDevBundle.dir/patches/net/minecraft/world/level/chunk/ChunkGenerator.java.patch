--- a/net/minecraft/world/level/chunk/ChunkGenerator.java
+++ b/net/minecraft/world/level/chunk/ChunkGenerator.java
@@ -2,25 +2,28 @@
 
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Lists;
+import com.google.common.collect.UnmodifiableIterator;
 import com.mojang.serialization.Codec;
 import it.unimi.dsi.fastutil.ints.IntArraySet;
-import it.unimi.dsi.fastutil.ints.IntSet;
 import it.unimi.dsi.fastutil.objects.ObjectArraySet;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Objects;
 import java.util.Optional;
 import java.util.Random;
 import java.util.Set;
-import java.util.Map.Entry;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
+import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
@@ -40,7 +43,6 @@
 import net.minecraft.world.entity.MobCategory;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.LevelHeightAccessor;
-import net.minecraft.world.level.NoiseColumn;
 import net.minecraft.world.level.StructureFeatureManager;
 import net.minecraft.world.level.WorldGenLevel;
 import net.minecraft.world.level.biome.Biome;
@@ -68,18 +70,20 @@
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
 
 public abstract class ChunkGenerator implements BiomeManager.NoiseBiomeSource {
-    public static final Codec<ChunkGenerator> CODEC = Registry.CHUNK_GENERATOR.byNameCodec().dispatchStable(ChunkGenerator::codec, Function.identity());
+
+    public static final Codec<ChunkGenerator> CODEC;
     protected final BiomeSource biomeSource;
     protected final BiomeSource runtimeBiomeSource;
     private final StructureSettings settings;
     public final long strongholdSeed;
-    private final List<ChunkPos> strongholdPositions = Lists.newArrayList();
+    private final List<ChunkPos> strongholdPositions;
 
     public ChunkGenerator(BiomeSource biomeSource, StructureSettings structuresConfig) {
         this(biomeSource, biomeSource, structuresConfig, 0L);
     }
 
     public ChunkGenerator(BiomeSource populationSource, BiomeSource biomeSource, StructureSettings structuresConfig, long worldSeed) {
+        this.strongholdPositions = Lists.newArrayList();
         this.biomeSource = populationSource;
         this.runtimeBiomeSource = biomeSource;
         this.settings = structuresConfig;
@@ -88,44 +92,55 @@
 
     private void generateStrongholds() {
         if (this.strongholdPositions.isEmpty()) {
-            StrongholdConfiguration strongholdConfiguration = this.settings.stronghold();
-            if (strongholdConfiguration != null && strongholdConfiguration.count() != 0) {
+            StrongholdConfiguration structuresettingsstronghold = this.settings.stronghold();
+
+            if (structuresettingsstronghold != null && structuresettingsstronghold.count() != 0) {
                 List<Biome> list = Lists.newArrayList();
+                Iterator iterator = this.biomeSource.possibleBiomes().iterator();
 
-                for(Biome biome : this.biomeSource.possibleBiomes()) {
-                    if (validStrongholdBiome(biome)) {
-                        list.add(biome);
+                while (iterator.hasNext()) {
+                    Biome biomebase = (Biome) iterator.next();
+
+                    if (ChunkGenerator.validStrongholdBiome(biomebase)) {
+                        list.add(biomebase);
                     }
                 }
 
-                int i = strongholdConfiguration.distance();
-                int j = strongholdConfiguration.count();
-                int k = strongholdConfiguration.spread();
+                int i = structuresettingsstronghold.distance();
+                int j = structuresettingsstronghold.count();
+                int k = structuresettingsstronghold.spread();
                 Random random = new Random();
+
                 random.setSeed(this.strongholdSeed);
-                double d = random.nextDouble() * Math.PI * 2.0D;
+                double d0 = random.nextDouble() * 3.141592653589793D * 2.0D;
                 int l = 0;
-                int m = 0;
+                int i1 = 0;
 
-                for(int n = 0; n < j; ++n) {
-                    double e = (double)(4 * i + i * m * 6) + (random.nextDouble() - 0.5D) * (double)i * 2.5D;
-                    int o = (int)Math.round(Math.cos(d) * e);
-                    int p = (int)Math.round(Math.sin(d) * e);
-                    BlockPos blockPos = this.biomeSource.findBiomeHorizontal(SectionPos.sectionToBlockCoord(o, 8), 0, SectionPos.sectionToBlockCoord(p, 8), 112, list::contains, random, this.climateSampler());
-                    if (blockPos != null) {
-                        o = SectionPos.blockToSectionCoord(blockPos.getX());
-                        p = SectionPos.blockToSectionCoord(blockPos.getZ());
+                for (int j1 = 0; j1 < j; ++j1) {
+                    double d1 = (double) (4 * i + i * i1 * 6) + (random.nextDouble() - 0.5D) * (double) i * 2.5D;
+                    int k1 = (int) Math.round(Math.cos(d0) * d1);
+                    int l1 = (int) Math.round(Math.sin(d0) * d1);
+                    BiomeSource worldchunkmanager = this.biomeSource;
+                    int i2 = SectionPos.sectionToBlockCoord(k1, 8);
+                    int j2 = SectionPos.sectionToBlockCoord(l1, 8);
+
+                    Objects.requireNonNull(list);
+                    BlockPos blockposition = worldchunkmanager.findBiomeHorizontal(i2, 0, j2, 112, list::contains, random, this.climateSampler());
+
+                    if (blockposition != null) {
+                        k1 = SectionPos.blockToSectionCoord(blockposition.getX());
+                        l1 = SectionPos.blockToSectionCoord(blockposition.getZ());
                     }
 
-                    this.strongholdPositions.add(new ChunkPos(o, p));
-                    d += (Math.PI * 2D) / (double)k;
+                    this.strongholdPositions.add(new ChunkPos(k1, l1));
+                    d0 += 6.283185307179586D / (double) k;
                     ++l;
                     if (l == k) {
-                        ++m;
+                        ++i1;
                         l = 0;
-                        k += 2 * k / (m + 1);
-                        k = Math.min(k, j - n);
-                        d += random.nextDouble() * Math.PI * 2.0D;
+                        k += 2 * k / (i1 + 1);
+                        k = Math.min(k, j - j1);
+                        d0 += random.nextDouble() * 3.141592653589793D * 2.0D;
                     }
                 }
 
@@ -134,8 +149,9 @@
     }
 
     private static boolean validStrongholdBiome(Biome biome) {
-        Biome.BiomeCategory biomeCategory = biome.getBiomeCategory();
-        return biomeCategory != Biome.BiomeCategory.OCEAN && biomeCategory != Biome.BiomeCategory.RIVER && biomeCategory != Biome.BiomeCategory.BEACH && biomeCategory != Biome.BiomeCategory.SWAMP && biomeCategory != Biome.BiomeCategory.NETHER && biomeCategory != Biome.BiomeCategory.THEEND;
+        Biome.BiomeCategory biomebase_geography = biome.getBiomeCategory();
+
+        return biomebase_geography != Biome.BiomeCategory.OCEAN && biomebase_geography != Biome.BiomeCategory.RIVER && biomebase_geography != Biome.BiomeCategory.BEACH && biomebase_geography != Biome.BiomeCategory.SWAMP && biomebase_geography != Biome.BiomeCategory.NETHER && biomebase_geography != Biome.BiomeCategory.THEEND;
     }
 
     protected abstract Codec<? extends ChunkGenerator> codec();
@@ -148,7 +164,10 @@
 
     public CompletableFuture<ChunkAccess> createBiomes(Registry<Biome> biomeRegistry, Executor executor, Blender blender, StructureFeatureManager structureAccessor, ChunkAccess chunk) {
         return CompletableFuture.supplyAsync(Util.wrapThreadWithTaskName("init_biomes", () -> {
-            chunk.fillBiomesFromNoise(this.runtimeBiomeSource::getNoiseBiome, this.climateSampler());
+            BiomeSource worldchunkmanager = this.runtimeBiomeSource;
+
+            Objects.requireNonNull(this.runtimeBiomeSource);
+            chunk.fillBiomesFromNoise(worldchunkmanager::getNoiseBiome, this.climateSampler());
             return chunk;
         }), Util.backgroundExecutor());
     }
@@ -164,152 +183,244 @@
 
     @Nullable
     public BlockPos findNearestMapFeature(ServerLevel world, StructureFeature<?> structureFeature, BlockPos center, int radius, boolean skipExistingChunks) {
+        // Paper start
+        org.bukkit.World world1 = world.getWorld();
+        org.bukkit.Location originLocation = new org.bukkit.Location(world1, center.getX(), center.getY(), center.getZ());
+        io.papermc.paper.event.world.StructureLocateEvent event = new io.papermc.paper.event.world.StructureLocateEvent(world1, originLocation, org.bukkit.StructureType.getStructureTypes().get(structureFeature.getFeatureName()), radius, skipExistingChunks);
+        if(!event.callEvent()) return null;
+        // If event call set a final location, skip structure finding and just return set result.
+        if(event.getResult() != null) return new BlockPos(event.getResult().getBlockX(), event.getResult().getBlockY(), event.getResult().getBlockZ());
+        // Get origin location (re)defined by event call.
+        center = new BlockPos(event.getOrigin().getBlockX(), event.getOrigin().getBlockY(), event.getOrigin().getBlockZ());
+        // Get radius and whether to find unexplored structures (re)defined by event call.
+        radius = event.getRadius();
+        skipExistingChunks = event.shouldFindUnexplored();
+        structureFeature = StructureFeature.STRUCTURES_REGISTRY.get(event.getType().getName());
+        // Paper end
         if (structureFeature == StructureFeature.STRONGHOLD) {
             this.generateStrongholds();
-            BlockPos blockPos = null;
-            double d = Double.MAX_VALUE;
-            BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
+            BlockPos blockposition1 = null;
+            double d0 = Double.MAX_VALUE;
+            BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
+            Iterator iterator = this.strongholdPositions.iterator();
 
-            for(ChunkPos chunkPos : this.strongholdPositions) {
-                mutableBlockPos.set(SectionPos.sectionToBlockCoord(chunkPos.x, 8), 32, SectionPos.sectionToBlockCoord(chunkPos.z, 8));
-                double e = mutableBlockPos.distSqr(center);
-                if (blockPos == null) {
-                    blockPos = new BlockPos(mutableBlockPos);
-                    d = e;
-                } else if (e < d) {
-                    blockPos = new BlockPos(mutableBlockPos);
-                    d = e;
+            while (iterator.hasNext()) {
+                ChunkPos chunkcoordintpair = (ChunkPos) iterator.next();
+
+                blockposition_mutableblockposition.set(SectionPos.sectionToBlockCoord(chunkcoordintpair.x, 8), 32, SectionPos.sectionToBlockCoord(chunkcoordintpair.z, 8));
+                double d1 = blockposition_mutableblockposition.distSqr(center);
+
+                if (blockposition1 == null) {
+                    blockposition1 = new BlockPos(blockposition_mutableblockposition);
+                    d0 = d1;
+                } else if (d1 < d0) {
+                    blockposition1 = new BlockPos(blockposition_mutableblockposition);
+                    d0 = d1;
                 }
             }
 
-            return blockPos;
+            return blockposition1;
         } else {
-            StructureFeatureConfiguration structureFeatureConfiguration = this.settings.getConfig(structureFeature);
-            ImmutableMultimap<ConfiguredStructureFeature<?, ?>, ResourceKey<Biome>> immutableMultimap = this.settings.structures(structureFeature);
-            if (structureFeatureConfiguration != null && !immutableMultimap.isEmpty()) {
-                Registry<Biome> registry = world.registryAccess().registryOrThrow(Registry.BIOME_REGISTRY);
-                Set<ResourceKey<Biome>> set = this.runtimeBiomeSource.possibleBiomes().stream().flatMap((biome) -> {
-                    return registry.getResourceKey(biome).stream();
+            this.updateStructureSettings(world, this.settings); // Spigot
+            StructureFeatureConfiguration structuresettingsfeature = this.settings.getConfig(structureFeature);
+            ImmutableMultimap<ConfiguredStructureFeature<?, ?>, ResourceKey<Biome>> immutablemultimap = this.settings.structures(structureFeature);
+
+            if (structuresettingsfeature != null && !immutablemultimap.isEmpty()) {
+                Registry<Biome> iregistry = world.registryAccess().registryOrThrow(Registry.BIOME_REGISTRY);
+                Set<ResourceKey<Biome>> set = (Set) this.runtimeBiomeSource.possibleBiomes().stream().flatMap((biomebase) -> {
+                    return iregistry.getResourceKey(biomebase).stream();
                 }).collect(Collectors.toSet());
-                return immutableMultimap.values().stream().noneMatch(set::contains) ? null : structureFeature.getNearestGeneratedFeature(world, world.structureFeatureManager(), center, radius, skipExistingChunks, world.getSeed(), structureFeatureConfiguration);
+                Stream stream = immutablemultimap.values().stream();
+
+                Objects.requireNonNull(set);
+                return stream.noneMatch(set::contains) ? null : structureFeature.getNearestGeneratedFeature(world, world.structureFeatureManager(), center, radius, skipExistingChunks, world.getSeed(), structuresettingsfeature);
             } else {
                 return null;
             }
         }
     }
 
-    public void applyBiomeDecoration(WorldGenLevel world, ChunkAccess chunk, StructureFeatureManager structureAccessor) {
-        ChunkPos chunkPos = chunk.getPos();
-        if (!SharedConstants.debugVoidTerrain(chunkPos)) {
-            SectionPos sectionPos = SectionPos.of(chunkPos, world.getMinSection());
-            BlockPos blockPos = sectionPos.origin();
-            Map<Integer, List<StructureFeature<?>>> map = Registry.STRUCTURE_FEATURE.stream().collect(Collectors.groupingBy((structureFeature) -> {
-                return structureFeature.step().ordinal();
+    public void addVanillaDecorations(WorldGenLevel generatoraccessseed, ChunkAccess ichunkaccess, StructureFeatureManager structuremanager) { // CraftBukkit
+        ChunkPos chunkcoordintpair = ichunkaccess.getPos();
+
+        if (!SharedConstants.debugVoidTerrain(chunkcoordintpair)) {
+            SectionPos sectionposition = SectionPos.of(chunkcoordintpair, generatoraccessseed.getMinSection());
+            BlockPos blockposition = sectionposition.origin();
+            Map<Integer, List<StructureFeature<?>>> map = (Map) Registry.STRUCTURE_FEATURE.stream().collect(Collectors.groupingBy((structuregenerator) -> {
+                return structuregenerator.step().ordinal();
             }));
             List<BiomeSource.StepFeatureData> list = this.biomeSource.featuresPerStep();
-            WorldgenRandom worldgenRandom = new WorldgenRandom(new XoroshiroRandomSource(RandomSupport.seedUniquifier()));
-            long l = worldgenRandom.setDecorationSeed(world.getSeed(), blockPos.getX(), blockPos.getZ());
-            Set<Biome> set = new ObjectArraySet<>();
+            WorldgenRandom seededrandom = new WorldgenRandom(new XoroshiroRandomSource(RandomSupport.seedUniquifier()));
+            long i = seededrandom.setDecorationSeed(generatoraccessseed.getSeed(), blockposition.getX(), blockposition.getZ());
+            Set<Biome> set = new ObjectArraySet();
+
             if (this instanceof FlatLevelSource) {
                 set.addAll(this.biomeSource.possibleBiomes());
             } else {
-                ChunkPos.rangeClosed(sectionPos.chunk(), 1).forEach((chunkPosx) -> {
-                    ChunkAccess chunkAccess = world.getChunk(chunkPosx.x, chunkPosx.z);
+                ChunkPos.rangeClosed(sectionposition.chunk(), 1).forEach((chunkcoordintpair1) -> {
+                    ChunkAccess ichunkaccess1 = generatoraccessseed.getChunk(chunkcoordintpair1.x, chunkcoordintpair1.z);
+                    LevelChunkSection[] achunksection = ichunkaccess1.getSections();
+                    int j = achunksection.length;
 
-                    for(LevelChunkSection levelChunkSection : chunkAccess.getSections()) {
-                        levelChunkSection.getBiomes().getAll(set::add);
+                    for (int k = 0; k < j; ++k) {
+                        LevelChunkSection chunksection = achunksection[k];
+                        PalettedContainer<Biome> datapaletteblock = chunksection.getBiomes(); // CraftBukkit - decompile error
+
+                        Objects.requireNonNull(set);
+                        datapaletteblock.getAll(set::add);
                     }
 
                 });
                 set.retainAll(this.biomeSource.possibleBiomes());
             }
 
-            int i = list.size();
+            int j = list.size();
 
             try {
-                Registry<PlacedFeature> registry = world.registryAccess().registryOrThrow(Registry.PLACED_FEATURE_REGISTRY);
-                Registry<StructureFeature<?>> registry2 = world.registryAccess().registryOrThrow(Registry.STRUCTURE_FEATURE_REGISTRY);
-                int j = Math.max(GenerationStep.Decoration.values().length, i);
+                Registry<PlacedFeature> iregistry = generatoraccessseed.registryAccess().registryOrThrow(Registry.PLACED_FEATURE_REGISTRY); // Paper - diff on change
+                Registry<StructureFeature<?>> iregistry1 = generatoraccessseed.registryAccess().registryOrThrow(Registry.STRUCTURE_FEATURE_REGISTRY);
+                int k = Math.max(GenerationStep.Decoration.values().length, j);
 
-                for(int k = 0; k < j; ++k) {
-                    int m = 0;
-                    if (structureAccessor.shouldGenerateFeatures()) {
-                        for(StructureFeature<?> structureFeature : map.getOrDefault(k, Collections.emptyList())) {
-                            worldgenRandom.setFeatureSeed(l, m, k);
-                            Supplier<String> supplier = () -> {
-                                return registry2.getResourceKey(structureFeature).map(Object::toString).orElseGet(structureFeature::toString);
+                for (int l = 0; l < k; ++l) {
+                    int i1 = 0;
+                    Iterator iterator;
+                    CrashReportCategory crashreportsystemdetails;
+
+                    if (structuremanager.shouldGenerateFeatures()) {
+                        List<StructureFeature<?>> list1 = (List) map.getOrDefault(l, Collections.emptyList());
+
+                        for (iterator = list1.iterator(); iterator.hasNext(); ++i1) {
+                            StructureFeature<?> structuregenerator = (StructureFeature) iterator.next();
+
+                            seededrandom.setFeatureSeed(i, i1, l);
+                            Supplier<String> supplier = () -> { // CraftBukkit - decompile error
+                                Optional optional = iregistry1.getResourceKey(structuregenerator).map(Object::toString);
+
+                                Objects.requireNonNull(structuregenerator);
+                                return (String) optional.orElseGet(structuregenerator::toString);
                             };
 
                             try {
-                                world.setCurrentlyGenerating(supplier);
-                                structureAccessor.startsForFeature(sectionPos, structureFeature).forEach((structureStart) -> {
-                                    structureStart.placeInChunk(world, structureAccessor, this, worldgenRandom, getWritableArea(chunk), chunkPos);
+                                generatoraccessseed.setCurrentlyGenerating(supplier);
+                                structuremanager.startsForFeature(sectionposition, structuregenerator).forEach((structurestart) -> {
+                                    structurestart.placeInChunk(generatoraccessseed, structuremanager, this, seededrandom, ChunkGenerator.getWritableArea(ichunkaccess), chunkcoordintpair);
                                 });
-                            } catch (Exception var29) {
-                                CrashReport crashReport = CrashReport.forThrowable(var29, "Feature placement");
-                                crashReport.addCategory("Feature").setDetail("Description", supplier::get);
-                                throw new ReportedException(crashReport);
-                            }
+                            } catch (Exception exception) {
+                                CrashReport crashreport = CrashReport.forThrowable(exception, "Feature placement");
 
-                            ++m;
+                                crashreportsystemdetails = crashreport.addCategory("Feature");
+                                Objects.requireNonNull(supplier);
+                                crashreportsystemdetails.setDetail("Description", supplier::get);
+                                throw new ReportedException(crashreport);
+                            }
                         }
                     }
 
-                    if (k < i) {
-                        IntSet intSet = new IntArraySet();
+                    if (l < j) {
+                        IntArraySet intarrayset = new IntArraySet();
 
-                        for(Biome biome : set) {
-                            List<List<Supplier<PlacedFeature>>> list3 = biome.getGenerationSettings().features();
-                            if (k < list3.size()) {
-                                List<Supplier<PlacedFeature>> list4 = list3.get(k);
-                                BiomeSource.StepFeatureData stepFeatureData = list.get(k);
-                                list4.stream().map(Supplier::get).forEach((placedFeaturex) -> {
-                                    intSet.add(stepFeatureData.indexMapping().applyAsInt(placedFeaturex));
+                        iterator = set.iterator();
+
+                        while (iterator.hasNext()) {
+                            Biome biomebase = (Biome) iterator.next();
+                            List<List<Supplier<PlacedFeature>>> list2 = biomebase.getGenerationSettings().features();
+
+                            if (l < list2.size()) {
+                                List<Supplier<PlacedFeature>> list3 = (List) list2.get(l);
+                                BiomeSource.StepFeatureData worldchunkmanager_b = (BiomeSource.StepFeatureData) list.get(l);
+
+                                list3.stream().map(Supplier::get).forEach((placedfeature) -> {
+                                    intarrayset.add(worldchunkmanager_b.indexMapping().applyAsInt(placedfeature));
                                 });
                             }
                         }
 
-                        int n = intSet.size();
-                        int[] is = intSet.toIntArray();
-                        Arrays.sort(is);
-                        BiomeSource.StepFeatureData stepFeatureData2 = list.get(k);
+                        int j1 = intarrayset.size();
+                        int[] aint = intarrayset.toIntArray();
 
-                        for(int o = 0; o < n; ++o) {
-                            int p = is[o];
-                            PlacedFeature placedFeature = stepFeatureData2.features().get(p);
-                            Supplier<String> supplier2 = () -> {
-                                return registry.getResourceKey(placedFeature).map(Object::toString).orElseGet(placedFeature::toString);
+                        Arrays.sort(aint);
+                        BiomeSource.StepFeatureData worldchunkmanager_b1 = (BiomeSource.StepFeatureData) list.get(l);
+
+                        for (int k1 = 0; k1 < j1; ++k1) {
+                            int l1 = aint[k1];
+                            PlacedFeature placedfeature = (PlacedFeature) worldchunkmanager_b1.features().get(l1);
+                            Supplier<String> supplier1 = () -> {
+                                Optional optional = iregistry.getResourceKey(placedfeature).map(Object::toString);
+
+                                Objects.requireNonNull(placedfeature);
+                                return (String) optional.orElseGet(placedfeature::toString);
                             };
-                            worldgenRandom.setFeatureSeed(l, p, k);
+
+                            // Paper start - change populationSeed used in random
+                            long featurePopulationSeed = i;
+                            final net.minecraft.resources.ResourceLocation location = iregistry.getKey(placedfeature);
+                            final long configFeatureSeed = generatoraccessseed.getMinecraftWorld().paperConfig.featureSeeds.getLong(location);
+                            if (configFeatureSeed != -1) {
+                                featurePopulationSeed = seededrandom.setDecorationSeed(configFeatureSeed, blockposition.getX(), blockposition.getZ()); // See seededrandom.setDecorationSeed from above
+                            }
+                            seededrandom.setFeatureSeed(featurePopulationSeed, l1, l);
+                            // Paper end
 
                             try {
-                                world.setCurrentlyGenerating(supplier2);
-                                placedFeature.placeWithBiomeCheck(world, this, worldgenRandom, blockPos);
-                            } catch (Exception var30) {
-                                CrashReport crashReport2 = CrashReport.forThrowable(var30, "Feature placement");
-                                crashReport2.addCategory("Feature").setDetail("Description", supplier2::get);
-                                throw new ReportedException(crashReport2);
+                                generatoraccessseed.setCurrentlyGenerating(supplier1);
+                                placedfeature.placeWithBiomeCheck(generatoraccessseed, this, seededrandom, blockposition);
+                            } catch (Exception exception1) {
+                                CrashReport crashreport1 = CrashReport.forThrowable(exception1, "Feature placement");
+
+                                crashreportsystemdetails = crashreport1.addCategory("Feature");
+                                Objects.requireNonNull(supplier1);
+                                crashreportsystemdetails.setDetail("Description", supplier1::get);
+                                throw new ReportedException(crashreport1);
                             }
                         }
                     }
                 }
 
-                world.setCurrentlyGenerating((Supplier<String>)null);
-            } catch (Exception var31) {
-                CrashReport crashReport3 = CrashReport.forThrowable(var31, "Biome decoration");
-                crashReport3.addCategory("Generation").setDetail("CenterX", chunkPos.x).setDetail("CenterZ", chunkPos.z).setDetail("Seed", l);
-                throw new ReportedException(crashReport3);
+                generatoraccessseed.setCurrentlyGenerating((Supplier) null);
+            } catch (Exception exception2) {
+                CrashReport crashreport2 = CrashReport.forThrowable(exception2, "Biome decoration");
+
+                crashreport2.addCategory("Generation").setDetail("CenterX", (Object) chunkcoordintpair.x).setDetail("CenterZ", (Object) chunkcoordintpair.z).setDetail("Seed", (Object) i);
+                throw new ReportedException(crashreport2);
             }
         }
     }
 
+    public void applyBiomeDecoration(WorldGenLevel world, ChunkAccess chunk, StructureFeatureManager structureAccessor) {
+        // CraftBukkit start
+        this.applyBiomeDecoration(world, chunk, structureAccessor, true);
+    }
+
+    public void applyBiomeDecoration(WorldGenLevel generatoraccessseed, ChunkAccess ichunkaccess, StructureFeatureManager structuremanager, boolean vanilla) {
+        if (vanilla) {
+            this.addVanillaDecorations(generatoraccessseed, ichunkaccess, structuremanager);
+        }
+
+        org.bukkit.World world = generatoraccessseed.getMinecraftWorld().getWorld();
+        // only call when a populator is present (prevents unnecessary entity conversion)
+        if (!world.getPopulators().isEmpty()) {
+            org.bukkit.craftbukkit.v1_18_R1.generator.CraftLimitedRegion limitedRegion = new org.bukkit.craftbukkit.v1_18_R1.generator.CraftLimitedRegion(generatoraccessseed, ichunkaccess.getPos());
+            int x = ichunkaccess.getPos().x;
+            int z = ichunkaccess.getPos().z;
+            for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
+                WorldgenRandom seededrandom = new WorldgenRandom(new net.minecraft.world.level.levelgen.LegacyRandomSource(generatoraccessseed.getSeed()));
+                seededrandom.setDecorationSeed(generatoraccessseed.getSeed(), x, z);
+                populator.populate(world, seededrandom, x, z, limitedRegion);
+            }
+            limitedRegion.saveEntities();
+            limitedRegion.breakLink();
+        }
+        // CraftBukkit end
+    }
+
     private static BoundingBox getWritableArea(ChunkAccess chunk) {
-        ChunkPos chunkPos = chunk.getPos();
-        int i = chunkPos.getMinBlockX();
-        int j = chunkPos.getMinBlockZ();
-        LevelHeightAccessor levelHeightAccessor = chunk.getHeightAccessorForGeneration();
-        int k = levelHeightAccessor.getMinBuildHeight() + 1;
-        int l = levelHeightAccessor.getMaxBuildHeight() - 1;
+        ChunkPos chunkcoordintpair = chunk.getPos();
+        int i = chunkcoordintpair.getMinBlockX();
+        int j = chunkcoordintpair.getMinBlockZ();
+        LevelHeightAccessor levelheightaccessor = chunk.getHeightAccessorForGeneration();
+        int k = levelheightaccessor.getMinBuildHeight() + 1;
+        int l = levelheightaccessor.getMaxBuildHeight() - 1;
+
         return new BoundingBox(i, k, j, i + 15, l, j + 15);
     }
 
@@ -336,39 +447,57 @@
     }
 
     public void createStructures(RegistryAccess registryManager, StructureFeatureManager structureAccessor, ChunkAccess chunk, StructureManager structureManager, long worldSeed) {
-        ChunkPos chunkPos = chunk.getPos();
-        SectionPos sectionPos = SectionPos.bottomOf(chunk);
-        StructureFeatureConfiguration structureFeatureConfiguration = this.settings.getConfig(StructureFeature.STRONGHOLD);
-        if (structureFeatureConfiguration != null) {
-            StructureStart<?> structureStart = structureAccessor.getStartForFeature(sectionPos, StructureFeature.STRONGHOLD, chunk);
-            if (structureStart == null || !structureStart.isValid()) {
-                StructureStart<?> structureStart2 = StructureFeatures.STRONGHOLD.generate(registryManager, this, this.biomeSource, structureManager, worldSeed, chunkPos, fetchReferences(structureAccessor, chunk, sectionPos, StructureFeature.STRONGHOLD), structureFeatureConfiguration, chunk, ChunkGenerator::validStrongholdBiome);
-                structureAccessor.setStartForFeature(sectionPos, StructureFeature.STRONGHOLD, structureStart2, chunk);
+        ChunkPos chunkcoordintpair = chunk.getPos();
+        SectionPos sectionposition = SectionPos.bottomOf(chunk);
+        this.updateStructureSettings(structureAccessor.getWorld(), this.settings); // Spigot
+        StructureFeatureConfiguration structuresettingsfeature = this.settings.getConfig(StructureFeature.STRONGHOLD);
+
+        if (structuresettingsfeature != null) {
+            StructureStart<?> structurestart = structureAccessor.getStartForFeature(sectionposition, StructureFeature.STRONGHOLD, chunk);
+
+            if (structurestart == null || !structurestart.isValid()) {
+                StructureStart<?> structurestart1 = StructureFeatures.STRONGHOLD.generate(registryManager, this, this.biomeSource, structureManager, worldSeed, chunkcoordintpair, ChunkGenerator.fetchReferences(structureAccessor, chunk, sectionposition, StructureFeature.STRONGHOLD), structuresettingsfeature, chunk, ChunkGenerator::validStrongholdBiome);
+
+                structureAccessor.setStartForFeature(sectionposition, StructureFeature.STRONGHOLD, structurestart1, chunk);
             }
         }
 
-        Registry<Biome> registry = registryManager.registryOrThrow(Registry.BIOME_REGISTRY);
+        Registry<Biome> iregistry = registryManager.registryOrThrow(Registry.BIOME_REGISTRY);
+        Iterator iterator = Registry.STRUCTURE_FEATURE.iterator();
 
-        label48:
-        for(StructureFeature<?> structureFeature : Registry.STRUCTURE_FEATURE) {
-            if (structureFeature != StructureFeature.STRONGHOLD) {
-                StructureFeatureConfiguration structureFeatureConfiguration2 = this.settings.getConfig(structureFeature);
-                if (structureFeatureConfiguration2 != null) {
-                    StructureStart<?> structureStart3 = structureAccessor.getStartForFeature(sectionPos, structureFeature, chunk);
-                    if (structureStart3 == null || !structureStart3.isValid()) {
-                        int i = fetchReferences(structureAccessor, chunk, sectionPos, structureFeature);
+        label37:
+        while (iterator.hasNext()) {
+            StructureFeature<?> structuregenerator = (StructureFeature) iterator.next();
 
-                        for(Entry<ConfiguredStructureFeature<?, ?>, Collection<ResourceKey<Biome>>> entry : this.settings.structures(structureFeature).asMap().entrySet()) {
-                            StructureStart<?> structureStart4 = entry.getKey().generate(registryManager, this, this.biomeSource, structureManager, worldSeed, chunkPos, i, structureFeatureConfiguration2, chunk, (b) -> {
-                                return this.validBiome(registry, entry.getValue()::contains, b);
-                            });
-                            if (structureStart4.isValid()) {
-                                structureAccessor.setStartForFeature(sectionPos, structureFeature, structureStart4, chunk);
-                                continue label48;
+            if (structuregenerator != StructureFeature.STRONGHOLD) {
+                StructureFeatureConfiguration structuresettingsfeature1 = this.settings.getConfig(structuregenerator);
+
+                if (structuresettingsfeature1 != null) {
+                    StructureStart<?> structurestart2 = structureAccessor.getStartForFeature(sectionposition, structuregenerator, chunk);
+
+                    if (structurestart2 == null || !structurestart2.isValid()) {
+                        int j = ChunkGenerator.fetchReferences(structureAccessor, chunk, sectionposition, structuregenerator);
+                        UnmodifiableIterator unmodifiableiterator = this.settings.structures(structuregenerator).asMap().entrySet().iterator();
+
+                        StructureStart structurestart3;
+
+                        do {
+                            if (!unmodifiableiterator.hasNext()) {
+                                structureAccessor.setStartForFeature(sectionposition, structuregenerator, StructureStart.INVALID_START, chunk);
+                                continue label37;
                             }
-                        }
 
-                        structureAccessor.setStartForFeature(sectionPos, structureFeature, StructureStart.INVALID_START, chunk);
+                            Entry<ConfiguredStructureFeature<?, ?>, Collection<ResourceKey<Biome>>> entry = (Entry) unmodifiableiterator.next();
+
+                            structurestart3 = (entry.getKey()).generate(registryManager, this, this.biomeSource, structureManager, worldSeed, chunkcoordintpair, j, structuresettingsfeature1, chunk, (biomebase) -> { // CraftBukkit - decompile error
+                                Collection collection = (Collection) entry.getValue();
+
+                                Objects.requireNonNull(collection);
+                                return this.validBiome(iregistry, collection::contains, biomebase);
+                            });
+                        } while (!structurestart3.isValid());
+
+                        structureAccessor.setStartForFeature(sectionposition, structuregenerator, structurestart3, chunk);
                     }
                 }
             }
@@ -377,46 +506,128 @@
     }
 
     private static int fetchReferences(StructureFeatureManager structureAccessor, ChunkAccess chunk, SectionPos sectionPos, StructureFeature<?> structureFeature) {
-        StructureStart<?> structureStart = structureAccessor.getStartForFeature(sectionPos, structureFeature, chunk);
-        return structureStart != null ? structureStart.getReferences() : 0;
+        StructureStart<?> structurestart = structureAccessor.getStartForFeature(sectionPos, structureFeature, chunk);
+
+        return structurestart != null ? structurestart.getReferences() : 0;
     }
 
     protected boolean validBiome(Registry<Biome> registry, Predicate<ResourceKey<Biome>> condition, Biome biome) {
         return registry.getResourceKey(biome).filter(condition).isPresent();
     }
 
+    // Spigot start
+    private volatile boolean injected;
+    private void updateStructureSettings(net.minecraft.world.level.Level world, StructureSettings settings) {
+        if (this.injected) {
+            return;
+        }
+        synchronized (settings) {
+            if (this.injected) {
+                return;
+            }
+            java.util.Map<StructureFeature<?>, StructureFeatureConfiguration> original = settings.structureConfig();
+            java.util.Map<StructureFeature<?>, StructureFeatureConfiguration> updated = new java.util.HashMap<>();
+            org.spigotmc.SpigotWorldConfig conf = world.spigotConfig;
+
+            for (java.util.Map.Entry<StructureFeature<?>, StructureFeatureConfiguration> entry : original.entrySet()) {
+                String name = Registry.STRUCTURE_FEATURE.getKey(entry.getKey()).getPath();
+                StructureFeatureConfiguration feature = entry.getValue();
+                int seed = feature.salt();
+
+                switch (name) {
+                    case "bastion_remnant":
+                        seed = conf.bastionSeed;
+                        break;
+                    case "desert_pyramid":
+                        seed = conf.desertSeed;
+                        break;
+                    case "endcity":
+                        seed = conf.endCitySeed;
+                        break;
+                    case "fortress":
+                        seed = conf.fortressSeed;
+                        break;
+                    case "igloo":
+                        seed = conf.iglooSeed;
+                        break;
+                    case "jungle_pyramid":
+                        seed = conf.jungleSeed;
+                        break;
+                    case "mansion":
+                        seed = conf.mansionSeed;
+                        break;
+                    case "monument":
+                        seed = conf.monumentSeed;
+                        break;
+                    case "nether_fossil":
+                        seed = conf.fossilSeed;
+                        break;
+                    case "ocean_ruin":
+                        seed = conf.oceanSeed;
+                        break;
+                    case "pillager_outpost":
+                        seed = conf.outpostSeed;
+                        break;
+                    case "ruined_portal":
+                        seed = conf.portalSeed;
+                        break;
+                    case "shipwreck":
+                        seed = conf.shipwreckSeed;
+                        break;
+                    case "swamp_hut":
+                        seed = conf.swampSeed;
+                        break;
+                    case "village":
+                        seed = conf.villageSeed;
+                        break;
+                }
+
+                updated.put(entry.getKey(), new StructureFeatureConfiguration(feature.spacing(), feature.separation(), seed));
+            }
+
+            original.clear();
+            original.putAll(updated);
+            this.injected = true;
+        }
+    }
+    // Spigot end
+
     public void createReferences(WorldGenLevel world, StructureFeatureManager structureAccessor, ChunkAccess chunk) {
-        int i = 8;
-        ChunkPos chunkPos = chunk.getPos();
-        int j = chunkPos.x;
-        int k = chunkPos.z;
-        int l = chunkPos.getMinBlockX();
-        int m = chunkPos.getMinBlockZ();
-        SectionPos sectionPos = SectionPos.bottomOf(chunk);
+        boolean flag = true;
+        ChunkPos chunkcoordintpair = chunk.getPos();
+        int i = chunkcoordintpair.x;
+        int j = chunkcoordintpair.z;
+        int k = chunkcoordintpair.getMinBlockX();
+        int l = chunkcoordintpair.getMinBlockZ();
+        SectionPos sectionposition = SectionPos.bottomOf(chunk);
 
-        for(int n = j - 8; n <= j + 8; ++n) {
-            for(int o = k - 8; o <= k + 8; ++o) {
-                long p = ChunkPos.asLong(n, o);
+        for (int i1 = i - 8; i1 <= i + 8; ++i1) {
+            for (int j1 = j - 8; j1 <= j + 8; ++j1) {
+                long k1 = ChunkPos.asLong(i1, j1);
+                Iterator iterator = world.getChunk(i1, j1).getAllStarts().values().iterator();
+
+                while (iterator.hasNext()) {
+                    StructureStart structurestart = (StructureStart) iterator.next();
 
-                for(StructureStart<?> structureStart : world.getChunk(n, o).getAllStarts().values()) {
                     try {
-                        if (structureStart.isValid() && structureStart.getBoundingBox().intersects(l, m, l + 15, m + 15)) {
-                            structureAccessor.addReferenceForFeature(sectionPos, structureStart.getFeature(), p, chunk);
-                            DebugPackets.sendStructurePacket(world, structureStart);
+                        if (structurestart.isValid() && structurestart.getBoundingBox().intersects(k, l, k + 15, l + 15)) {
+                            structureAccessor.addReferenceForFeature(sectionposition, structurestart.getFeature(), k1, chunk);
+                            DebugPackets.sendStructurePacket(world, structurestart);
                         }
-                    } catch (Exception var20) {
-                        CrashReport crashReport = CrashReport.forThrowable(var20, "Generating structure reference");
-                        CrashReportCategory crashReportCategory = crashReport.addCategory("Structure");
-                        crashReportCategory.setDetail("Id", () -> {
-                            return Registry.STRUCTURE_FEATURE.getKey(structureStart.getFeature()).toString();
+                    } catch (Exception exception) {
+                        CrashReport crashreport = CrashReport.forThrowable(exception, "Generating structure reference");
+                        CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Structure");
+
+                        crashreportsystemdetails.setDetail("Id", () -> {
+                            return Registry.STRUCTURE_FEATURE.getKey(structurestart.getFeature()).toString();
                         });
-                        crashReportCategory.setDetail("Name", () -> {
-                            return structureStart.getFeature().getFeatureName();
+                        crashreportsystemdetails.setDetail("Name", () -> {
+                            return structurestart.getFeature().getFeatureName();
                         });
-                        crashReportCategory.setDetail("Class", () -> {
-                            return structureStart.getFeature().getClass().getCanonicalName();
+                        crashreportsystemdetails.setDetail("Class", () -> {
+                            return structurestart.getFeature().getClass().getCanonicalName();
                         });
-                        throw new ReportedException(crashReport);
+                        throw new ReportedException(crashreport);
                     }
                 }
             }
@@ -432,7 +643,7 @@
 
     public abstract int getBaseHeight(int x, int z, Heightmap.Types heightmap, LevelHeightAccessor world);
 
-    public abstract NoiseColumn getBaseColumn(int x, int z, LevelHeightAccessor world);
+    public abstract net.minecraft.world.level.NoiseColumn getBaseColumn(int x, int z, LevelHeightAccessor world);
 
     public int getFirstFreeHeight(int x, int z, Heightmap.Types heightmap, LevelHeightAccessor world) {
         return this.getBaseHeight(x, z, heightmap, world);
@@ -451,5 +662,6 @@
         Registry.register(Registry.CHUNK_GENERATOR, "noise", NoiseBasedChunkGenerator.CODEC);
         Registry.register(Registry.CHUNK_GENERATOR, "flat", FlatLevelSource.CODEC);
         Registry.register(Registry.CHUNK_GENERATOR, "debug", DebugLevelSource.CODEC);
+        CODEC = Registry.CHUNK_GENERATOR.byNameCodec().dispatchStable(ChunkGenerator::codec, Function.identity());
     }
 }
